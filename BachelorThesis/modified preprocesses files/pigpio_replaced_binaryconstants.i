# 0 "pigpio.c"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 0 "<command-line>" 2
# 1 "pigpio.c"
# 34 "pigpio.c"
# 1 "/usr/include/stdio.h" 1 3 4
# 27 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 33 "/usr/include/aarch64-linux-gnu/bits/libc-header-start.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 392 "/usr/include/features.h" 3 4
# 1 "/usr/include/features-time64.h" 1 3 4
# 20 "/usr/include/features-time64.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/wordsize.h" 1 3 4
# 21 "/usr/include/features-time64.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/timesize.h" 1 3 4
# 22 "/usr/include/features-time64.h" 2 3 4
# 393 "/usr/include/features.h" 2 3 4
# 486 "/usr/include/features.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/sys/cdefs.h" 1 3 4
# 559 "/usr/include/aarch64-linux-gnu/sys/cdefs.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/wordsize.h" 1 3 4
# 560 "/usr/include/aarch64-linux-gnu/sys/cdefs.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/long-double.h" 1 3 4
# 561 "/usr/include/aarch64-linux-gnu/sys/cdefs.h" 2 3 4
# 487 "/usr/include/features.h" 2 3 4
# 510 "/usr/include/features.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/gnu/stubs.h" 1 3 4




# 1 "/usr/include/aarch64-linux-gnu/bits/wordsize.h" 1 3 4
# 6 "/usr/include/aarch64-linux-gnu/gnu/stubs.h" 2 3 4


# 1 "/usr/include/aarch64-linux-gnu/gnu/stubs-lp64.h" 1 3 4
# 9 "/usr/include/aarch64-linux-gnu/gnu/stubs.h" 2 3 4
# 511 "/usr/include/features.h" 2 3 4
# 34 "/usr/include/aarch64-linux-gnu/bits/libc-header-start.h" 2 3 4
# 28 "/usr/include/stdio.h" 2 3 4





# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 209 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 3 4

# 209 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 34 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 37 "/usr/include/stdio.h" 2 3 4

# 1 "/usr/include/aarch64-linux-gnu/bits/types.h" 1 3 4
# 27 "/usr/include/aarch64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/aarch64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/timesize.h" 1 3 4
# 29 "/usr/include/aarch64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;






typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;



typedef long int __quad_t;
typedef unsigned long int __u_quad_t;







typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
# 141 "/usr/include/aarch64-linux-gnu/bits/types.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/typesizes.h" 1 3 4
# 142 "/usr/include/aarch64-linux-gnu/bits/types.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/time64.h" 1 3 4
# 143 "/usr/include/aarch64-linux-gnu/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef long int __suseconds64_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;




typedef int __sig_atomic_t;
# 39 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/types/__fpos_t.h" 1 3 4




# 1 "/usr/include/aarch64-linux-gnu/bits/types/__mbstate_t.h" 1 3 4
# 13 "/usr/include/aarch64-linux-gnu/bits/types/__mbstate_t.h" 3 4
typedef struct
{
  int __count;
  union
  {
    unsigned int __wch;
    char __wchb[4];
  } __value;
} __mbstate_t;
# 6 "/usr/include/aarch64-linux-gnu/bits/types/__fpos_t.h" 2 3 4




typedef struct _G_fpos_t
{
  __off_t __pos;
  __mbstate_t __state;
} __fpos_t;
# 40 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/types/__fpos64_t.h" 1 3 4
# 10 "/usr/include/aarch64-linux-gnu/bits/types/__fpos64_t.h" 3 4
typedef struct _G_fpos64_t
{
  __off64_t __pos;
  __mbstate_t __state;
} __fpos64_t;
# 41 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/types/__FILE.h" 1 3 4



struct _IO_FILE;
typedef struct _IO_FILE __FILE;
# 42 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/types/FILE.h" 1 3 4



struct _IO_FILE;


typedef struct _IO_FILE FILE;
# 43 "/usr/include/stdio.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/types/struct_FILE.h" 1 3 4
# 35 "/usr/include/aarch64-linux-gnu/bits/types/struct_FILE.h" 3 4
struct _IO_FILE;
struct _IO_marker;
struct _IO_codecvt;
struct _IO_wide_data;




typedef void _IO_lock_t;





struct _IO_FILE
{
  int _flags;


  char *_IO_read_ptr;
  char *_IO_read_end;
  char *_IO_read_base;
  char *_IO_write_base;
  char *_IO_write_ptr;
  char *_IO_write_end;
  char *_IO_buf_base;
  char *_IO_buf_end;


  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;
  int _flags2;
  __off_t _old_offset;


  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];

  _IO_lock_t *_lock;







  __off64_t _offset;

  struct _IO_codecvt *_codecvt;
  struct _IO_wide_data *_wide_data;
  struct _IO_FILE *_freeres_list;
  void *_freeres_buf;
  size_t __pad5;
  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];
};
# 44 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/aarch64-linux-gnu/bits/types/cookie_io_functions_t.h" 1 3 4
# 27 "/usr/include/aarch64-linux-gnu/bits/types/cookie_io_functions_t.h" 3 4
typedef __ssize_t cookie_read_function_t (void *__cookie, char *__buf,
                                          size_t __nbytes);







typedef __ssize_t cookie_write_function_t (void *__cookie, const char *__buf,
                                           size_t __nbytes);







typedef int cookie_seek_function_t (void *__cookie, __off64_t *__pos, int __w);


typedef int cookie_close_function_t (void *__cookie);






typedef struct _IO_cookie_io_functions_t
{
  cookie_read_function_t *read;
  cookie_write_function_t *write;
  cookie_seek_function_t *seek;
  cookie_close_function_t *close;
} cookie_io_functions_t;
# 47 "/usr/include/stdio.h" 2 3 4





typedef __gnuc_va_list va_list;
# 63 "/usr/include/stdio.h" 3 4
typedef __off_t off_t;






typedef __off64_t off64_t;






typedef __ssize_t ssize_t;






typedef __fpos_t fpos_t;




typedef __fpos64_t fpos64_t;
# 133 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/stdio_lim.h" 1 3 4
# 134 "/usr/include/stdio.h" 2 3 4
# 143 "/usr/include/stdio.h" 3 4
extern FILE *stdin;
extern FILE *stdout;
extern FILE *stderr;






extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));



extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ , __leaf__));
# 170 "/usr/include/stdio.h" 3 4
extern int renameat2 (int __oldfd, const char *__old, int __newfd,
        const char *__new, unsigned int __flags) __attribute__ ((__nothrow__ , __leaf__));






extern int fclose (FILE *__stream);
# 188 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile (void)
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) __attribute__ ((__warn_unused_result__));
# 200 "/usr/include/stdio.h" 3 4
extern FILE *tmpfile64 (void)
   __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) __attribute__ ((__warn_unused_result__));



extern char *tmpnam (char[20]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern char *tmpnam_r (char __s[20]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
# 222 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
   __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__warn_unused_result__)) __attribute__ ((__malloc__ (__builtin_free, 1)));






extern int fflush (FILE *__stream);
# 239 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 249 "/usr/include/stdio.h" 3 4
extern int fcloseall (void);
# 258 "/usr/include/stdio.h" 3 4
extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes)
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) __attribute__ ((__warn_unused_result__));




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
# 283 "/usr/include/stdio.h" 3 4
extern FILE *fopen64 (const char *__restrict __filename,
        const char *__restrict __modes)
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) __attribute__ ((__warn_unused_result__));
extern FILE *freopen64 (const char *__restrict __filename,
   const char *__restrict __modes,
   FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));




extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) __attribute__ ((__warn_unused_result__));





extern FILE *fopencookie (void *__restrict __magic_cookie,
     const char *__restrict __modes,
     cookie_io_functions_t __io_funcs) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) __attribute__ ((__warn_unused_result__));




extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) __attribute__ ((__warn_unused_result__));




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (fclose, 1))) __attribute__ ((__warn_unused_result__));
# 328 "/usr/include/stdio.h" 3 4
extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));




extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ , __leaf__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));







extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));



extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));





extern int vasprintf (char **__restrict __ptr, const char *__restrict __f,
        __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0))) __attribute__ ((__warn_unused_result__));
extern int __asprintf (char **__restrict __ptr,
         const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) __attribute__ ((__warn_unused_result__));
extern int asprintf (char **__restrict __ptr,
       const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3))) __attribute__ ((__warn_unused_result__));




extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));







extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) __attribute__ ((__warn_unused_result__));




extern int scanf (const char *__restrict __format, ...) __attribute__ ((__warn_unused_result__));

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));





# 1 "/usr/include/aarch64-linux-gnu/bits/floatn.h" 1 3 4
# 23 "/usr/include/aarch64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/long-double.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/floatn.h" 2 3 4
# 95 "/usr/include/aarch64-linux-gnu/bits/floatn.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/floatn-common.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/floatn-common.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/long-double.h" 1 3 4
# 25 "/usr/include/aarch64-linux-gnu/bits/floatn-common.h" 2 3 4
# 96 "/usr/include/aarch64-linux-gnu/bits/floatn.h" 2 3 4
# 431 "/usr/include/stdio.h" 2 3 4



extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                          __attribute__ ((__warn_unused_result__));
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                         __attribute__ ((__warn_unused_result__));
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ ("" "__isoc99_sscanf") __attribute__ ((__nothrow__ , __leaf__))

                      ;
# 459 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) __attribute__ ((__warn_unused_result__));





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) __attribute__ ((__warn_unused_result__));


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));





extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) __attribute__ ((__warn_unused_result__));
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) __attribute__ ((__warn_unused_result__));
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vsscanf") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 513 "/usr/include/stdio.h" 3 4
extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);






extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 538 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);
# 549 "/usr/include/stdio.h" 3 4
extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);
# 565 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);







extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 1, 2)));
# 615 "/usr/include/stdio.h" 3 4
extern char *fgets_unlocked (char *__restrict __s, int __n,
        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__))
    __attribute__ ((__access__ (__write_only__, 1, 2)));
# 632 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
                             size_t *__restrict __n, int __delimiter,
                             FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern __ssize_t getdelim (char **__restrict __lineptr,
                           size_t *__restrict __n, int __delimiter,
                           FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));







extern __ssize_t getline (char **__restrict __lineptr,
                          size_t *__restrict __n,
                          FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));







extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);
# 691 "/usr/include/stdio.h" 3 4
extern int fputs_unlocked (const char *__restrict __s,
      FILE *__restrict __stream);
# 702 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);







extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) __attribute__ ((__warn_unused_result__));




extern void rewind (FILE *__stream);
# 736 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) __attribute__ ((__warn_unused_result__));
# 760 "/usr/include/stdio.h" 3 4
extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 779 "/usr/include/stdio.h" 3 4
extern int fseeko64 (FILE *__stream, __off64_t __off, int __whence);
extern __off64_t ftello64 (FILE *__stream) __attribute__ ((__warn_unused_result__));
extern int fgetpos64 (FILE *__restrict __stream, fpos64_t *__restrict __pos);
extern int fsetpos64 (FILE *__stream, const fpos64_t *__pos);



extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));



extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));







extern void perror (const char *__s);




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
# 823 "/usr/include/stdio.h" 3 4
extern int pclose (FILE *__stream);





extern FILE *popen (const char *__command, const char *__modes)
  __attribute__ ((__malloc__)) __attribute__ ((__malloc__ (pclose, 1))) __attribute__ ((__warn_unused_result__));






extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__access__ (__write_only__, 1)));





extern char *cuserid (char *__s)
  __attribute__ ((__access__ (__write_only__, 1)));




struct obstack;


extern int obstack_printf (struct obstack *__restrict __obstack,
      const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 3)));
extern int obstack_vprintf (struct obstack *__restrict __obstack,
       const char *__restrict __format,
       __gnuc_va_list __args)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 2, 0)));







extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
# 885 "/usr/include/stdio.h" 3 4
extern int __uflow (FILE *);
extern int __overflow (FILE *, int);




# 1 "/usr/include/aarch64-linux-gnu/bits/stdio.h" 1 3 4
# 46 "/usr/include/aarch64-linux-gnu/bits/stdio.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
getchar (void)
{
  return getc (stdin);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fgetc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}





extern __inline __attribute__ ((__gnu_inline__)) int
getc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}


extern __inline __attribute__ ((__gnu_inline__)) int
getchar_unlocked (void)
{
  return (__builtin_expect (((stdin)->_IO_read_ptr >= (stdin)->_IO_read_end), 0) ? __uflow (stdin) : *(unsigned char *) (stdin)->_IO_read_ptr++);
}




extern __inline __attribute__ ((__gnu_inline__)) int
putchar (int __c)
{
  return putc (__c, stdout);
}




extern __inline __attribute__ ((__gnu_inline__)) int
fputc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) int
putc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}


extern __inline __attribute__ ((__gnu_inline__)) int
putchar_unlocked (int __c)
{
  return (__builtin_expect (((stdout)->_IO_write_ptr >= (stdout)->_IO_write_end), 0) ? __overflow (stdout, (unsigned char) (__c)) : (unsigned char) (*(stdout)->_IO_write_ptr++ = (__c)));
}





extern __inline __attribute__ ((__gnu_inline__)) __ssize_t
getline (char **__lineptr, size_t *__n, FILE *__stream)
{
  return __getdelim (__lineptr, __n, '\n', __stream);
}





extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) feof_unlocked (FILE *__stream)
{
  return (((__stream)->_flags & 0x0010) != 0);
}


extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) ferror_unlocked (FILE *__stream)
{
  return (((__stream)->_flags & 0x0020) != 0);
}
# 892 "/usr/include/stdio.h" 2 3 4


# 1 "/usr/include/aarch64-linux-gnu/bits/stdio2.h" 1 3 4
# 26 "/usr/include/aarch64-linux-gnu/bits/stdio2.h" 3 4
extern int __sprintf_chk (char *__restrict __s, int __flag, size_t __slen,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__))
    __attribute__ ((__access__ (__write_only__, 1, 3)));
extern int __vsprintf_chk (char *__restrict __s, int __flag, size_t __slen,
      const char *__restrict __format,
      __gnuc_va_list __ap) __attribute__ ((__nothrow__ , __leaf__))
    __attribute__ ((__access__ (__write_only__, 1, 3)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) sprintf (char *__restrict __s, const char *__restrict __fmt, ...)
{
  return __builtin___sprintf_chk (__s, 2 - 1,
      __builtin_object_size (__s, 2 > 1), __fmt,
      __builtin_va_arg_pack ());
}






extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) vsprintf (char *__restrict __s, const char *__restrict __fmt, __gnuc_va_list __ap)

{
  return __builtin___vsprintf_chk (__s, 2 - 1,
       __builtin_object_size (__s, 2 > 1), __fmt, __ap);
}



extern int __snprintf_chk (char *__restrict __s, size_t __n, int __flag,
      size_t __slen, const char *__restrict __format,
      ...) __attribute__ ((__nothrow__ , __leaf__))
    __attribute__ ((__access__ (__write_only__, 1, 2)));
extern int __vsnprintf_chk (char *__restrict __s, size_t __n, int __flag,
       size_t __slen, const char *__restrict __format,
       __gnuc_va_list __ap) __attribute__ ((__nothrow__ , __leaf__));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) snprintf (char *__restrict __s, size_t __n, const char *__restrict __fmt, ...)

{
  return __builtin___snprintf_chk (__s, __n, 2 - 1,
       __builtin_object_size (__s, 2 > 1), __fmt,
       __builtin_va_arg_pack ());
}






extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) vsnprintf (char *__restrict __s, size_t __n, const char *__restrict __fmt, __gnuc_va_list __ap)

{
  return __builtin___vsnprintf_chk (__s, __n, 2 - 1,
        __builtin_object_size (__s, 2 > 1), __fmt, __ap);
}





extern int __fprintf_chk (FILE *__restrict __stream, int __flag,
     const char *__restrict __format, ...);
extern int __printf_chk (int __flag, const char *__restrict __format, ...);
extern int __vfprintf_chk (FILE *__restrict __stream, int __flag,
      const char *__restrict __format, __gnuc_va_list __ap);
extern int __vprintf_chk (int __flag, const char *__restrict __format,
     __gnuc_va_list __ap);


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
fprintf (FILE *__restrict __stream, const char *__restrict __fmt, ...)
{
  return __fprintf_chk (__stream, 2 - 1, __fmt,
   __builtin_va_arg_pack ());
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
printf (const char *__restrict __fmt, ...)
{
  return __printf_chk (2 - 1, __fmt, __builtin_va_arg_pack ());
}







extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
vprintf (const char *__restrict __fmt, __gnuc_va_list __ap)
{

  return __vfprintf_chk (stdout, 2 - 1, __fmt, __ap);



}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
vfprintf (FILE *__restrict __stream,
   const char *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vfprintf_chk (__stream, 2 - 1, __fmt, __ap);
}


extern int __dprintf_chk (int __fd, int __flag, const char *__restrict __fmt,
     ...) __attribute__ ((__format__ (__printf__, 3, 4)));
extern int __vdprintf_chk (int __fd, int __flag,
      const char *__restrict __fmt, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 3, 0)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
dprintf (int __fd, const char *__restrict __fmt, ...)
{
  return __dprintf_chk (__fd, 2 - 1, __fmt,
   __builtin_va_arg_pack ());
}





extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
vdprintf (int __fd, const char *__restrict __fmt, __gnuc_va_list __ap)
{
  return __vdprintf_chk (__fd, 2 - 1, __fmt, __ap);
}




extern int __asprintf_chk (char **__restrict __ptr, int __flag,
      const char *__restrict __fmt, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__printf__, 3, 4))) __attribute__ ((__warn_unused_result__));
extern int __vasprintf_chk (char **__restrict __ptr, int __flag,
       const char *__restrict __fmt, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__printf__, 3, 0))) __attribute__ ((__warn_unused_result__));
extern int __obstack_printf_chk (struct obstack *__restrict __obstack,
     int __flag, const char *__restrict __format,
     ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__printf__, 3, 4)));
extern int __obstack_vprintf_chk (struct obstack *__restrict __obstack,
      int __flag,
      const char *__restrict __format,
      __gnuc_va_list __args)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__printf__, 3, 0)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) asprintf (char **__restrict __ptr, const char *__restrict __fmt, ...)
{
  return __asprintf_chk (__ptr, 2 - 1, __fmt,
    __builtin_va_arg_pack ());
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) __asprintf (char **__restrict __ptr, const char *__restrict __fmt, ...)

{
  return __asprintf_chk (__ptr, 2 - 1, __fmt,
    __builtin_va_arg_pack ());
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) obstack_printf (struct obstack *__restrict __obstack, const char *__restrict __fmt, ...)

{
  return __obstack_printf_chk (__obstack, 2 - 1, __fmt,
          __builtin_va_arg_pack ());
}
# 214 "/usr/include/aarch64-linux-gnu/bits/stdio2.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) vasprintf (char **__restrict __ptr, const char *__restrict __fmt, __gnuc_va_list __ap)

{
  return __vasprintf_chk (__ptr, 2 - 1, __fmt, __ap);
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) obstack_vprintf (struct obstack *__restrict __obstack, const char *__restrict __fmt, __gnuc_va_list __ap)

{
  return __obstack_vprintf_chk (__obstack, 2 - 1, __fmt,
    __ap);
}
# 248 "/usr/include/aarch64-linux-gnu/bits/stdio2.h" 3 4
extern char *__fgets_chk (char *__restrict __s, size_t __size, int __n,
     FILE *__restrict __stream)
    __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 1, 3)));
extern char *__fgets_alias (char *__restrict __s, int __n, FILE *__restrict __stream) __asm__ ("" "fgets")


    __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 1, 2)));
extern char *__fgets_chk_warn (char *__restrict __s, size_t __size, int __n, FILE *__restrict __stream) __asm__ ("" "__fgets_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fgets called with bigger size than length " "of destination buffer")))
                                 ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 1, 2))) char *
fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
{
  size_t sz = __builtin_object_size (__s, 2 > 1);
  if ((((__typeof (__n)) 0 < (__typeof (__n)) -1 || (__builtin_constant_p (__n) && (__n) > 0)) && __builtin_constant_p ((((long unsigned int) (__n)) <= (sz) / (sizeof (char)))) && (((long unsigned int) (__n)) <= (sz) / (sizeof (char)))))
    return __fgets_alias (__s, __n, __stream);
  if ((((__typeof (__n)) 0 < (__typeof (__n)) -1 || (__builtin_constant_p (__n) && (__n) > 0)) && __builtin_constant_p ((((long unsigned int) (__n)) <= (sz) / (sizeof (char)))) && !(((long unsigned int) (__n)) <= (sz) / (sizeof (char)))))
    return __fgets_chk_warn (__s, sz, __n, __stream);
  return __fgets_chk (__s, sz, __n, __stream);
}

extern size_t __fread_chk (void *__restrict __ptr, size_t __ptrlen,
      size_t __size, size_t __n,
      FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern size_t __fread_alias (void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "fread")


            __attribute__ ((__warn_unused_result__));
extern size_t __fread_chk_warn (void *__restrict __ptr, size_t __ptrlen, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "__fread_chk")




     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fread called with bigger size * nmemb than length " "of destination buffer")))
                                 ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) size_t
fread (void *__restrict __ptr, size_t __size, size_t __n,
       FILE *__restrict __stream)
{
  size_t sz = __builtin_object_size (__ptr, 0);
  if ((((__typeof (__n)) 0 < (__typeof (__n)) -1 || (__builtin_constant_p (__n) && (__n) > 0)) && __builtin_constant_p ((((long unsigned int) (__n)) <= (sz) / (__size))) && (((long unsigned int) (__n)) <= (sz) / (__size))))
    return __fread_alias (__ptr, __size, __n, __stream);
  if ((((__typeof (__n)) 0 < (__typeof (__n)) -1 || (__builtin_constant_p (__n) && (__n) > 0)) && __builtin_constant_p ((((long unsigned int) (__n)) <= (sz) / (__size))) && !(((long unsigned int) (__n)) <= (sz) / (__size))))
    return __fread_chk_warn (__ptr, sz, __size, __n, __stream);
  return __fread_chk (__ptr, sz, __size, __n, __stream);
}


extern char *__fgets_unlocked_chk (char *__restrict __s, size_t __size,
       int __n, FILE *__restrict __stream)
    __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 1, 3)));
extern char *__fgets_unlocked_alias (char *__restrict __s, int __n, FILE *__restrict __stream) __asm__ ("" "fgets_unlocked")


    __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 1, 2)));
extern char *__fgets_unlocked_chk_warn (char *__restrict __s, size_t __size, int __n, FILE *__restrict __stream) __asm__ ("" "__fgets_unlocked_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fgets_unlocked called with bigger size than length " "of destination buffer")))
                                 ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 1, 2))) char *
fgets_unlocked (char *__restrict __s, int __n, FILE *__restrict __stream)
{
  size_t sz = __builtin_object_size (__s, 2 > 1);
  if ((((__typeof (__n)) 0 < (__typeof (__n)) -1 || (__builtin_constant_p (__n) && (__n) > 0)) && __builtin_constant_p ((((long unsigned int) (__n)) <= (sz) / (sizeof (char)))) && (((long unsigned int) (__n)) <= (sz) / (sizeof (char)))))
    return __fgets_unlocked_alias (__s, __n, __stream);
  if ((((__typeof (__n)) 0 < (__typeof (__n)) -1 || (__builtin_constant_p (__n) && (__n) > 0)) && __builtin_constant_p ((((long unsigned int) (__n)) <= (sz) / (sizeof (char)))) && !(((long unsigned int) (__n)) <= (sz) / (sizeof (char)))))
    return __fgets_unlocked_chk_warn (__s, sz, __n, __stream);
  return __fgets_unlocked_chk (__s, sz, __n, __stream);
}




extern size_t __fread_unlocked_chk (void *__restrict __ptr, size_t __ptrlen,
        size_t __size, size_t __n,
        FILE *__restrict __stream) __attribute__ ((__warn_unused_result__));
extern size_t __fread_unlocked_alias (void *__restrict __ptr, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "fread_unlocked")


                     __attribute__ ((__warn_unused_result__));
extern size_t __fread_unlocked_chk_warn (void *__restrict __ptr, size_t __ptrlen, size_t __size, size_t __n, FILE *__restrict __stream) __asm__ ("" "__fread_unlocked_chk")




     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("fread_unlocked called with bigger size * nmemb than " "length of destination buffer")))
                                        ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) size_t
fread_unlocked (void *__restrict __ptr, size_t __size, size_t __n,
  FILE *__restrict __stream)
{
  size_t sz = __builtin_object_size (__ptr, 0);
  if ((((__typeof (__n)) 0 < (__typeof (__n)) -1 || (__builtin_constant_p (__n) && (__n) > 0)) && __builtin_constant_p ((((long unsigned int) (__n)) <= (sz) / (__size))) && (((long unsigned int) (__n)) <= (sz) / (__size))))
    {

      if (__builtin_constant_p (__size)
   && __builtin_constant_p (__n)
   && (__size | __n) < (((size_t) 1) << (8 * sizeof (size_t) / 2))
   && __size * __n <= 8)
 {
   size_t __cnt = __size * __n;
   char *__cptr = (char *) __ptr;
   if (__cnt == 0)
     return 0;

   for (; __cnt > 0; --__cnt)
     {
       int __c = getc_unlocked (__stream);
       if (__c == (-1))
  break;
       *__cptr++ = __c;
     }
   return (__cptr - (char *) __ptr) / __size;
 }

      return __fread_unlocked_alias (__ptr, __size, __n, __stream);
    }
  if ((((__typeof (__n)) 0 < (__typeof (__n)) -1 || (__builtin_constant_p (__n) && (__n) > 0)) && __builtin_constant_p ((((long unsigned int) (__n)) <= (sz) / (__size))) && !(((long unsigned int) (__n)) <= (sz) / (__size))))
    return __fread_unlocked_chk_warn (__ptr, sz, __size, __n, __stream);
  return __fread_unlocked_chk (__ptr, sz, __size, __n, __stream);

}
# 895 "/usr/include/stdio.h" 2 3 4








# 35 "pigpio.c" 2
# 1 "/usr/include/string.h" 1 3 4
# 26 "/usr/include/string.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/string.h" 2 3 4






# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 34 "/usr/include/string.h" 2 3 4
# 43 "/usr/include/string.h" 3 4
extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
    __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__access__ (__write_only__, 1, 4)));




extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 80 "/usr/include/string.h" 3 4
extern int __memcmpeq (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 107 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 120 "/usr/include/string.h" 3 4
extern void *rawmemchr (const void *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 133 "/usr/include/string.h" 3 4
extern void *memrchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)))
      __attribute__ ((__access__ (__read_only__, 1, 3)));





extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
    __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 1, 3)));



# 1 "/usr/include/aarch64-linux-gnu/bits/types/locale_t.h" 1 3 4
# 22 "/usr/include/aarch64-linux-gnu/bits/types/locale_t.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/types/__locale_t.h" 1 3 4
# 27 "/usr/include/aarch64-linux-gnu/bits/types/__locale_t.h" 3 4
struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
};

typedef struct __locale_struct *__locale_t;
# 23 "/usr/include/aarch64-linux-gnu/bits/types/locale_t.h" 2 3 4

typedef __locale_t locale_t;
# 173 "/usr/include/string.h" 2 3 4


extern int strcoll_l (const char *__s1, const char *__s2, locale_t __l)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    locale_t __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)))
     __attribute__ ((__access__ (__write_only__, 1, 3)));





extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 246 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 273 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 286 "/usr/include/string.h" 3 4
extern char *strchrnul (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 323 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 350 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 380 "/usr/include/string.h" 3 4
extern char *strcasestr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));







extern void *memmem (const void *__haystack, size_t __haystacklen,
       const void *__needle, size_t __needlelen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 3)))
    __attribute__ ((__access__ (__read_only__, 1, 2)))
    __attribute__ ((__access__ (__read_only__, 3, 4)));



extern void *__mempcpy (void *__restrict __dest,
   const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern void *mempcpy (void *__restrict __dest,
        const void *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern char *strerror (int __errnum) __attribute__ ((__nothrow__ , __leaf__));
# 444 "/usr/include/string.h" 3 4
extern char *strerror_r (int __errnum, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 2, 3)));




extern const char *strerrordesc_np (int __err) __attribute__ ((__nothrow__ , __leaf__));

extern const char *strerrorname_np (int __err) __attribute__ ((__nothrow__ , __leaf__));





extern char *strerror_l (int __errnum, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/strings.h" 1 3 4
# 23 "/usr/include/strings.h" 3 4
# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 24 "/usr/include/strings.h" 2 3 4










extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bcopy (const void *__src, void *__dest, size_t __n)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 68 "/usr/include/strings.h" 3 4
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 96 "/usr/include/strings.h" 3 4
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));






extern int ffs (int __i) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));





extern int ffsl (long int __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__ extern int ffsll (long long int __ll)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));






extern int strcasecmp_l (const char *__s1, const char *__s2, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));



extern int strncasecmp_l (const char *__s1, const char *__s2,
     size_t __n, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 4)));








# 1 "/usr/include/aarch64-linux-gnu/bits/strings_fortified.h" 1 3 4
# 22 "/usr/include/aarch64-linux-gnu/bits/strings_fortified.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void
__attribute__ ((__nothrow__ , __leaf__)) bcopy (const void *__src, void *__dest, size_t __len)
{
  (void) __builtin___memmove_chk (__dest, __src, __len,
      __builtin_object_size (__dest, 0));
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void
__attribute__ ((__nothrow__ , __leaf__)) bzero (void *__dest, size_t __len)
{
  (void) __builtin___memset_chk (__dest, '\0', __len,
     __builtin_object_size (__dest, 0));
}
# 145 "/usr/include/strings.h" 2 3 4
# 463 "/usr/include/string.h" 2 3 4



extern void explicit_bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__write_only__, 1, 2)));



extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));



extern const char *sigabbrev_np (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern const char *sigdescr_np (int __sig) __attribute__ ((__nothrow__ , __leaf__));



extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int strverscmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strfry (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void *memfrob (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__read_write__, 1, 2)));
# 527 "/usr/include/string.h" 3 4
extern char *basename (const char *__filename) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







# 1 "/usr/include/aarch64-linux-gnu/bits/string_fortified.h" 1 3 4
# 25 "/usr/include/aarch64-linux-gnu/bits/string_fortified.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void *
__attribute__ ((__nothrow__ , __leaf__)) memcpy (void *__restrict __dest, const void *__restrict __src, size_t __len)

{
  return __builtin___memcpy_chk (__dest, __src, __len,
     __builtin_object_size (__dest, 0));
}

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void *
__attribute__ ((__nothrow__ , __leaf__)) memmove (void *__dest, const void *__src, size_t __len)
{
  return __builtin___memmove_chk (__dest, __src, __len,
      __builtin_object_size (__dest, 0));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void *
__attribute__ ((__nothrow__ , __leaf__)) mempcpy (void *__restrict __dest, const void *__restrict __src, size_t __len)

{
  return __builtin___mempcpy_chk (__dest, __src, __len,
      __builtin_object_size (__dest, 0));
}
# 56 "/usr/include/aarch64-linux-gnu/bits/string_fortified.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void *
__attribute__ ((__nothrow__ , __leaf__)) memset (void *__dest, int __ch, size_t __len)
{
  return __builtin___memset_chk (__dest, __ch, __len,
     __builtin_object_size (__dest, 0));
}




void __explicit_bzero_chk (void *__dest, size_t __len, size_t __destlen)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__access__ (__write_only__, 1, 2)));

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void
__attribute__ ((__nothrow__ , __leaf__)) explicit_bzero (void *__dest, size_t __len)
{
  __explicit_bzero_chk (__dest, __len, __builtin_object_size (__dest, 0));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) strcpy (char *__restrict __dest, const char *__restrict __src)
{
  return __builtin___strcpy_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) stpcpy (char *__restrict __dest, const char *__restrict __src)
{
  return __builtin___stpcpy_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1));
}



extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) strncpy (char *__restrict __dest, const char *__restrict __src, size_t __len)

{
  return __builtin___strncpy_chk (__dest, __src, __len,
      __builtin_object_size (__dest, 2 > 1));
}



extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) stpncpy (char *__dest, const char *__src, size_t __n)
{
  return __builtin___stpncpy_chk (__dest, __src, __n,
      __builtin_object_size (__dest, 2 > 1));
}
# 127 "/usr/include/aarch64-linux-gnu/bits/string_fortified.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) strcat (char *__restrict __dest, const char *__restrict __src)
{
  return __builtin___strcat_chk (__dest, __src, __builtin_object_size (__dest, 2 > 1));
}


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) char *
__attribute__ ((__nothrow__ , __leaf__)) strncat (char *__restrict __dest, const char *__restrict __src, size_t __len)

{
  return __builtin___strncat_chk (__dest, __src, __len,
      __builtin_object_size (__dest, 2 > 1));
}
# 536 "/usr/include/string.h" 2 3 4




# 36 "pigpio.c" 2

# 1 "/usr/include/stdlib.h" 1 3 4
# 26 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdlib.h" 2 3 4





# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 321 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 3 4
typedef unsigned int wchar_t;
# 33 "/usr/include/stdlib.h" 2 3 4







# 1 "/usr/include/aarch64-linux-gnu/bits/waitflags.h" 1 3 4
# 41 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/waitstatus.h" 1 3 4
# 42 "/usr/include/stdlib.h" 2 3 4
# 59 "/usr/include/stdlib.h" 3 4
typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;





__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;
# 98 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));



extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));

extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 141 "/usr/include/stdlib.h" 3 4
extern float strtof32 (const char *__restrict __nptr,
     char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern double strtof64 (const char *__restrict __nptr,
     char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern long double strtof128 (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern double strtof32x (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern long double strtof64x (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 177 "/usr/include/stdlib.h" 3 4
extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int strfromd (char *__dest, size_t __size, const char *__format,
       double __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));

extern int strfromf (char *__dest, size_t __size, const char *__format,
       float __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));

extern int strfroml (char *__dest, size_t __size, const char *__format,
       long double __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
# 233 "/usr/include/stdlib.h" 3 4
extern int strfromf32 (char *__dest, size_t __size, const char * __format,
         float __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf64 (char *__dest, size_t __size, const char * __format,
         double __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf128 (char *__dest, size_t __size, const char * __format,
   long double __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf32x (char *__dest, size_t __size, const char * __format,
   double __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));



extern int strfromf64x (char *__dest, size_t __size, const char * __format,
   long double __f)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
# 275 "/usr/include/stdlib.h" 3 4
extern long int strtol_l (const char *__restrict __nptr,
     char **__restrict __endptr, int __base,
     locale_t __loc) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

extern unsigned long int strtoul_l (const char *__restrict __nptr,
        char **__restrict __endptr,
        int __base, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern long long int strtoll_l (const char *__restrict __nptr,
    char **__restrict __endptr, int __base,
    locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

__extension__
extern unsigned long long int strtoull_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       int __base, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 4)));

extern double strtod_l (const char *__restrict __nptr,
   char **__restrict __endptr, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

extern float strtof_l (const char *__restrict __nptr,
         char **__restrict __endptr, locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));

extern long double strtold_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));
# 317 "/usr/include/stdlib.h" 3 4
extern float strtof32_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern double strtof64_l (const char *__restrict __nptr,
       char **__restrict __endptr,
       locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern long double strtof128_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern double strtof32x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern long double strtof64x_l (const char *__restrict __nptr,
         char **__restrict __endptr,
         locale_t __loc)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));
# 361 "/usr/include/stdlib.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) atoi (const char *__nptr)
{
  return (int) strtol (__nptr, (char **) ((void *)0), 10);
}
extern __inline __attribute__ ((__gnu_inline__)) long int
__attribute__ ((__nothrow__ , __leaf__)) atol (const char *__nptr)
{
  return strtol (__nptr, (char **) ((void *)0), 10);
}


__extension__ extern __inline __attribute__ ((__gnu_inline__)) long long int
__attribute__ ((__nothrow__ , __leaf__)) atoll (const char *__nptr)
{
  return strtoll (__nptr, (char **) ((void *)0), 10);
}
# 386 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));


extern long int a64l (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));




# 1 "/usr/include/aarch64-linux-gnu/sys/types.h" 1 3 4
# 27 "/usr/include/aarch64-linux-gnu/sys/types.h" 3 4






typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;


typedef __loff_t loff_t;




typedef __ino_t ino_t;






typedef __ino64_t ino64_t;




typedef __dev_t dev_t;




typedef __gid_t gid_t;




typedef __mode_t mode_t;




typedef __nlink_t nlink_t;




typedef __uid_t uid_t;
# 97 "/usr/include/aarch64-linux-gnu/sys/types.h" 3 4
typedef __pid_t pid_t;





typedef __id_t id_t;
# 114 "/usr/include/aarch64-linux-gnu/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;




# 1 "/usr/include/aarch64-linux-gnu/bits/types/clock_t.h" 1 3 4






typedef __clock_t clock_t;
# 127 "/usr/include/aarch64-linux-gnu/sys/types.h" 2 3 4

# 1 "/usr/include/aarch64-linux-gnu/bits/types/clockid_t.h" 1 3 4






typedef __clockid_t clockid_t;
# 129 "/usr/include/aarch64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/types/time_t.h" 1 3 4
# 10 "/usr/include/aarch64-linux-gnu/bits/types/time_t.h" 3 4
typedef __time_t time_t;
# 130 "/usr/include/aarch64-linux-gnu/sys/types.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/types/timer_t.h" 1 3 4






typedef __timer_t timer_t;
# 131 "/usr/include/aarch64-linux-gnu/sys/types.h" 2 3 4



typedef __useconds_t useconds_t;



typedef __suseconds_t suseconds_t;





# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 145 "/usr/include/aarch64-linux-gnu/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;




# 1 "/usr/include/aarch64-linux-gnu/bits/stdint-intn.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/stdint-intn.h" 3 4
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
# 156 "/usr/include/aarch64-linux-gnu/sys/types.h" 2 3 4


typedef __uint8_t u_int8_t;
typedef __uint16_t u_int16_t;
typedef __uint32_t u_int32_t;
typedef __uint64_t u_int64_t;


typedef int register_t __attribute__ ((__mode__ (__word__)));
# 176 "/usr/include/aarch64-linux-gnu/sys/types.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 24 "/usr/include/endian.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/endian.h" 1 3 4
# 35 "/usr/include/aarch64-linux-gnu/bits/endian.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/endianness.h" 1 3 4
# 36 "/usr/include/aarch64-linux-gnu/bits/endian.h" 2 3 4
# 25 "/usr/include/endian.h" 2 3 4
# 35 "/usr/include/endian.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/byteswap.h" 1 3 4
# 33 "/usr/include/aarch64-linux-gnu/bits/byteswap.h" 3 4
static __inline __uint16_t
__bswap_16 (__uint16_t __bsx)
{

  return __builtin_bswap16 (__bsx);



}






static __inline __uint32_t
__bswap_32 (__uint32_t __bsx)
{

  return __builtin_bswap32 (__bsx);



}
# 69 "/usr/include/aarch64-linux-gnu/bits/byteswap.h" 3 4
__extension__ static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{

  return __builtin_bswap64 (__bsx);



}
# 36 "/usr/include/endian.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 32 "/usr/include/aarch64-linux-gnu/bits/uintn-identity.h" 3 4
static __inline __uint16_t
__uint16_identity (__uint16_t __x)
{
  return __x;
}

static __inline __uint32_t
__uint32_identity (__uint32_t __x)
{
  return __x;
}

static __inline __uint64_t
__uint64_identity (__uint64_t __x)
{
  return __x;
}
# 37 "/usr/include/endian.h" 2 3 4
# 177 "/usr/include/aarch64-linux-gnu/sys/types.h" 2 3 4


# 1 "/usr/include/aarch64-linux-gnu/sys/select.h" 1 3 4
# 30 "/usr/include/aarch64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/select.h" 1 3 4
# 31 "/usr/include/aarch64-linux-gnu/sys/select.h" 2 3 4


# 1 "/usr/include/aarch64-linux-gnu/bits/types/sigset_t.h" 1 3 4



# 1 "/usr/include/aarch64-linux-gnu/bits/types/__sigset_t.h" 1 3 4




typedef struct
{
  unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
} __sigset_t;
# 5 "/usr/include/aarch64-linux-gnu/bits/types/sigset_t.h" 2 3 4


typedef __sigset_t sigset_t;
# 34 "/usr/include/aarch64-linux-gnu/sys/select.h" 2 3 4



# 1 "/usr/include/aarch64-linux-gnu/bits/types/struct_timeval.h" 1 3 4







struct timeval
{




  __time_t tv_sec;
  __suseconds_t tv_usec;

};
# 38 "/usr/include/aarch64-linux-gnu/sys/select.h" 2 3 4

# 1 "/usr/include/aarch64-linux-gnu/bits/types/struct_timespec.h" 1 3 4
# 11 "/usr/include/aarch64-linux-gnu/bits/types/struct_timespec.h" 3 4
struct timespec
{



  __time_t tv_sec;




  __syscall_slong_t tv_nsec;
# 31 "/usr/include/aarch64-linux-gnu/bits/types/struct_timespec.h" 3 4
};
# 40 "/usr/include/aarch64-linux-gnu/sys/select.h" 2 3 4
# 49 "/usr/include/aarch64-linux-gnu/sys/select.h" 3 4
typedef long int __fd_mask;
# 59 "/usr/include/aarch64-linux-gnu/sys/select.h" 3 4
typedef struct
  {



    __fd_mask fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];





  } fd_set;






typedef __fd_mask fd_mask;
# 91 "/usr/include/aarch64-linux-gnu/sys/select.h" 3 4

# 102 "/usr/include/aarch64-linux-gnu/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 127 "/usr/include/aarch64-linux-gnu/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 150 "/usr/include/aarch64-linux-gnu/sys/select.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/select2.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/select2.h" 3 4
extern long int __fdelt_chk (long int __d);
extern long int __fdelt_warn (long int __d)
  __attribute__((__warning__ ("bit outside of fd_set selected")));
# 151 "/usr/include/aarch64-linux-gnu/sys/select.h" 2 3 4



# 180 "/usr/include/aarch64-linux-gnu/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 219 "/usr/include/aarch64-linux-gnu/sys/types.h" 3 4
typedef __blkcnt64_t blkcnt64_t;
typedef __fsblkcnt64_t fsblkcnt64_t;
typedef __fsfilcnt64_t fsfilcnt64_t;





# 1 "/usr/include/aarch64-linux-gnu/bits/pthreadtypes.h" 1 3 4
# 23 "/usr/include/aarch64-linux-gnu/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/thread-shared-types.h" 1 3 4
# 44 "/usr/include/aarch64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/pthreadtypes-arch.h" 1 3 4
# 45 "/usr/include/aarch64-linux-gnu/bits/thread-shared-types.h" 2 3 4

# 1 "/usr/include/aarch64-linux-gnu/bits/atomic_wide_counter.h" 1 3 4
# 25 "/usr/include/aarch64-linux-gnu/bits/atomic_wide_counter.h" 3 4
typedef union
{
  __extension__ unsigned long long int __value64;
  struct
  {
    unsigned int __low;
    unsigned int __high;
  } __value32;
} __atomic_wide_counter;
# 47 "/usr/include/aarch64-linux-gnu/bits/thread-shared-types.h" 2 3 4




typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;

typedef struct __pthread_internal_slist
{
  struct __pthread_internal_slist *__next;
} __pthread_slist_t;
# 76 "/usr/include/aarch64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/struct_mutex.h" 1 3 4
# 27 "/usr/include/aarch64-linux-gnu/bits/struct_mutex.h" 3 4
struct __pthread_mutex_s
{
  int __lock ;
  unsigned int __count;
  int __owner;

  unsigned int __nusers;
# 58 "/usr/include/aarch64-linux-gnu/bits/struct_mutex.h" 3 4
  int __kind;




  int __spins;
  __pthread_list_t __list;
# 74 "/usr/include/aarch64-linux-gnu/bits/struct_mutex.h" 3 4
};
# 77 "/usr/include/aarch64-linux-gnu/bits/thread-shared-types.h" 2 3 4
# 89 "/usr/include/aarch64-linux-gnu/bits/thread-shared-types.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/struct_rwlock.h" 1 3 4
# 23 "/usr/include/aarch64-linux-gnu/bits/struct_rwlock.h" 3 4
struct __pthread_rwlock_arch_t
{
  unsigned int __readers;
  unsigned int __writers;
  unsigned int __wrphase_futex;
  unsigned int __writers_futex;
  unsigned int __pad3;
  unsigned int __pad4;
  int __cur_writer;
  int __shared;
  unsigned long int __pad1;
  unsigned long int __pad2;
  unsigned int __flags;
};
# 90 "/usr/include/aarch64-linux-gnu/bits/thread-shared-types.h" 2 3 4




struct __pthread_cond_s
{
  __atomic_wide_counter __wseq;
  __atomic_wide_counter __g1_start;
  unsigned int __g_refs[2] ;
  unsigned int __g_size[2];
  unsigned int __g1_orig_size;
  unsigned int __wrefs;
  unsigned int __g_signals[2];
};

typedef unsigned int __tss_t;
typedef unsigned long int __thrd_t;

typedef struct
{
  int __data ;
} __once_flag;
# 24 "/usr/include/aarch64-linux-gnu/bits/pthreadtypes.h" 2 3 4



typedef unsigned long int pthread_t;




typedef union
{
  char __size[8];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  char __size[8];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;


union pthread_attr_t
{
  char __size[64];
  long int __align;
};

typedef union pthread_attr_t pthread_attr_t;




typedef union
{
  struct __pthread_mutex_s __data;
  char __size[48];
  long int __align;
} pthread_mutex_t;


typedef union
{
  struct __pthread_cond_s __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;





typedef union
{
  struct __pthread_rwlock_arch_t __data;
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[8];
  int __align;
} pthread_barrierattr_t;
# 228 "/usr/include/aarch64-linux-gnu/sys/types.h" 2 3 4



# 396 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) __attribute__ ((__nothrow__ , __leaf__));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern int rand (void) __attribute__ ((__nothrow__ , __leaf__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));



extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ , __leaf__));







extern double drand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ , __leaf__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    __extension__ unsigned long long int __a;

  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) __attribute__ ((__warn_unused_result__));

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_size__ (1, 2))) __attribute__ ((__warn_unused_result__));






extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__)) __attribute__ ((__alloc_size__ (2)));


extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));







extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__))
     __attribute__ ((__alloc_size__ (2, 3)))
    __attribute__ ((__malloc__ (__builtin_free, 1)));


extern void *reallocarray (void *__ptr, size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__ (reallocarray, 1)));



# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4







extern void *alloca (size_t __size) __attribute__ ((__nothrow__ , __leaf__));






# 575 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__))
     __attribute__ ((__alloc_size__ (1))) __attribute__ ((__warn_unused_result__));




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));




extern void *aligned_alloc (size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__alloc_align__ (1)))
     __attribute__ ((__alloc_size__ (2))) __attribute__ ((__warn_unused_result__));



extern void abort (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int at_quick_exit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern void exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void quick_exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));





extern void _Exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));




extern char *getenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));




extern char *secure_getenv (const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));






extern int putenv (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) __attribute__ ((__nothrow__ , __leaf__));
# 682 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 695 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 705 "/usr/include/stdlib.h" 3 4
extern int mkstemp64 (char *__template) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 717 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 727 "/usr/include/stdlib.h" 3 4
extern int mkstemps64 (char *__template, int __suffixlen)
     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 738 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 749 "/usr/include/stdlib.h" 3 4
extern int mkostemp (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 759 "/usr/include/stdlib.h" 3 4
extern int mkostemp64 (char *__template, int __flags) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 769 "/usr/include/stdlib.h" 3 4
extern int mkostemps (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 781 "/usr/include/stdlib.h" 3 4
extern int mkostemps64 (char *__template, int __suffixlen, int __flags)
     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 791 "/usr/include/stdlib.h" 3 4
extern int system (const char *__command) __attribute__ ((__warn_unused_result__));





extern char *canonicalize_file_name (const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__malloc__))
     __attribute__ ((__malloc__ (__builtin_free, 1))) __attribute__ ((__warn_unused_result__));
# 808 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));






typedef int (*__compar_fn_t) (const void *, const void *);


typedef __compar_fn_t comparison_fn_t;



typedef int (*__compar_d_fn_t) (const void *, const void *, void *);




extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) __attribute__ ((__warn_unused_result__));


# 1 "/usr/include/aarch64-linux-gnu/bits/stdlib-bsearch.h" 1 3 4
# 19 "/usr/include/aarch64-linux-gnu/bits/stdlib-bsearch.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) void *
bsearch (const void *__key, const void *__base, size_t __nmemb, size_t __size,
  __compar_fn_t __compar)
{
  size_t __l, __u, __idx;
  const void *__p;
  int __comparison;

  __l = 0;
  __u = __nmemb;
  while (__l < __u)
    {
      __idx = (__l + __u) / 2;
      __p = (const void *) (((const char *) __base) + (__idx * __size));
      __comparison = (*__compar) (__key, __p);
      if (__comparison < 0)
 __u = __idx;
      else if (__comparison > 0)
 __l = __idx + 1;
      else
 {

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wcast-qual"

   return (void *) __p;

#pragma GCC diagnostic pop

 }
    }

  return ((void *)0);
}
# 834 "/usr/include/stdlib.h" 2 3 4




extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));

extern void qsort_r (void *__base, size_t __nmemb, size_t __size,
       __compar_d_fn_t __compar, void *__arg)
  __attribute__ ((__nonnull__ (1, 4)));




extern int abs (int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
extern long int labs (long int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));


__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));






extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));


__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) __attribute__ ((__warn_unused_result__));
# 880 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) __attribute__ ((__warn_unused_result__));




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) __attribute__ ((__warn_unused_result__));
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) __attribute__ ((__warn_unused_result__));




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));





extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ , __leaf__));



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__))
    __attribute__ ((__access__ (__read_only__, 2)));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__access__ (__write_only__, 1, 3)))
  __attribute__ ((__access__ (__read_only__, 2)));






extern int rpmatch (const char *__response) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 967 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3))) __attribute__ ((__warn_unused_result__));







extern int posix_openpt (int __oflag) __attribute__ ((__warn_unused_result__));







extern int grantpt (int __fd) __attribute__ ((__nothrow__ , __leaf__));



extern int unlockpt (int __fd) __attribute__ ((__nothrow__ , __leaf__));




extern char *ptsname (int __fd) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));






extern int ptsname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 2, 3)));


extern int getpt (void);






extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 1023 "/usr/include/stdlib.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/stdlib-float.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/stdlib-float.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) double
__attribute__ ((__nothrow__ , __leaf__)) atof (const char *__nptr)
{
  return strtod (__nptr, (char **) ((void *)0));
}
# 1024 "/usr/include/stdlib.h" 2 3 4



# 1 "/usr/include/aarch64-linux-gnu/bits/stdlib.h" 1 3 4
# 23 "/usr/include/aarch64-linux-gnu/bits/stdlib.h" 3 4
extern char *__realpath_chk (const char *__restrict __name,
        char *__restrict __resolved,
        size_t __resolvedlen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
extern char *__realpath_alias (const char *__restrict __name, char *__restrict __resolved) __asm__ ("" "realpath") __attribute__ ((__nothrow__ , __leaf__))

                                                 __attribute__ ((__warn_unused_result__));
extern char *__realpath_chk_warn (const char *__restrict __name, char *__restrict __resolved, size_t __resolvedlen) __asm__ ("" "__realpath_chk") __attribute__ ((__nothrow__ , __leaf__))


                                                __attribute__ ((__warn_unused_result__))
     __attribute__((__warning__ ("second argument of realpath must be either NULL or at " "least PATH_MAX bytes long buffer")))
                                      ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) char *
__attribute__ ((__nothrow__ , __leaf__)) realpath (const char *__restrict __name, char *__restrict __resolved)
{
  size_t sz = __builtin_object_size (__resolved, 2 > 1);

  if (sz == (size_t) -1)
    return __realpath_alias (__name, __resolved);





  return __realpath_chk (__name, __resolved, sz);
}


extern int __ptsname_r_chk (int __fd, char *__buf, size_t __buflen,
       size_t __nreal) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)))
    __attribute__ ((__access__ (__write_only__, 2, 3)));
extern int __ptsname_r_alias (int __fd, char *__buf, size_t __buflen) __asm__ ("" "ptsname_r") __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__nonnull__ (2))) __attribute__ ((__access__ (__write_only__, 2, 3)));
extern int __ptsname_r_chk_warn (int __fd, char *__buf, size_t __buflen, size_t __nreal) __asm__ ("" "__ptsname_r_chk") __attribute__ ((__nothrow__ , __leaf__))


     __attribute__ ((__nonnull__ (2))) __attribute__((__warning__ ("ptsname_r called with buflen bigger than " "size of buf")))
                   ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) ptsname_r (int __fd, char *__buf, size_t __buflen)
{
  return ((((__typeof (__buflen)) 0 < (__typeof (__buflen)) -1 || (__builtin_constant_p (__buflen) && (__buflen) > 0)) && __builtin_constant_p ((((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) && (((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) ? __ptsname_r_alias (__fd, __buf, __buflen) : ((((__typeof (__buflen)) 0 < (__typeof (__buflen)) -1 || (__builtin_constant_p (__buflen) && (__buflen) > 0)) && __builtin_constant_p ((((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) && !(((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) ? __ptsname_r_chk_warn (__fd, __buf, __buflen, __builtin_object_size (__buf, 2 > 1)) : __ptsname_r_chk (__fd, __buf, __buflen, __builtin_object_size (__buf, 2 > 1))))

                           ;
}


extern int __wctomb_chk (char *__s, wchar_t __wchar, size_t __buflen)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
extern int __wctomb_alias (char *__s, wchar_t __wchar) __asm__ ("" "wctomb") __attribute__ ((__nothrow__ , __leaf__))
              __attribute__ ((__warn_unused_result__));

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) int
__attribute__ ((__nothrow__ , __leaf__)) wctomb (char *__s, wchar_t __wchar)
{







  if (__builtin_object_size (__s, 2 > 1) != (size_t) -1
      && 16 > __builtin_object_size (__s, 2 > 1))
    return __wctomb_chk (__s, __wchar, __builtin_object_size (__s, 2 > 1));
  return __wctomb_alias (__s, __wchar);
}


extern size_t __mbstowcs_chk (wchar_t *__restrict __dst,
         const char *__restrict __src,
         size_t __len, size_t __dstlen) __attribute__ ((__nothrow__ , __leaf__))
    __attribute__ ((__access__ (__write_only__, 1, 3))) __attribute__ ((__access__ (__read_only__, 2)));
extern size_t __mbstowcs_alias (wchar_t *__restrict __dst, const char *__restrict __src, size_t __len) __asm__ ("" "mbstowcs") __attribute__ ((__nothrow__ , __leaf__))



    __attribute__ ((__access__ (__write_only__, 1, 3))) __attribute__ ((__access__ (__read_only__, 2)));
extern size_t __mbstowcs_chk_warn (wchar_t *__restrict __dst, const char *__restrict __src, size_t __len, size_t __dstlen) __asm__ ("" "__mbstowcs_chk") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__((__warning__ ("mbstowcs called with dst buffer smaller than len " "* sizeof (wchar_t)")))
                        ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) size_t
__attribute__ ((__nothrow__ , __leaf__)) mbstowcs (wchar_t *__restrict __dst, const char *__restrict __src, size_t __len)

{
  return ((((__typeof (__len)) 0 < (__typeof (__len)) -1 || (__builtin_constant_p (__len) && (__len) > 0)) && __builtin_constant_p ((((long unsigned int) (__len)) <= (__builtin_object_size (__dst, 2 > 1)) / (sizeof (wchar_t)))) && (((long unsigned int) (__len)) <= (__builtin_object_size (__dst, 2 > 1)) / (sizeof (wchar_t)))) ? __mbstowcs_alias (__dst, __src, __len) : ((((__typeof (__len)) 0 < (__typeof (__len)) -1 || (__builtin_constant_p (__len) && (__len) > 0)) && __builtin_constant_p ((((long unsigned int) (__len)) <= (__builtin_object_size (__dst, 2 > 1)) / (sizeof (wchar_t)))) && !(((long unsigned int) (__len)) <= (__builtin_object_size (__dst, 2 > 1)) / (sizeof (wchar_t)))) ? __mbstowcs_chk_warn (__dst, __src, __len, (__builtin_object_size (__dst, 2 > 1)) / (sizeof (wchar_t))) : __mbstowcs_chk (__dst, __src, __len, (__builtin_object_size (__dst, 2 > 1)) / (sizeof (wchar_t)))))

                           ;
}


extern size_t __wcstombs_chk (char *__restrict __dst,
         const wchar_t *__restrict __src,
         size_t __len, size_t __dstlen) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__access__ (__write_only__, 1, 3))) __attribute__ ((__access__ (__read_only__, 2)));
extern size_t __wcstombs_alias (char *__restrict __dst, const wchar_t *__restrict __src, size_t __len) __asm__ ("" "wcstombs") __attribute__ ((__nothrow__ , __leaf__))



  __attribute__ ((__access__ (__write_only__, 1, 3))) __attribute__ ((__access__ (__read_only__, 2)));
extern size_t __wcstombs_chk_warn (char *__restrict __dst, const wchar_t *__restrict __src, size_t __len, size_t __dstlen) __asm__ ("" "__wcstombs_chk") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__((__warning__ ("wcstombs called with dst buffer smaller than len")));

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) size_t
__attribute__ ((__nothrow__ , __leaf__)) wcstombs (char *__restrict __dst, const wchar_t *__restrict __src, size_t __len)

{
  return ((((__typeof (__len)) 0 < (__typeof (__len)) -1 || (__builtin_constant_p (__len) && (__len) > 0)) && __builtin_constant_p ((((long unsigned int) (__len)) <= (__builtin_object_size (__dst, 2 > 1)) / (sizeof (char)))) && (((long unsigned int) (__len)) <= (__builtin_object_size (__dst, 2 > 1)) / (sizeof (char)))) ? __wcstombs_alias (__dst, __src, __len) : ((((__typeof (__len)) 0 < (__typeof (__len)) -1 || (__builtin_constant_p (__len) && (__len) > 0)) && __builtin_constant_p ((((long unsigned int) (__len)) <= (__builtin_object_size (__dst, 2 > 1)) / (sizeof (char)))) && !(((long unsigned int) (__len)) <= (__builtin_object_size (__dst, 2 > 1)) / (sizeof (char)))) ? __wcstombs_chk_warn (__dst, __src, __len, __builtin_object_size (__dst, 2 > 1)) : __wcstombs_chk (__dst, __src, __len, __builtin_object_size (__dst, 2 > 1))))

                         ;
}
# 1028 "/usr/include/stdlib.h" 2 3 4








# 38 "pigpio.c" 2
# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/stdint.h" 2 3 4

# 1 "/usr/include/aarch64-linux-gnu/bits/wchar.h" 1 3 4
# 29 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/wordsize.h" 1 3 4
# 30 "/usr/include/stdint.h" 2 3 4







# 1 "/usr/include/aarch64-linux-gnu/bits/stdint-uintn.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/stdint-uintn.h" 3 4
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
# 38 "/usr/include/stdint.h" 2 3 4





typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;


typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;





typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 71 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 87 "/usr/include/stdint.h" 3 4
typedef long int intptr_t;


typedef unsigned long int uintptr_t;
# 101 "/usr/include/stdint.h" 3 4
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
# 10 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stdint.h" 2 3 4
# 39 "pigpio.c" 2
# 1 "/usr/include/inttypes.h" 1 3 4
# 34 "/usr/include/inttypes.h" 3 4
typedef unsigned int __gwchar_t;
# 266 "/usr/include/inttypes.h" 3 4





typedef struct
  {
    long int quot;
    long int rem;
  } imaxdiv_t;
# 290 "/usr/include/inttypes.h" 3 4
extern intmax_t imaxabs (intmax_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern imaxdiv_t imaxdiv (intmax_t __numer, intmax_t __denom)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern intmax_t strtoimax (const char *__restrict __nptr,
      char **__restrict __endptr, int __base) __attribute__ ((__nothrow__ , __leaf__));


extern uintmax_t strtoumax (const char *__restrict __nptr,
       char ** __restrict __endptr, int __base) __attribute__ ((__nothrow__ , __leaf__));


extern intmax_t wcstoimax (const __gwchar_t *__restrict __nptr,
      __gwchar_t **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));


extern uintmax_t wcstoumax (const __gwchar_t *__restrict __nptr,
       __gwchar_t ** __restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__));


# 40 "pigpio.c" 2
# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stdarg.h" 1 3 4
# 41 "pigpio.c" 2
# 1 "/usr/include/ctype.h" 1 3 4
# 28 "/usr/include/ctype.h" 3 4

# 46 "/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 79 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 108 "/usr/include/ctype.h" 3 4
extern int isalnum (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha (int) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit (int) __attribute__ ((__nothrow__ , __leaf__));
extern int islower (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint (int) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit (int) __attribute__ ((__nothrow__ , __leaf__));



extern int tolower (int __c) __attribute__ ((__nothrow__ , __leaf__));


extern int toupper (int __c) __attribute__ ((__nothrow__ , __leaf__));




extern int isblank (int) __attribute__ ((__nothrow__ , __leaf__));




extern int isctype (int __c, int __mask) __attribute__ ((__nothrow__ , __leaf__));






extern int isascii (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int toascii (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int _toupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int _tolower (int) __attribute__ ((__nothrow__ , __leaf__));
# 206 "/usr/include/ctype.h" 3 4
extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) tolower (int __c)
{
  return __c >= -128 && __c < 256 ? (*__ctype_tolower_loc ())[__c] : __c;
}

extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) toupper (int __c)
{
  return __c >= -128 && __c < 256 ? (*__ctype_toupper_loc ())[__c] : __c;
}
# 251 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int islower_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));

extern int isblank_l (int, locale_t) __attribute__ ((__nothrow__ , __leaf__));



extern int __tolower_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int tolower_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));


extern int __toupper_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int toupper_l (int __c, locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
# 327 "/usr/include/ctype.h" 3 4

# 42 "pigpio.c" 2
# 1 "/usr/include/syslog.h" 1 3 4
# 1 "/usr/include/aarch64-linux-gnu/sys/syslog.h" 1 3 4
# 40 "/usr/include/aarch64-linux-gnu/sys/syslog.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/syslog-path.h" 1 3 4
# 41 "/usr/include/aarch64-linux-gnu/sys/syslog.h" 2 3 4
# 169 "/usr/include/aarch64-linux-gnu/sys/syslog.h" 3 4






extern void closelog (void);





extern void openlog (const char *__ident, int __option, int __facility);


extern int setlogmask (int __mask) __attribute__ ((__nothrow__ , __leaf__));





extern void syslog (int __pri, const char *__fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));
# 200 "/usr/include/aarch64-linux-gnu/sys/syslog.h" 3 4
extern void vsyslog (int __pri, const char *__fmt, __gnuc_va_list __ap)
     __attribute__ ((__format__ (__printf__, 2, 0)));





# 1 "/usr/include/aarch64-linux-gnu/bits/syslog.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/syslog.h" 3 4
extern void __syslog_chk (int __pri, int __flag, const char *__fmt, ...)
     __attribute__ ((__format__ (__printf__, 3, 4)));


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void
syslog (int __pri, const char *__fmt, ...)
{
  __syslog_chk (__pri, 2 - 1, __fmt, __builtin_va_arg_pack ());
}







extern void __vsyslog_chk (int __pri, int __flag, const char *__fmt,
      __gnuc_va_list __ap)
     __attribute__ ((__format__ (__printf__, 3, 0)));

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) void
vsyslog (int __pri, const char *__fmt, __gnuc_va_list __ap)
{
  __vsyslog_chk (__pri, 2 - 1, __fmt, __ap);
}
# 208 "/usr/include/aarch64-linux-gnu/sys/syslog.h" 2 3 4








# 2 "/usr/include/syslog.h" 2 3 4
# 43 "pigpio.c" 2
# 1 "/usr/include/poll.h" 1 3 4
# 1 "/usr/include/aarch64-linux-gnu/sys/poll.h" 1 3 4
# 25 "/usr/include/aarch64-linux-gnu/sys/poll.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/poll.h" 1 3 4
# 26 "/usr/include/aarch64-linux-gnu/sys/poll.h" 2 3 4







typedef unsigned long int nfds_t;


struct pollfd
  {
    int fd;
    short int events;
    short int revents;
  };



# 54 "/usr/include/aarch64-linux-gnu/sys/poll.h" 3 4
extern int poll (struct pollfd *__fds, nfds_t __nfds, int __timeout)
    __attribute__ ((__access__ (__write_only__, 1, 2)));
# 64 "/usr/include/aarch64-linux-gnu/sys/poll.h" 3 4
extern int ppoll (struct pollfd *__fds, nfds_t __nfds,
    const struct timespec *__timeout,
    const __sigset_t *__ss)
    __attribute__ ((__access__ (__write_only__, 1, 2)));
# 82 "/usr/include/aarch64-linux-gnu/sys/poll.h" 3 4





# 1 "/usr/include/aarch64-linux-gnu/bits/poll2.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/poll2.h" 3 4


extern int __poll_alias (struct pollfd *__fds, nfds_t __nfds, int __timeout) __asm__ ("" "poll")
                               ;
extern int __poll_chk (struct pollfd *__fds, nfds_t __nfds, int __timeout,
         long unsigned int __fdslen)
    __attribute__ ((__access__ (__write_only__, 1, 2)));
extern int __poll_chk_warn (struct pollfd *__fds, nfds_t __nfds, int __timeout, long unsigned int __fdslen) __asm__ ("" "__poll_chk")


  __attribute__((__warning__ ("poll called with fds buffer too small file nfds entries")));

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__access__ (__write_only__, 1, 2))) int
poll (struct pollfd *__fds, nfds_t __nfds, int __timeout)
{
  return ((((__typeof (__nfds)) 0 < (__typeof (__nfds)) -1 || (__builtin_constant_p (__nfds) && (__nfds) > 0)) && __builtin_constant_p ((((long unsigned int) (__nfds)) <= (__builtin_object_size (__fds, 2 > 1)) / (sizeof (*__fds)))) && (((long unsigned int) (__nfds)) <= (__builtin_object_size (__fds, 2 > 1)) / (sizeof (*__fds)))) ? __poll_alias (__fds, __nfds, __timeout) : ((((__typeof (__nfds)) 0 < (__typeof (__nfds)) -1 || (__builtin_constant_p (__nfds) && (__nfds) > 0)) && __builtin_constant_p ((((long unsigned int) (__nfds)) <= (__builtin_object_size (__fds, 2 > 1)) / (sizeof (*__fds)))) && !(((long unsigned int) (__nfds)) <= (__builtin_object_size (__fds, 2 > 1)) / (sizeof (*__fds)))) ? __poll_chk_warn (__fds, __nfds, __timeout, __builtin_object_size (__fds, 2 > 1)) : __poll_chk (__fds, __nfds, __timeout, __builtin_object_size (__fds, 2 > 1))))

                              ;
}



extern int __ppoll_alias (struct pollfd *__fds, nfds_t __nfds, const struct timespec *__timeout, const __sigset_t *__ss) __asm__ ("" "ppoll")

                                          ;
extern int __ppoll_chk (struct pollfd *__fds, nfds_t __nfds,
   const struct timespec *__timeout,
   const __sigset_t *__ss, long unsigned int __fdslen)
    __attribute__ ((__access__ (__write_only__, 1, 2)));
extern int __ppoll_chk_warn (struct pollfd *__fds, nfds_t __nfds, const struct timespec *__timeout, const __sigset_t *__ss, long unsigned int __fdslen) __asm__ ("" "__ppoll_chk")




  __attribute__((__warning__ ("ppoll called with fds buffer too small file nfds entries")));

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__access__ (__write_only__, 1, 2))) int
ppoll (struct pollfd *__fds, nfds_t __nfds, const struct timespec *__timeout,
       const __sigset_t *__ss)
{
  return ((((__typeof (__nfds)) 0 < (__typeof (__nfds)) -1 || (__builtin_constant_p (__nfds) && (__nfds) > 0)) && __builtin_constant_p ((((long unsigned int) (__nfds)) <= (__builtin_object_size (__fds, 2 > 1)) / (sizeof (*__fds)))) && (((long unsigned int) (__nfds)) <= (__builtin_object_size (__fds, 2 > 1)) / (sizeof (*__fds)))) ? __ppoll_alias (__fds, __nfds, __timeout, __ss) : ((((__typeof (__nfds)) 0 < (__typeof (__nfds)) -1 || (__builtin_constant_p (__nfds) && (__nfds) > 0)) && __builtin_constant_p ((((long unsigned int) (__nfds)) <= (__builtin_object_size (__fds, 2 > 1)) / (sizeof (*__fds)))) && !(((long unsigned int) (__nfds)) <= (__builtin_object_size (__fds, 2 > 1)) / (sizeof (*__fds)))) ? __ppoll_chk_warn (__fds, __nfds, __timeout, __ss, __builtin_object_size (__fds, 2 > 1)) : __ppoll_chk (__fds, __nfds, __timeout, __ss, __builtin_object_size (__fds, 2 > 1))))

                                    ;
}



# 88 "/usr/include/aarch64-linux-gnu/sys/poll.h" 2 3 4
# 2 "/usr/include/poll.h" 2 3 4
# 44 "pigpio.c" 2
# 1 "/usr/include/unistd.h" 1 3 4
# 27 "/usr/include/unistd.h" 3 4

# 202 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/posix_opt.h" 1 3 4
# 203 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/aarch64-linux-gnu/bits/environments.h" 1 3 4
# 22 "/usr/include/aarch64-linux-gnu/bits/environments.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/wordsize.h" 1 3 4
# 23 "/usr/include/aarch64-linux-gnu/bits/environments.h" 2 3 4
# 207 "/usr/include/unistd.h" 2 3 4
# 226 "/usr/include/unistd.h" 3 4
# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 227 "/usr/include/unistd.h" 2 3 4
# 274 "/usr/include/unistd.h" 3 4
typedef __socklen_t socklen_t;
# 287 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int euidaccess (const char *__name, int __type)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int eaccess (const char *__name, int __type)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int execveat (int __fd, const char *__path, char *const __argv[],
                     char *const __envp[], int __flags)
    __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));






extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) __attribute__ ((__warn_unused_result__));
# 339 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) __attribute__ ((__nothrow__ , __leaf__));
# 350 "/usr/include/unistd.h" 3 4
extern __off64_t lseek64 (int __fd, __off64_t __offset, int __whence)
     __attribute__ ((__nothrow__ , __leaf__));






extern int close (int __fd);




extern void closefrom (int __lowfd) __attribute__ ((__nothrow__ , __leaf__));







extern ssize_t read (int __fd, void *__buf, size_t __nbytes) __attribute__ ((__warn_unused_result__))
    __attribute__ ((__access__ (__write_only__, 2, 3)));





extern ssize_t write (int __fd, const void *__buf, size_t __n) __attribute__ ((__warn_unused_result__))
    __attribute__ ((__access__ (__read_only__, 2, 3)));
# 389 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) __attribute__ ((__warn_unused_result__))
    __attribute__ ((__access__ (__write_only__, 2, 3)));






extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
         __off_t __offset) __attribute__ ((__warn_unused_result__))
    __attribute__ ((__access__ (__read_only__, 2, 3)));
# 422 "/usr/include/unistd.h" 3 4
extern ssize_t pread64 (int __fd, void *__buf, size_t __nbytes,
   __off64_t __offset) __attribute__ ((__warn_unused_result__))
    __attribute__ ((__access__ (__write_only__, 2, 3)));


extern ssize_t pwrite64 (int __fd, const void *__buf, size_t __n,
    __off64_t __offset) __attribute__ ((__warn_unused_result__))
    __attribute__ ((__access__ (__read_only__, 2, 3)));







extern int pipe (int __pipedes[2]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern int pipe2 (int __pipedes[2], int __flags) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
# 452 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) __attribute__ ((__nothrow__ , __leaf__));
# 464 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     __attribute__ ((__nothrow__ , __leaf__));






extern int usleep (__useconds_t __useconds);
# 489 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) __attribute__ ((__warn_unused_result__));



extern int chdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



extern int fchdir (int __fd) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
# 531 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));





extern char *get_current_dir_name (void) __attribute__ ((__nothrow__ , __leaf__));







extern char *getwd (char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) __attribute__ ((__warn_unused_result__))
    __attribute__ ((__access__ (__write_only__, 1)));




extern int dup (int __fd) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));


extern int dup2 (int __fd, int __fd2) __attribute__ ((__nothrow__ , __leaf__));




extern int dup3 (int __fd, int __fd2, int __flags) __attribute__ ((__nothrow__ , __leaf__));



extern char **__environ;

extern char **environ;





extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int execvpe (const char *__file, char *const __argv[],
      char *const __envp[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern int nice (int __inc) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/aarch64-linux-gnu/bits/confname.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT,


    _SC_MINSIGSTKSZ,


    _SC_SIGSTKSZ

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 631 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) __attribute__ ((__nothrow__ , __leaf__));


extern long int sysconf (int __name) __attribute__ ((__nothrow__ , __leaf__));



extern size_t confstr (int __name, char *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__))
    __attribute__ ((__access__ (__write_only__, 2, 3)));




extern __pid_t getpid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t getppid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t getpgrp (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t __getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));

extern __pid_t getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));






extern int setpgid (__pid_t __pid, __pid_t __pgid) __attribute__ ((__nothrow__ , __leaf__));
# 682 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) __attribute__ ((__nothrow__ , __leaf__));






extern __pid_t setsid (void) __attribute__ ((__nothrow__ , __leaf__));



extern __pid_t getsid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));



extern __uid_t getuid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __uid_t geteuid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __gid_t getgid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __gid_t getegid (void) __attribute__ ((__nothrow__ , __leaf__));




extern int getgroups (int __size, __gid_t __list[]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__))
    __attribute__ ((__access__ (__write_only__, 2, 1)));


extern int group_member (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__));






extern int setuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern int setreuid (__uid_t __ruid, __uid_t __euid) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern int seteuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));






extern int setgid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern int setregid (__gid_t __rgid, __gid_t __egid) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));




extern int setegid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));





extern int getresuid (__uid_t *__ruid, __uid_t *__euid, __uid_t *__suid)
     __attribute__ ((__nothrow__ , __leaf__));



extern int getresgid (__gid_t *__rgid, __gid_t *__egid, __gid_t *__sgid)
     __attribute__ ((__nothrow__ , __leaf__));



extern int setresuid (__uid_t __ruid, __uid_t __euid, __uid_t __suid)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));



extern int setresgid (__gid_t __rgid, __gid_t __egid, __gid_t __sgid)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));






extern __pid_t fork (void) __attribute__ ((__nothrow__));







extern __pid_t vfork (void) __attribute__ ((__nothrow__ , __leaf__));






extern __pid_t _Fork (void) __attribute__ ((__nothrow__ , __leaf__));





extern char *ttyname (int __fd) __attribute__ ((__nothrow__ , __leaf__));



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) __attribute__ ((__warn_unused_result__))
     __attribute__ ((__access__ (__write_only__, 2, 3)));



extern int isatty (int __fd) __attribute__ ((__nothrow__ , __leaf__));




extern int ttyslot (void) __attribute__ ((__nothrow__ , __leaf__));




extern int link (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__));




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4))) __attribute__ ((__warn_unused_result__));




extern int symlink (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__));




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__))
     __attribute__ ((__access__ (__write_only__, 2, 3)));





extern int symlinkat (const char *__from, int __tofd,
        const char *__to) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3))) __attribute__ ((__warn_unused_result__));


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3))) __attribute__ ((__warn_unused_result__))
     __attribute__ ((__access__ (__write_only__, 3, 4)));



extern int unlink (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) __attribute__ ((__nothrow__ , __leaf__));


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) __attribute__ ((__nothrow__ , __leaf__));






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__write_only__, 1, 2)));




extern int setlogin (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







# 1 "/usr/include/aarch64-linux-gnu/bits/getopt_posix.h" 1 3 4
# 27 "/usr/include/aarch64-linux-gnu/bits/getopt_posix.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/getopt_core.h" 1 3 4
# 28 "/usr/include/aarch64-linux-gnu/bits/getopt_core.h" 3 4








extern char *optarg;
# 50 "/usr/include/aarch64-linux-gnu/bits/getopt_core.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 91 "/usr/include/aarch64-linux-gnu/bits/getopt_core.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));


# 28 "/usr/include/aarch64-linux-gnu/bits/getopt_posix.h" 2 3 4


# 49 "/usr/include/aarch64-linux-gnu/bits/getopt_posix.h" 3 4

# 904 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)))
    __attribute__ ((__access__ (__write_only__, 1, 2)));






extern int sethostname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__read_only__, 1, 2)));



extern int sethostid (long int __id) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));





extern int getdomainname (char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__))
     __attribute__ ((__access__ (__write_only__, 1, 2)));
extern int setdomainname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__read_only__, 1, 2)));




extern int vhangup (void) __attribute__ ((__nothrow__ , __leaf__));


extern int revoke (const char *__file) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) __attribute__ ((__nothrow__ , __leaf__));



extern char *getusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void endusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void setusershell (void) __attribute__ ((__nothrow__ , __leaf__));





extern int daemon (int __nochdir, int __noclose) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));






extern int chroot (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);





extern int syncfs (int __fd) __attribute__ ((__nothrow__ , __leaf__));






extern long int gethostid (void);


extern void sync (void) __attribute__ ((__nothrow__ , __leaf__));





extern int getpagesize (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int getdtablesize (void) __attribute__ ((__nothrow__ , __leaf__));
# 1026 "/usr/include/unistd.h" 3 4
extern int truncate (const char *__file, __off_t __length)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 1038 "/usr/include/unistd.h" 3 4
extern int truncate64 (const char *__file, __off64_t __length)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__));
# 1049 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
# 1059 "/usr/include/unistd.h" 3 4
extern int ftruncate64 (int __fd, __off64_t __length) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
# 1070 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));





extern void *sbrk (intptr_t __delta) __attribute__ ((__nothrow__ , __leaf__));
# 1091 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) __attribute__ ((__nothrow__ , __leaf__));
# 1114 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) __attribute__ ((__warn_unused_result__));
# 1124 "/usr/include/unistd.h" 3 4
extern int lockf64 (int __fd, int __cmd, __off64_t __len) __attribute__ ((__warn_unused_result__));
# 1142 "/usr/include/unistd.h" 3 4
ssize_t copy_file_range (int __infd, __off64_t *__pinoff,
    int __outfd, __off64_t *__poutoff,
    size_t __length, unsigned int __flags);





extern int fdatasync (int __fildes);
# 1159 "/usr/include/unistd.h" 3 4
extern char *crypt (const char *__key, const char *__salt)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));







extern void swab (const void *__restrict __from, void *__restrict __to,
    ssize_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)))
    __attribute__ ((__access__ (__read_only__, 1, 3)))
    __attribute__ ((__access__ (__write_only__, 2, 3)));
# 1198 "/usr/include/unistd.h" 3 4
int getentropy (void *__buffer, size_t __length) __attribute__ ((__warn_unused_result__))
    __attribute__ ((__access__ (__write_only__, 1, 2)));
# 1208 "/usr/include/unistd.h" 3 4
extern int close_range (unsigned int __fd, unsigned int __max_fd,
   int __flags) __attribute__ ((__nothrow__ , __leaf__));




# 1 "/usr/include/aarch64-linux-gnu/bits/unistd.h" 1 3 4
# 23 "/usr/include/aarch64-linux-gnu/bits/unistd.h" 3 4
extern ssize_t __read_chk (int __fd, void *__buf, size_t __nbytes,
      size_t __buflen)
  __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 2, 3)));
extern ssize_t __read_alias (int __fd, void *__buf, size_t __nbytes) __asm__ ("" "read")

  __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 2, 3)));
extern ssize_t __read_chk_warn (int __fd, void *__buf, size_t __nbytes, size_t __buflen) __asm__ ("" "__read_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("read called with bigger length than size of " "the destination buffer")))
                                  ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) ssize_t
read (int __fd, void *__buf, size_t __nbytes)
{
  return ((((__typeof (__nbytes)) 0 < (__typeof (__nbytes)) -1 || (__builtin_constant_p (__nbytes) && (__nbytes) > 0)) && __builtin_constant_p ((((long unsigned int) (__nbytes)) <= (__builtin_object_size (__buf, 0)) / (sizeof (char)))) && (((long unsigned int) (__nbytes)) <= (__builtin_object_size (__buf, 0)) / (sizeof (char)))) ? __read_alias (__fd, __buf, __nbytes) : ((((__typeof (__nbytes)) 0 < (__typeof (__nbytes)) -1 || (__builtin_constant_p (__nbytes) && (__nbytes) > 0)) && __builtin_constant_p ((((long unsigned int) (__nbytes)) <= (__builtin_object_size (__buf, 0)) / (sizeof (char)))) && !(((long unsigned int) (__nbytes)) <= (__builtin_object_size (__buf, 0)) / (sizeof (char)))) ? __read_chk_warn (__fd, __buf, __nbytes, __builtin_object_size (__buf, 0)) : __read_chk (__fd, __buf, __nbytes, __builtin_object_size (__buf, 0))))

                           ;
}


extern ssize_t __pread_chk (int __fd, void *__buf, size_t __nbytes,
       __off_t __offset, size_t __bufsize)
  __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 2, 3)));
extern ssize_t __pread64_chk (int __fd, void *__buf, size_t __nbytes,
         __off64_t __offset, size_t __bufsize)
  __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 2, 3)));
extern ssize_t __pread_alias (int __fd, void *__buf, size_t __nbytes, __off_t __offset) __asm__ ("" "pread")


  __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 2, 3)));
extern ssize_t __pread64_alias (int __fd, void *__buf, size_t __nbytes, __off64_t __offset) __asm__ ("" "pread64")


  __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 2, 3)));
extern ssize_t __pread_chk_warn (int __fd, void *__buf, size_t __nbytes, __off_t __offset, size_t __bufsize) __asm__ ("" "__pread_chk")


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("pread called with bigger length than size of " "the destination buffer")))
                                  ;
extern ssize_t __pread64_chk_warn (int __fd, void *__buf, size_t __nbytes, __off64_t __offset, size_t __bufsize) __asm__ ("" "__pread64_chk")



     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("pread64 called with bigger length than size of " "the destination buffer")))
                                  ;


extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) ssize_t
pread (int __fd, void *__buf, size_t __nbytes, __off_t __offset)
{
  return ((((__typeof (__nbytes)) 0 < (__typeof (__nbytes)) -1 || (__builtin_constant_p (__nbytes) && (__nbytes) > 0)) && __builtin_constant_p ((((long unsigned int) (__nbytes)) <= (__builtin_object_size (__buf, 0)) / (sizeof (char)))) && (((long unsigned int) (__nbytes)) <= (__builtin_object_size (__buf, 0)) / (sizeof (char)))) ? __pread_alias (__fd, __buf, __nbytes, __offset) : ((((__typeof (__nbytes)) 0 < (__typeof (__nbytes)) -1 || (__builtin_constant_p (__nbytes) && (__nbytes) > 0)) && __builtin_constant_p ((((long unsigned int) (__nbytes)) <= (__builtin_object_size (__buf, 0)) / (sizeof (char)))) && !(((long unsigned int) (__nbytes)) <= (__builtin_object_size (__buf, 0)) / (sizeof (char)))) ? __pread_chk_warn (__fd, __buf, __nbytes, __offset, __builtin_object_size (__buf, 0)) : __pread_chk (__fd, __buf, __nbytes, __offset, __builtin_object_size (__buf, 0))))

                                     ;
}
# 89 "/usr/include/aarch64-linux-gnu/bits/unistd.h" 3 4
extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) ssize_t
pread64 (int __fd, void *__buf, size_t __nbytes, __off64_t __offset)
{
  return ((((__typeof (__nbytes)) 0 < (__typeof (__nbytes)) -1 || (__builtin_constant_p (__nbytes) && (__nbytes) > 0)) && __builtin_constant_p ((((long unsigned int) (__nbytes)) <= (__builtin_object_size (__buf, 0)) / (sizeof (char)))) && (((long unsigned int) (__nbytes)) <= (__builtin_object_size (__buf, 0)) / (sizeof (char)))) ? __pread64_alias (__fd, __buf, __nbytes, __offset) : ((((__typeof (__nbytes)) 0 < (__typeof (__nbytes)) -1 || (__builtin_constant_p (__nbytes) && (__nbytes) > 0)) && __builtin_constant_p ((((long unsigned int) (__nbytes)) <= (__builtin_object_size (__buf, 0)) / (sizeof (char)))) && !(((long unsigned int) (__nbytes)) <= (__builtin_object_size (__buf, 0)) / (sizeof (char)))) ? __pread64_chk_warn (__fd, __buf, __nbytes, __offset, __builtin_object_size (__buf, 0)) : __pread64_chk (__fd, __buf, __nbytes, __offset, __builtin_object_size (__buf, 0))))

                                     ;
}




extern ssize_t __readlink_chk (const char *__restrict __path,
          char *__restrict __buf, size_t __len,
          size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 2, 3)));
extern ssize_t __readlink_alias (const char *__restrict __path, char *__restrict __buf, size_t __len) __asm__ ("" "readlink") __attribute__ ((__nothrow__ , __leaf__))


     __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 2, 3)));
extern ssize_t __readlink_chk_warn (const char *__restrict __path, char *__restrict __buf, size_t __len, size_t __buflen) __asm__ ("" "__readlink_chk") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("readlink called with bigger length " "than size of destination buffer")))
                                         ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__warn_unused_result__)) ssize_t
__attribute__ ((__nothrow__ , __leaf__)) readlink (const char *__restrict __path, char *__restrict __buf, size_t __len)

{
  return ((((__typeof (__len)) 0 < (__typeof (__len)) -1 || (__builtin_constant_p (__len) && (__len) > 0)) && __builtin_constant_p ((((long unsigned int) (__len)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) && (((long unsigned int) (__len)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) ? __readlink_alias (__path, __buf, __len) : ((((__typeof (__len)) 0 < (__typeof (__len)) -1 || (__builtin_constant_p (__len) && (__len) > 0)) && __builtin_constant_p ((((long unsigned int) (__len)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) && !(((long unsigned int) (__len)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) ? __readlink_chk_warn (__path, __buf, __len, __builtin_object_size (__buf, 2 > 1)) : __readlink_chk (__path, __buf, __len, __builtin_object_size (__buf, 2 > 1))))

                          ;
}



extern ssize_t __readlinkat_chk (int __fd, const char *__restrict __path,
     char *__restrict __buf, size_t __len,
     size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3))) __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 3, 4)));
extern ssize_t __readlinkat_alias (int __fd, const char *__restrict __path, char *__restrict __buf, size_t __len) __asm__ ("" "readlinkat") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__ ((__nonnull__ (2, 3))) __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 3, 4)));
extern ssize_t __readlinkat_chk_warn (int __fd, const char *__restrict __path, char *__restrict __buf, size_t __len, size_t __buflen) __asm__ ("" "__readlinkat_chk") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__ ((__nonnull__ (2, 3))) __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("readlinkat called with bigger " "length than size of destination " "buffer")))

                ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__nonnull__ (2, 3))) __attribute__ ((__warn_unused_result__)) ssize_t
__attribute__ ((__nothrow__ , __leaf__)) readlinkat (int __fd, const char *__restrict __path, char *__restrict __buf, size_t __len)

{
  return ((((__typeof (__len)) 0 < (__typeof (__len)) -1 || (__builtin_constant_p (__len) && (__len) > 0)) && __builtin_constant_p ((((long unsigned int) (__len)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) && (((long unsigned int) (__len)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) ? __readlinkat_alias (__fd, __path, __buf, __len) : ((((__typeof (__len)) 0 < (__typeof (__len)) -1 || (__builtin_constant_p (__len) && (__len) > 0)) && __builtin_constant_p ((((long unsigned int) (__len)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) && !(((long unsigned int) (__len)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) ? __readlinkat_chk_warn (__fd, __path, __buf, __len, __builtin_object_size (__buf, 2 > 1)) : __readlinkat_chk (__fd, __path, __buf, __len, __builtin_object_size (__buf, 2 > 1))))

                                ;
}


extern char *__getcwd_chk (char *__buf, size_t __size, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
extern char *__getcwd_alias (char *__buf, size_t __size) __asm__ ("" "getcwd") __attribute__ ((__nothrow__ , __leaf__))
                                              __attribute__ ((__warn_unused_result__));
extern char *__getcwd_chk_warn (char *__buf, size_t __size, size_t __buflen) __asm__ ("" "__getcwd_chk") __attribute__ ((__nothrow__ , __leaf__))


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("getcwd caller with bigger length than size of " "destination buffer")))
                              ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__warn_unused_result__)) char *
__attribute__ ((__nothrow__ , __leaf__)) getcwd (char *__buf, size_t __size)
{
  return ((((__typeof (__size)) 0 < (__typeof (__size)) -1 || (__builtin_constant_p (__size) && (__size) > 0)) && __builtin_constant_p ((((long unsigned int) (__size)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) && (((long unsigned int) (__size)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) ? __getcwd_alias (__buf, __size) : ((((__typeof (__size)) 0 < (__typeof (__size)) -1 || (__builtin_constant_p (__size) && (__size) > 0)) && __builtin_constant_p ((((long unsigned int) (__size)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) && !(((long unsigned int) (__size)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) ? __getcwd_chk_warn (__buf, __size, __builtin_object_size (__buf, 2 > 1)) : __getcwd_chk (__buf, __size, __builtin_object_size (__buf, 2 > 1))))

                   ;
}


extern char *__getwd_chk (char *__buf, size_t buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 1, 2)));
extern char *__getwd_warn (char *__buf) __asm__ ("" "getwd") __attribute__ ((__nothrow__ , __leaf__))
     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("please use getcwd instead, as getwd " "doesn't specify buffer size")))
                                         ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) __attribute__ ((__warn_unused_result__)) char *
__attribute__ ((__nothrow__ , __leaf__)) getwd (char *__buf)
{
  if (__builtin_object_size (__buf, 2 > 1) != (size_t) -1)
    return __getwd_chk (__buf, __builtin_object_size (__buf, 2 > 1));
  return __getwd_warn (__buf);
}


extern size_t __confstr_chk (int __name, char *__buf, size_t __len,
        size_t __buflen) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__access__ (__write_only__, 2, 3)));
extern size_t __confstr_alias (int __name, char *__buf, size_t __len) __asm__ ("" "confstr") __attribute__ ((__nothrow__ , __leaf__))

   __attribute__ ((__access__ (__write_only__, 2, 3)));
extern size_t __confstr_chk_warn (int __name, char *__buf, size_t __len, size_t __buflen) __asm__ ("" "__confstr_chk") __attribute__ ((__nothrow__ , __leaf__))


     __attribute__((__warning__ ("confstr called with bigger length than size of destination " "buffer")))
            ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) size_t
__attribute__ ((__nothrow__ , __leaf__)) confstr (int __name, char *__buf, size_t __len)
{
  return ((((__typeof (__len)) 0 < (__typeof (__len)) -1 || (__builtin_constant_p (__len) && (__len) > 0)) && __builtin_constant_p ((((long unsigned int) (__len)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) && (((long unsigned int) (__len)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) ? __confstr_alias (__name, __buf, __len) : ((((__typeof (__len)) 0 < (__typeof (__len)) -1 || (__builtin_constant_p (__len) && (__len) > 0)) && __builtin_constant_p ((((long unsigned int) (__len)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) && !(((long unsigned int) (__len)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) ? __confstr_chk_warn (__name, __buf, __len, __builtin_object_size (__buf, 2 > 1)) : __confstr_chk (__name, __buf, __len, __builtin_object_size (__buf, 2 > 1))))

                          ;
}


extern int __getgroups_chk (int __size, __gid_t __list[], size_t __listlen)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 2, 1)));
extern int __getgroups_alias (int __size, __gid_t __list[]) __asm__ ("" "getgroups") __attribute__ ((__nothrow__ , __leaf__))
                 __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 2, 1)));
extern int __getgroups_chk_warn (int __size, __gid_t __list[], size_t __listlen) __asm__ ("" "__getgroups_chk") __attribute__ ((__nothrow__ , __leaf__))


     __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("getgroups called with bigger group count than what " "can fit into destination buffer")))
                                           ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) getgroups (int __size, __gid_t __list[])
{
  return ((((__typeof (__size)) 0 < (__typeof (__size)) -1 || (__builtin_constant_p (__size) && (__size) > 0)) && __builtin_constant_p ((((long unsigned int) (__size)) <= (__builtin_object_size (__list, 2 > 1)) / (sizeof (__gid_t)))) && (((long unsigned int) (__size)) <= (__builtin_object_size (__list, 2 > 1)) / (sizeof (__gid_t)))) ? __getgroups_alias (__size, __list) : ((((__typeof (__size)) 0 < (__typeof (__size)) -1 || (__builtin_constant_p (__size) && (__size) > 0)) && __builtin_constant_p ((((long unsigned int) (__size)) <= (__builtin_object_size (__list, 2 > 1)) / (sizeof (__gid_t)))) && !(((long unsigned int) (__size)) <= (__builtin_object_size (__list, 2 > 1)) / (sizeof (__gid_t)))) ? __getgroups_chk_warn (__size, __list, __builtin_object_size (__list, 2 > 1)) : __getgroups_chk (__size, __list, __builtin_object_size (__list, 2 > 1))))

                    ;
}


extern int __ttyname_r_chk (int __fd, char *__buf, size_t __buflen,
       size_t __nreal) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)))
   __attribute__ ((__access__ (__write_only__, 2, 3)));
extern int __ttyname_r_alias (int __fd, char *__buf, size_t __buflen) __asm__ ("" "ttyname_r") __attribute__ ((__nothrow__ , __leaf__))

     __attribute__ ((__nonnull__ (2)));
extern int __ttyname_r_chk_warn (int __fd, char *__buf, size_t __buflen, size_t __nreal) __asm__ ("" "__ttyname_r_chk") __attribute__ ((__nothrow__ , __leaf__))


     __attribute__ ((__nonnull__ (2))) __attribute__((__warning__ ("ttyname_r called with bigger buflen than " "size of destination buffer")))
                                  ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) ttyname_r (int __fd, char *__buf, size_t __buflen)
{
  return ((((__typeof (__buflen)) 0 < (__typeof (__buflen)) -1 || (__builtin_constant_p (__buflen) && (__buflen) > 0)) && __builtin_constant_p ((((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) && (((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) ? __ttyname_r_alias (__fd, __buf, __buflen) : ((((__typeof (__buflen)) 0 < (__typeof (__buflen)) -1 || (__builtin_constant_p (__buflen) && (__buflen) > 0)) && __builtin_constant_p ((((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) && !(((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) ? __ttyname_r_chk_warn (__fd, __buf, __buflen, __builtin_object_size (__buf, 2 > 1)) : __ttyname_r_chk (__fd, __buf, __buflen, __builtin_object_size (__buf, 2 > 1))))

                           ;
}



extern int __getlogin_r_chk (char *__buf, size_t __buflen, size_t __nreal)
     __attribute__ ((__nonnull__ (1))) __attribute__ ((__access__ (__write_only__, 1, 2)));
extern int __getlogin_r_alias (char *__buf, size_t __buflen) __asm__ ("" "getlogin_r")
                     __attribute__ ((__nonnull__ (1)));
extern int __getlogin_r_chk_warn (char *__buf, size_t __buflen, size_t __nreal) __asm__ ("" "__getlogin_r_chk")


     __attribute__ ((__nonnull__ (1))) __attribute__((__warning__ ("getlogin_r called with bigger buflen than " "size of destination buffer")))
                                  ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
getlogin_r (char *__buf, size_t __buflen)
{
  return ((((__typeof (__buflen)) 0 < (__typeof (__buflen)) -1 || (__builtin_constant_p (__buflen) && (__buflen) > 0)) && __builtin_constant_p ((((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) && (((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) ? __getlogin_r_alias (__buf, __buflen) : ((((__typeof (__buflen)) 0 < (__typeof (__buflen)) -1 || (__builtin_constant_p (__buflen) && (__buflen) > 0)) && __builtin_constant_p ((((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) && !(((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) ? __getlogin_r_chk_warn (__buf, __buflen, __builtin_object_size (__buf, 2 > 1)) : __getlogin_r_chk (__buf, __buflen, __builtin_object_size (__buf, 2 > 1))))

                     ;
}




extern int __gethostname_chk (char *__buf, size_t __buflen, size_t __nreal)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__access__ (__write_only__, 1, 2)));
extern int __gethostname_alias (char *__buf, size_t __buflen) __asm__ ("" "gethostname") __attribute__ ((__nothrow__ , __leaf__))

  __attribute__ ((__nonnull__ (1))) __attribute__ ((__access__ (__write_only__, 1, 2)));
extern int __gethostname_chk_warn (char *__buf, size_t __buflen, size_t __nreal) __asm__ ("" "__gethostname_chk") __attribute__ ((__nothrow__ , __leaf__))


     __attribute__ ((__nonnull__ (1))) __attribute__((__warning__ ("gethostname called with bigger buflen than " "size of destination buffer")))
                                  ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) gethostname (char *__buf, size_t __buflen)
{
  return ((((__typeof (__buflen)) 0 < (__typeof (__buflen)) -1 || (__builtin_constant_p (__buflen) && (__buflen) > 0)) && __builtin_constant_p ((((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) && (((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) ? __gethostname_alias (__buf, __buflen) : ((((__typeof (__buflen)) 0 < (__typeof (__buflen)) -1 || (__builtin_constant_p (__buflen) && (__buflen) > 0)) && __builtin_constant_p ((((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) && !(((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) ? __gethostname_chk_warn (__buf, __buflen, __builtin_object_size (__buf, 2 > 1)) : __gethostname_chk (__buf, __buflen, __builtin_object_size (__buf, 2 > 1))))

                     ;
}




extern int __getdomainname_chk (char *__buf, size_t __buflen, size_t __nreal)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 1, 2)));
extern int __getdomainname_alias (char *__buf, size_t __buflen) __asm__ ("" "getdomainname") __attribute__ ((__nothrow__ , __leaf__))

                     __attribute__ ((__nonnull__ (1)))
  __attribute__ ((__warn_unused_result__)) __attribute__ ((__access__ (__write_only__, 1, 2)));
extern int __getdomainname_chk_warn (char *__buf, size_t __buflen, size_t __nreal) __asm__ ("" "__getdomainname_chk") __attribute__ ((__nothrow__ , __leaf__))


     __attribute__ ((__nonnull__ (1))) __attribute__ ((__warn_unused_result__)) __attribute__((__warning__ ("getdomainname called with bigger " "buflen than size of destination " "buffer")))

                    ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
__attribute__ ((__nothrow__ , __leaf__)) getdomainname (char *__buf, size_t __buflen)
{
  return ((((__typeof (__buflen)) 0 < (__typeof (__buflen)) -1 || (__builtin_constant_p (__buflen) && (__buflen) > 0)) && __builtin_constant_p ((((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) && (((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) ? __getdomainname_alias (__buf, __buflen) : ((((__typeof (__buflen)) 0 < (__typeof (__buflen)) -1 || (__builtin_constant_p (__buflen) && (__buflen) > 0)) && __builtin_constant_p ((((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) && !(((long unsigned int) (__buflen)) <= (__builtin_object_size (__buf, 2 > 1)) / (sizeof (char)))) ? __getdomainname_chk_warn (__buf, __buflen, __builtin_object_size (__buf, 2 > 1)) : __getdomainname_chk (__buf, __buflen, __builtin_object_size (__buf, 2 > 1))))

                     ;
}
# 1215 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/aarch64-linux-gnu/bits/unistd_ext.h" 1 3 4
# 34 "/usr/include/aarch64-linux-gnu/bits/unistd_ext.h" 3 4
extern __pid_t gettid (void) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/linux/close_range.h" 1 3 4
# 39 "/usr/include/aarch64-linux-gnu/bits/unistd_ext.h" 2 3 4
# 1219 "/usr/include/unistd.h" 2 3 4


# 45 "pigpio.c" 2
# 1 "/usr/include/fcntl.h" 1 3 4
# 28 "/usr/include/fcntl.h" 3 4







# 1 "/usr/include/aarch64-linux-gnu/bits/fcntl.h" 1 3 4
# 40 "/usr/include/aarch64-linux-gnu/bits/fcntl.h" 3 4
struct flock
  {
    short int l_type;
    short int l_whence;
    __off_t l_start;
    __off_t l_len;
    __pid_t l_pid;
  };


struct flock64
  {
    short int l_type;
    short int l_whence;
    __off64_t l_start;
    __off64_t l_len;
    __pid_t l_pid;
  };



# 1 "/usr/include/aarch64-linux-gnu/bits/fcntl-linux.h" 1 3 4
# 38 "/usr/include/aarch64-linux-gnu/bits/fcntl-linux.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/types/struct_iovec.h" 1 3 4
# 23 "/usr/include/aarch64-linux-gnu/bits/types/struct_iovec.h" 3 4
# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/types/struct_iovec.h" 2 3 4


struct iovec
  {
    void *iov_base;
    size_t iov_len;
  };
# 39 "/usr/include/aarch64-linux-gnu/bits/fcntl-linux.h" 2 3 4
# 265 "/usr/include/aarch64-linux-gnu/bits/fcntl-linux.h" 3 4
enum __pid_type
  {
    F_OWNER_TID = 0,
    F_OWNER_PID,
    F_OWNER_PGRP,
    F_OWNER_GID = F_OWNER_PGRP
  };


struct f_owner_ex
  {
    enum __pid_type type;
    __pid_t pid;
  };
# 354 "/usr/include/aarch64-linux-gnu/bits/fcntl-linux.h" 3 4
# 1 "/usr/include/linux/falloc.h" 1 3 4
# 355 "/usr/include/aarch64-linux-gnu/bits/fcntl-linux.h" 2 3 4



struct file_handle
{
  unsigned int handle_bytes;
  int handle_type;

  unsigned char f_handle[0];
};
# 393 "/usr/include/aarch64-linux-gnu/bits/fcntl-linux.h" 3 4





extern __ssize_t readahead (int __fd, __off64_t __offset, size_t __count)
    __attribute__ ((__nothrow__ , __leaf__));






extern int sync_file_range (int __fd, __off64_t __offset, __off64_t __count,
       unsigned int __flags);






extern __ssize_t vmsplice (int __fdout, const struct iovec *__iov,
      size_t __count, unsigned int __flags);





extern __ssize_t splice (int __fdin, __off64_t *__offin, int __fdout,
    __off64_t *__offout, size_t __len,
    unsigned int __flags);





extern __ssize_t tee (int __fdin, int __fdout, size_t __len,
        unsigned int __flags);






extern int fallocate (int __fd, int __mode, __off_t __offset, __off_t __len);
# 448 "/usr/include/aarch64-linux-gnu/bits/fcntl-linux.h" 3 4
extern int fallocate64 (int __fd, int __mode, __off64_t __offset,
   __off64_t __len);




extern int name_to_handle_at (int __dfd, const char *__name,
         struct file_handle *__handle, int *__mnt_id,
         int __flags) __attribute__ ((__nothrow__ , __leaf__));





extern int open_by_handle_at (int __mountdirfd, struct file_handle *__handle,
         int __flags);




# 62 "/usr/include/aarch64-linux-gnu/bits/fcntl.h" 2 3 4
# 36 "/usr/include/fcntl.h" 2 3 4
# 78 "/usr/include/fcntl.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/stat.h" 1 3 4
# 25 "/usr/include/aarch64-linux-gnu/bits/stat.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/struct_stat.h" 1 3 4
# 27 "/usr/include/aarch64-linux-gnu/bits/struct_stat.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/aarch64-linux-gnu/bits/struct_stat.h" 2 3 4
# 44 "/usr/include/aarch64-linux-gnu/bits/struct_stat.h" 3 4
struct stat
  {
    __dev_t st_dev;
    __ino_t st_ino;
    __mode_t st_mode;
    __nlink_t st_nlink;
    __uid_t st_uid;
    __gid_t st_gid;
    __dev_t st_rdev;
    __dev_t __pad1;
    __off_t st_size;
    __blksize_t st_blksize;
    int __pad2;
    __blkcnt_t st_blocks;







    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 79 "/usr/include/aarch64-linux-gnu/bits/struct_stat.h" 3 4
    int __glibc_reserved[2];
  };




struct stat64
  {
    __dev_t st_dev;
    __ino64_t st_ino;
    __mode_t st_mode;
    __nlink_t st_nlink;
    __uid_t st_uid;
    __gid_t st_gid;
    __dev_t st_rdev;
    __dev_t __pad1;
    __off64_t st_size;
    __blksize_t st_blksize;
    int __pad2;
    __blkcnt64_t st_blocks;







    struct timespec st_atim;
    struct timespec st_mtim;
    struct timespec st_ctim;
# 117 "/usr/include/aarch64-linux-gnu/bits/struct_stat.h" 3 4
    int __glibc_reserved[2];
  };
# 26 "/usr/include/aarch64-linux-gnu/bits/stat.h" 2 3 4
# 79 "/usr/include/fcntl.h" 2 3 4
# 149 "/usr/include/fcntl.h" 3 4
extern int fcntl (int __fd, int __cmd, ...);
# 158 "/usr/include/fcntl.h" 3 4
extern int fcntl64 (int __fd, int __cmd, ...);
# 181 "/usr/include/fcntl.h" 3 4
extern int open (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 191 "/usr/include/fcntl.h" 3 4
extern int open64 (const char *__file, int __oflag, ...) __attribute__ ((__nonnull__ (1)));
# 205 "/usr/include/fcntl.h" 3 4
extern int openat (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 216 "/usr/include/fcntl.h" 3 4
extern int openat64 (int __fd, const char *__file, int __oflag, ...)
     __attribute__ ((__nonnull__ (2)));
# 227 "/usr/include/fcntl.h" 3 4
extern int creat (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 237 "/usr/include/fcntl.h" 3 4
extern int creat64 (const char *__file, mode_t __mode) __attribute__ ((__nonnull__ (1)));
# 273 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise (int __fd, off_t __offset, off_t __len,
     int __advise) __attribute__ ((__nothrow__ , __leaf__));
# 285 "/usr/include/fcntl.h" 3 4
extern int posix_fadvise64 (int __fd, off64_t __offset, off64_t __len,
       int __advise) __attribute__ ((__nothrow__ , __leaf__));
# 295 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate (int __fd, off_t __offset, off_t __len);
# 306 "/usr/include/fcntl.h" 3 4
extern int posix_fallocate64 (int __fd, off64_t __offset, off64_t __len);







# 1 "/usr/include/aarch64-linux-gnu/bits/fcntl2.h" 1 3 4
# 26 "/usr/include/aarch64-linux-gnu/bits/fcntl2.h" 3 4
extern int __open_2 (const char *__path, int __oflag) __attribute__ ((__nonnull__ (1)));
extern int __open_alias (const char *__path, int __oflag, ...) __asm__ ("" "open")
               __attribute__ ((__nonnull__ (1)));






extern void __open_too_many_args (void) __attribute__((__error__ ("open can be called either with 2 or 3 arguments, not more")))
                                                                  ;
extern void __open_missing_mode (void) __attribute__((__error__ ("open with O_CREAT or O_TMPFILE in second argument needs 3 arguments")))
                                                                            ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
open (const char *__path, int __oflag, ...)
{
  if (__builtin_va_arg_pack_len () > 1)
    __open_too_many_args ();

  if (__builtin_constant_p (__oflag))
    {
      if ((((__oflag) & 0100) != 0 || ((__oflag) & (020000000 | 040000)) == (020000000 | 040000)) && __builtin_va_arg_pack_len () < 1)
 {
   __open_missing_mode ();
   return __open_2 (__path, __oflag);
 }
      return __open_alias (__path, __oflag, __builtin_va_arg_pack ());
    }

  if (__builtin_va_arg_pack_len () < 1)
    return __open_2 (__path, __oflag);

  return __open_alias (__path, __oflag, __builtin_va_arg_pack ());
}



extern int __open64_2 (const char *__path, int __oflag) __attribute__ ((__nonnull__ (1)));
extern int __open64_alias (const char *__path, int __oflag, ...) __asm__ ("" "open64")
                   __attribute__ ((__nonnull__ (1)));
extern void __open64_too_many_args (void) __attribute__((__error__ ("open64 can be called either with 2 or 3 arguments, not more")))
                                                                    ;
extern void __open64_missing_mode (void) __attribute__((__error__ ("open64 with O_CREAT or O_TMPFILE in second argument needs 3 arguments")))
                                                                              ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
open64 (const char *__path, int __oflag, ...)
{
  if (__builtin_va_arg_pack_len () > 1)
    __open64_too_many_args ();

  if (__builtin_constant_p (__oflag))
    {
      if ((((__oflag) & 0100) != 0 || ((__oflag) & (020000000 | 040000)) == (020000000 | 040000)) && __builtin_va_arg_pack_len () < 1)
 {
   __open64_missing_mode ();
   return __open64_2 (__path, __oflag);
 }
      return __open64_alias (__path, __oflag, __builtin_va_arg_pack ());
    }

  if (__builtin_va_arg_pack_len () < 1)
    return __open64_2 (__path, __oflag);

  return __open64_alias (__path, __oflag, __builtin_va_arg_pack ());
}





extern int __openat_2 (int __fd, const char *__path, int __oflag)
     __attribute__ ((__nonnull__ (2)));
extern int __openat_alias (int __fd, const char *__path, int __oflag, ...) __asm__ ("" "openat")

     __attribute__ ((__nonnull__ (2)));
# 111 "/usr/include/aarch64-linux-gnu/bits/fcntl2.h" 3 4
extern void __openat_too_many_args (void) __attribute__((__error__ ("openat can be called either with 3 or 4 arguments, not more")))
                                                                    ;
extern void __openat_missing_mode (void) __attribute__((__error__ ("openat with O_CREAT or O_TMPFILE in third argument needs 4 arguments")))
                                                                             ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
openat (int __fd, const char *__path, int __oflag, ...)
{
  if (__builtin_va_arg_pack_len () > 1)
    __openat_too_many_args ();

  if (__builtin_constant_p (__oflag))
    {
      if ((((__oflag) & 0100) != 0 || ((__oflag) & (020000000 | 040000)) == (020000000 | 040000)) && __builtin_va_arg_pack_len () < 1)
 {
   __openat_missing_mode ();
   return __openat_2 (__fd, __path, __oflag);
 }
      return __openat_alias (__fd, __path, __oflag, __builtin_va_arg_pack ());
    }

  if (__builtin_va_arg_pack_len () < 1)
    return __openat_2 (__fd, __path, __oflag);

  return __openat_alias (__fd, __path, __oflag, __builtin_va_arg_pack ());
}



extern int __openat64_2 (int __fd, const char *__path, int __oflag)
     __attribute__ ((__nonnull__ (2)));
extern int __openat64_alias (int __fd, const char *__path, int __oflag, ...) __asm__ ("" "openat64")

     __attribute__ ((__nonnull__ (2)));
extern void __openat64_too_many_args (void) __attribute__((__error__ ("openat64 can be called either with 3 or 4 arguments, not more")))
                                                                      ;
extern void __openat64_missing_mode (void) __attribute__((__error__ ("openat64 with O_CREAT or O_TMPFILE in third argument needs 4 arguments")))
                                                                               ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) int
openat64 (int __fd, const char *__path, int __oflag, ...)
{
  if (__builtin_va_arg_pack_len () > 1)
    __openat64_too_many_args ();

  if (__builtin_constant_p (__oflag))
    {
      if ((((__oflag) & 0100) != 0 || ((__oflag) & (020000000 | 040000)) == (020000000 | 040000)) && __builtin_va_arg_pack_len () < 1)
 {
   __openat64_missing_mode ();
   return __openat64_2 (__fd, __path, __oflag);
 }
      return __openat64_alias (__fd, __path, __oflag, __builtin_va_arg_pack ());
    }

  if (__builtin_va_arg_pack_len () < 1)
    return __openat64_2 (__fd, __path, __oflag);

  return __openat64_alias (__fd, __path, __oflag, __builtin_va_arg_pack ());
}
# 315 "/usr/include/fcntl.h" 2 3 4



# 46 "pigpio.c" 2
# 1 "/usr/include/termios.h" 1 3 4
# 35 "/usr/include/termios.h" 3 4




# 1 "/usr/include/aarch64-linux-gnu/bits/termios.h" 1 3 4
# 23 "/usr/include/aarch64-linux-gnu/bits/termios.h" 3 4
typedef unsigned char cc_t;
typedef unsigned int speed_t;
typedef unsigned int tcflag_t;

# 1 "/usr/include/aarch64-linux-gnu/bits/termios-struct.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/termios-struct.h" 3 4
struct termios
  {
    tcflag_t c_iflag;
    tcflag_t c_oflag;
    tcflag_t c_cflag;
    tcflag_t c_lflag;
    cc_t c_line;
    cc_t c_cc[32];
    speed_t c_ispeed;
    speed_t c_ospeed;


  };
# 28 "/usr/include/aarch64-linux-gnu/bits/termios.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/termios-c_cc.h" 1 3 4
# 29 "/usr/include/aarch64-linux-gnu/bits/termios.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/termios-c_iflag.h" 1 3 4
# 30 "/usr/include/aarch64-linux-gnu/bits/termios.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/termios-c_oflag.h" 1 3 4
# 31 "/usr/include/aarch64-linux-gnu/bits/termios.h" 2 3 4
# 53 "/usr/include/aarch64-linux-gnu/bits/termios.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/termios-baud.h" 1 3 4
# 54 "/usr/include/aarch64-linux-gnu/bits/termios.h" 2 3 4

# 1 "/usr/include/aarch64-linux-gnu/bits/termios-c_cflag.h" 1 3 4
# 56 "/usr/include/aarch64-linux-gnu/bits/termios.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/termios-c_lflag.h" 1 3 4
# 57 "/usr/include/aarch64-linux-gnu/bits/termios.h" 2 3 4
# 74 "/usr/include/aarch64-linux-gnu/bits/termios.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/termios-tcflow.h" 1 3 4
# 75 "/usr/include/aarch64-linux-gnu/bits/termios.h" 2 3 4

# 1 "/usr/include/aarch64-linux-gnu/bits/termios-misc.h" 1 3 4
# 77 "/usr/include/aarch64-linux-gnu/bits/termios.h" 2 3 4
# 40 "/usr/include/termios.h" 2 3 4
# 48 "/usr/include/termios.h" 3 4
extern speed_t cfgetospeed (const struct termios *__termios_p) __attribute__ ((__nothrow__ , __leaf__));


extern speed_t cfgetispeed (const struct termios *__termios_p) __attribute__ ((__nothrow__ , __leaf__));


extern int cfsetospeed (struct termios *__termios_p, speed_t __speed) __attribute__ ((__nothrow__ , __leaf__));


extern int cfsetispeed (struct termios *__termios_p, speed_t __speed) __attribute__ ((__nothrow__ , __leaf__));



extern int cfsetspeed (struct termios *__termios_p, speed_t __speed) __attribute__ ((__nothrow__ , __leaf__));




extern int tcgetattr (int __fd, struct termios *__termios_p) __attribute__ ((__nothrow__ , __leaf__));



extern int tcsetattr (int __fd, int __optional_actions,
        const struct termios *__termios_p) __attribute__ ((__nothrow__ , __leaf__));




extern void cfmakeraw (struct termios *__termios_p) __attribute__ ((__nothrow__ , __leaf__));



extern int tcsendbreak (int __fd, int __duration) __attribute__ ((__nothrow__ , __leaf__));





extern int tcdrain (int __fd);



extern int tcflush (int __fd, int __queue_selector) __attribute__ ((__nothrow__ , __leaf__));



extern int tcflow (int __fd, int __action) __attribute__ ((__nothrow__ , __leaf__));




extern __pid_t tcgetsid (int __fd) __attribute__ ((__nothrow__ , __leaf__));




# 1 "/usr/include/aarch64-linux-gnu/sys/ttydefaults.h" 1 3 4
# 105 "/usr/include/termios.h" 2 3 4



# 47 "pigpio.c" 2
# 1 "/usr/include/signal.h" 1 3 4
# 27 "/usr/include/signal.h" 3 4



# 1 "/usr/include/aarch64-linux-gnu/bits/signum-generic.h" 1 3 4
# 76 "/usr/include/aarch64-linux-gnu/bits/signum-generic.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/signum-arch.h" 1 3 4
# 77 "/usr/include/aarch64-linux-gnu/bits/signum-generic.h" 2 3 4
# 31 "/usr/include/signal.h" 2 3 4

# 1 "/usr/include/aarch64-linux-gnu/bits/types/sig_atomic_t.h" 1 3 4







typedef __sig_atomic_t sig_atomic_t;
# 33 "/usr/include/signal.h" 2 3 4
# 57 "/usr/include/signal.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/types/siginfo_t.h" 1 3 4



# 1 "/usr/include/aarch64-linux-gnu/bits/wordsize.h" 1 3 4
# 5 "/usr/include/aarch64-linux-gnu/bits/types/siginfo_t.h" 2 3 4

# 1 "/usr/include/aarch64-linux-gnu/bits/types/__sigval_t.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/types/__sigval_t.h" 3 4
union sigval
{
  int sival_int;
  void *sival_ptr;
};

typedef union sigval __sigval_t;
# 7 "/usr/include/aarch64-linux-gnu/bits/types/siginfo_t.h" 2 3 4
# 16 "/usr/include/aarch64-linux-gnu/bits/types/siginfo_t.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/siginfo-arch.h" 1 3 4
# 17 "/usr/include/aarch64-linux-gnu/bits/types/siginfo_t.h" 2 3 4
# 36 "/usr/include/aarch64-linux-gnu/bits/types/siginfo_t.h" 3 4
typedef struct
  {
    int si_signo;

    int si_errno;

    int si_code;





    int __pad0;


    union
      {
 int _pad[((128 / sizeof (int)) - 4)];


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
   } _kill;


 struct
   {
     int si_tid;
     int si_overrun;
     __sigval_t si_sigval;
   } _timer;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     __sigval_t si_sigval;
   } _rt;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     int si_status;
     __clock_t si_utime;
     __clock_t si_stime;
   } _sigchld;


 struct
   {
     void *si_addr;
    
     short int si_addr_lsb;
     union
       {

  struct
    {
      void *_lower;
      void *_upper;
    } _addr_bnd;

  __uint32_t _pkey;
       } _bounds;
   } _sigfault;


 struct
   {
     long int si_band;
     int si_fd;
   } _sigpoll;



 struct
   {
     void *_call_addr;
     int _syscall;
     unsigned int _arch;
   } _sigsys;

      } _sifields;
  } siginfo_t ;
# 58 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/siginfo-consts.h" 1 3 4
# 35 "/usr/include/aarch64-linux-gnu/bits/siginfo-consts.h" 3 4
enum
{
  SI_ASYNCNL = -60,
  SI_DETHREAD = -7,

  SI_TKILL,
  SI_SIGIO,

  SI_ASYNCIO,
  SI_MESGQ,
  SI_TIMER,





  SI_QUEUE,
  SI_USER,
  SI_KERNEL = 0x80
# 66 "/usr/include/aarch64-linux-gnu/bits/siginfo-consts.h" 3 4
};




enum
{
  ILL_ILLOPC = 1,

  ILL_ILLOPN,

  ILL_ILLADR,

  ILL_ILLTRP,

  ILL_PRVOPC,

  ILL_PRVREG,

  ILL_COPROC,

  ILL_BADSTK,

  ILL_BADIADDR

};


enum
{
  FPE_INTDIV = 1,

  FPE_INTOVF,

  FPE_FLTDIV,

  FPE_FLTOVF,

  FPE_FLTUND,

  FPE_FLTRES,

  FPE_FLTINV,

  FPE_FLTSUB,

  FPE_FLTUNK = 14,

  FPE_CONDTRAP

};


enum
{
  SEGV_MAPERR = 1,

  SEGV_ACCERR,

  SEGV_BNDERR,

  SEGV_PKUERR,

  SEGV_ACCADI,

  SEGV_ADIDERR,

  SEGV_ADIPERR,

  SEGV_MTEAERR,

  SEGV_MTESERR

};


enum
{
  BUS_ADRALN = 1,

  BUS_ADRERR,

  BUS_OBJERR,

  BUS_MCEERR_AR,

  BUS_MCEERR_AO

};




enum
{
  TRAP_BRKPT = 1,

  TRAP_TRACE,

  TRAP_BRANCH,

  TRAP_HWBKPT,

  TRAP_UNK

};




enum
{
  CLD_EXITED = 1,

  CLD_KILLED,

  CLD_DUMPED,

  CLD_TRAPPED,

  CLD_STOPPED,

  CLD_CONTINUED

};


enum
{
  POLL_IN = 1,

  POLL_OUT,

  POLL_MSG,

  POLL_ERR,

  POLL_PRI,

  POLL_HUP

};





# 1 "/usr/include/aarch64-linux-gnu/bits/siginfo-consts-arch.h" 1 3 4
# 214 "/usr/include/aarch64-linux-gnu/bits/siginfo-consts.h" 2 3 4
# 59 "/usr/include/signal.h" 2 3 4



# 1 "/usr/include/aarch64-linux-gnu/bits/types/sigval_t.h" 1 3 4
# 16 "/usr/include/aarch64-linux-gnu/bits/types/sigval_t.h" 3 4
typedef __sigval_t sigval_t;
# 63 "/usr/include/signal.h" 2 3 4



# 1 "/usr/include/aarch64-linux-gnu/bits/types/sigevent_t.h" 1 3 4



# 1 "/usr/include/aarch64-linux-gnu/bits/wordsize.h" 1 3 4
# 5 "/usr/include/aarch64-linux-gnu/bits/types/sigevent_t.h" 2 3 4
# 22 "/usr/include/aarch64-linux-gnu/bits/types/sigevent_t.h" 3 4
typedef struct sigevent
  {
    __sigval_t sigev_value;
    int sigev_signo;
    int sigev_notify;

    union
      {
 int _pad[((64 / sizeof (int)) - 4)];



 __pid_t _tid;

 struct
   {
     void (*_function) (__sigval_t);
     pthread_attr_t *_attribute;
   } _sigev_thread;
      } _sigev_un;
  } sigevent_t;
# 67 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/sigevent-consts.h" 1 3 4
# 27 "/usr/include/aarch64-linux-gnu/bits/sigevent-consts.h" 3 4
enum
{
  SIGEV_SIGNAL = 0,

  SIGEV_NONE,

  SIGEV_THREAD,


  SIGEV_THREAD_ID = 4


};
# 68 "/usr/include/signal.h" 2 3 4




typedef void (*__sighandler_t) (int);




extern __sighandler_t __sysv_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));

extern __sighandler_t sysv_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));






extern __sighandler_t signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));
# 112 "/usr/include/signal.h" 3 4
extern int kill (__pid_t __pid, int __sig) __attribute__ ((__nothrow__ , __leaf__));






extern int killpg (__pid_t __pgrp, int __sig) __attribute__ ((__nothrow__ , __leaf__));



extern int raise (int __sig) __attribute__ ((__nothrow__ , __leaf__));



extern __sighandler_t ssignal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));
extern int gsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));




extern void psignal (int __sig, const char *__s);


extern void psiginfo (const siginfo_t *__pinfo, const char *__s);
# 151 "/usr/include/signal.h" 3 4
extern int sigpause (int __sig) __asm__ ("__xpg_sigpause")
  __attribute__ ((__deprecated__ ("Use the sigsuspend function instead")));
# 173 "/usr/include/signal.h" 3 4
extern int sigblock (int __mask) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));


extern int sigsetmask (int __mask) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));


extern int siggetmask (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
# 188 "/usr/include/signal.h" 3 4
typedef __sighandler_t sighandler_t;




typedef __sighandler_t sig_t;





extern int sigemptyset (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigfillset (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigaddset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigdelset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigismember (const sigset_t *__set, int __signo)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int sigisemptyset (const sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigandset (sigset_t *__set, const sigset_t *__left,
        const sigset_t *__right) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3)));


extern int sigorset (sigset_t *__set, const sigset_t *__left,
       const sigset_t *__right) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3)));




# 1 "/usr/include/aarch64-linux-gnu/bits/sigaction.h" 1 3 4
# 27 "/usr/include/aarch64-linux-gnu/bits/sigaction.h" 3 4
struct sigaction
  {


    union
      {

 __sighandler_t sa_handler;

 void (*sa_sigaction) (int, siginfo_t *, void *);
      }
    __sigaction_handler;







    __sigset_t sa_mask;


    int sa_flags;


    void (*sa_restorer) (void);
  };
# 230 "/usr/include/signal.h" 2 3 4


extern int sigprocmask (int __how, const sigset_t *__restrict __set,
   sigset_t *__restrict __oset) __attribute__ ((__nothrow__ , __leaf__));






extern int sigsuspend (const sigset_t *__set) __attribute__ ((__nonnull__ (1)));


extern int sigaction (int __sig, const struct sigaction *__restrict __act,
        struct sigaction *__restrict __oact) __attribute__ ((__nothrow__ , __leaf__));


extern int sigpending (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int sigwait (const sigset_t *__restrict __set, int *__restrict __sig)
     __attribute__ ((__nonnull__ (1, 2)));







extern int sigwaitinfo (const sigset_t *__restrict __set,
   siginfo_t *__restrict __info) __attribute__ ((__nonnull__ (1)));







extern int sigtimedwait (const sigset_t *__restrict __set,
    siginfo_t *__restrict __info,
    const struct timespec *__restrict __timeout)
     __attribute__ ((__nonnull__ (1)));
# 292 "/usr/include/signal.h" 3 4
extern int sigqueue (__pid_t __pid, int __sig, const union sigval __val)
     __attribute__ ((__nothrow__ , __leaf__));







# 1 "/usr/include/aarch64-linux-gnu/bits/sigcontext.h" 1 3 4
# 30 "/usr/include/aarch64-linux-gnu/bits/sigcontext.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/asm/sigcontext.h" 1 3 4
# 22 "/usr/include/aarch64-linux-gnu/asm/sigcontext.h" 3 4
# 1 "/usr/include/linux/types.h" 1 3 4




# 1 "/usr/include/aarch64-linux-gnu/asm/types.h" 1 3 4
# 1 "/usr/include/asm-generic/types.h" 1 3 4






# 1 "/usr/include/asm-generic/int-ll64.h" 1 3 4
# 12 "/usr/include/asm-generic/int-ll64.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/asm/bitsperlong.h" 1 3 4
# 22 "/usr/include/aarch64-linux-gnu/asm/bitsperlong.h" 3 4
# 1 "/usr/include/asm-generic/bitsperlong.h" 1 3 4
# 23 "/usr/include/aarch64-linux-gnu/asm/bitsperlong.h" 2 3 4
# 13 "/usr/include/asm-generic/int-ll64.h" 2 3 4







typedef __signed__ char __s8;
typedef unsigned char __u8;

typedef __signed__ short __s16;
typedef unsigned short __u16;

typedef __signed__ int __s32;
typedef unsigned int __u32;


__extension__ typedef __signed__ long long __s64;
__extension__ typedef unsigned long long __u64;
# 8 "/usr/include/asm-generic/types.h" 2 3 4
# 2 "/usr/include/aarch64-linux-gnu/asm/types.h" 2 3 4
# 6 "/usr/include/linux/types.h" 2 3 4



# 1 "/usr/include/linux/posix_types.h" 1 3 4




# 1 "/usr/include/linux/stddef.h" 1 3 4
# 6 "/usr/include/linux/posix_types.h" 2 3 4
# 25 "/usr/include/linux/posix_types.h" 3 4
typedef struct {
 unsigned long fds_bits[1024 / (8 * sizeof(long))];
} __kernel_fd_set;


typedef void (*__kernel_sighandler_t)(int);


typedef int __kernel_key_t;
typedef int __kernel_mqd_t;

# 1 "/usr/include/aarch64-linux-gnu/asm/posix_types.h" 1 3 4




typedef unsigned short __kernel_old_uid_t;
typedef unsigned short __kernel_old_gid_t;


# 1 "/usr/include/asm-generic/posix_types.h" 1 3 4
# 15 "/usr/include/asm-generic/posix_types.h" 3 4
typedef long __kernel_long_t;
typedef unsigned long __kernel_ulong_t;



typedef __kernel_ulong_t __kernel_ino_t;



typedef unsigned int __kernel_mode_t;



typedef int __kernel_pid_t;



typedef int __kernel_ipc_pid_t;



typedef unsigned int __kernel_uid_t;
typedef unsigned int __kernel_gid_t;



typedef __kernel_long_t __kernel_suseconds_t;



typedef int __kernel_daddr_t;



typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;
# 59 "/usr/include/asm-generic/posix_types.h" 3 4
typedef unsigned int __kernel_old_dev_t;
# 72 "/usr/include/asm-generic/posix_types.h" 3 4
typedef __kernel_ulong_t __kernel_size_t;
typedef __kernel_long_t __kernel_ssize_t;
typedef __kernel_long_t __kernel_ptrdiff_t;




typedef struct {
 int val[2];
} __kernel_fsid_t;





typedef __kernel_long_t __kernel_off_t;
typedef long long __kernel_loff_t;
typedef __kernel_long_t __kernel_old_time_t;
typedef __kernel_long_t __kernel_time_t;
typedef long long __kernel_time64_t;
typedef __kernel_long_t __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef char * __kernel_caddr_t;
typedef unsigned short __kernel_uid16_t;
typedef unsigned short __kernel_gid16_t;
# 10 "/usr/include/aarch64-linux-gnu/asm/posix_types.h" 2 3 4
# 37 "/usr/include/linux/posix_types.h" 2 3 4
# 10 "/usr/include/linux/types.h" 2 3 4
# 24 "/usr/include/linux/types.h" 3 4
typedef __u16 __le16;
typedef __u16 __be16;
typedef __u32 __le32;
typedef __u32 __be32;
typedef __u64 __le64;
typedef __u64 __be64;

typedef __u16 __sum16;
typedef __u32 __wsum;
# 47 "/usr/include/linux/types.h" 3 4
typedef unsigned __poll_t;
# 23 "/usr/include/aarch64-linux-gnu/asm/sigcontext.h" 2 3 4





struct sigcontext {
 __u64 fault_address;

 __u64 regs[31];
 __u64 sp;
 __u64 pc;
 __u64 pstate;

 __u8 __reserved[4096] __attribute__((__aligned__(16)));
};
# 66 "/usr/include/aarch64-linux-gnu/asm/sigcontext.h" 3 4
struct _aarch64_ctx {
 __u32 magic;
 __u32 size;
};



struct fpsimd_context {
 struct _aarch64_ctx head;
 __u32 fpsr;
 __u32 fpcr;
 unsigned __int128 vregs[32];
};
# 92 "/usr/include/aarch64-linux-gnu/asm/sigcontext.h" 3 4
struct esr_context {
 struct _aarch64_ctx head;
 __u64 esr;
};
# 125 "/usr/include/aarch64-linux-gnu/asm/sigcontext.h" 3 4
struct extra_context {
 struct _aarch64_ctx head;
 __u64 datap;
 __u32 size;
 __u32 __reserved[3];
};



struct sve_context {
 struct _aarch64_ctx head;
 __u16 vl;
 __u16 __reserved[3];
};



# 1 "/usr/include/aarch64-linux-gnu/asm/sve_context.h" 1 3 4
# 143 "/usr/include/aarch64-linux-gnu/asm/sigcontext.h" 2 3 4
# 31 "/usr/include/aarch64-linux-gnu/bits/sigcontext.h" 2 3 4



# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 35 "/usr/include/aarch64-linux-gnu/bits/sigcontext.h" 2 3 4
# 302 "/usr/include/signal.h" 2 3 4


extern int sigreturn (struct sigcontext *__scp) __attribute__ ((__nothrow__ , __leaf__));






# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 312 "/usr/include/signal.h" 2 3 4

# 1 "/usr/include/aarch64-linux-gnu/bits/types/stack_t.h" 1 3 4
# 23 "/usr/include/aarch64-linux-gnu/bits/types/stack_t.h" 3 4
# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/types/stack_t.h" 2 3 4


typedef struct
  {
    void *ss_sp;
    int ss_flags;
    size_t ss_size;
  } stack_t;
# 314 "/usr/include/signal.h" 2 3 4


# 1 "/usr/include/aarch64-linux-gnu/sys/ucontext.h" 1 3 4
# 36 "/usr/include/aarch64-linux-gnu/sys/ucontext.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/sys/procfs.h" 1 3 4
# 33 "/usr/include/aarch64-linux-gnu/sys/procfs.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/sys/time.h" 1 3 4
# 34 "/usr/include/aarch64-linux-gnu/sys/time.h" 3 4

# 52 "/usr/include/aarch64-linux-gnu/sys/time.h" 3 4
struct timezone
  {
    int tz_minuteswest;
    int tz_dsttime;
  };
# 67 "/usr/include/aarch64-linux-gnu/sys/time.h" 3 4
extern int gettimeofday (struct timeval *__restrict __tv,
    void *__restrict __tz) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 86 "/usr/include/aarch64-linux-gnu/sys/time.h" 3 4
extern int settimeofday (const struct timeval *__tv,
    const struct timezone *__tz)
     __attribute__ ((__nothrow__ , __leaf__));





extern int adjtime (const struct timeval *__delta,
      struct timeval *__olddelta) __attribute__ ((__nothrow__ , __leaf__));
# 114 "/usr/include/aarch64-linux-gnu/sys/time.h" 3 4
enum __itimer_which
  {

    ITIMER_REAL = 0,


    ITIMER_VIRTUAL = 1,



    ITIMER_PROF = 2

  };



struct itimerval
  {

    struct timeval it_interval;

    struct timeval it_value;
  };




typedef enum __itimer_which __itimer_which_t;







extern int getitimer (__itimer_which_t __which,
        struct itimerval *__value) __attribute__ ((__nothrow__ , __leaf__));




extern int setitimer (__itimer_which_t __which,
        const struct itimerval *__restrict __new,
        struct itimerval *__restrict __old) __attribute__ ((__nothrow__ , __leaf__));




extern int utimes (const char *__file, const struct timeval __tvp[2])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 189 "/usr/include/aarch64-linux-gnu/sys/time.h" 3 4
extern int lutimes (const char *__file, const struct timeval __tvp[2])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int futimes (int __fd, const struct timeval __tvp[2]) __attribute__ ((__nothrow__ , __leaf__));
# 214 "/usr/include/aarch64-linux-gnu/sys/time.h" 3 4
extern int futimesat (int __fd, const char *__file,
        const struct timeval __tvp[2]) __attribute__ ((__nothrow__ , __leaf__));
# 258 "/usr/include/aarch64-linux-gnu/sys/time.h" 3 4

# 34 "/usr/include/aarch64-linux-gnu/sys/procfs.h" 2 3 4

# 1 "/usr/include/aarch64-linux-gnu/sys/user.h" 1 3 4
# 22 "/usr/include/aarch64-linux-gnu/sys/user.h" 3 4
struct user_regs_struct
{
  unsigned long long regs[31];
  unsigned long long sp;
  unsigned long long pc;
  unsigned long long pstate;
};

struct user_fpsimd_struct
{
  unsigned __int128 vregs[32];
  unsigned int fpsr;
  unsigned int fpcr;
};
# 36 "/usr/include/aarch64-linux-gnu/sys/procfs.h" 2 3 4




# 1 "/usr/include/aarch64-linux-gnu/bits/procfs.h" 1 3 4
# 25 "/usr/include/aarch64-linux-gnu/bits/procfs.h" 3 4
typedef __uint64_t elf_greg_t;






typedef elf_greg_t elf_gregset_t[(sizeof (struct user_regs_struct) / sizeof (elf_greg_t))];


typedef struct user_fpsimd_struct elf_fpregset_t;
# 41 "/usr/include/aarch64-linux-gnu/sys/procfs.h" 2 3 4



# 1 "/usr/include/aarch64-linux-gnu/bits/procfs-id.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/procfs-id.h" 3 4
typedef unsigned int __pr_uid_t;
typedef unsigned int __pr_gid_t;
# 45 "/usr/include/aarch64-linux-gnu/sys/procfs.h" 2 3 4




struct elf_siginfo
  {
    int si_signo;
    int si_code;
    int si_errno;
  };
# 63 "/usr/include/aarch64-linux-gnu/sys/procfs.h" 3 4
struct elf_prstatus
  {
    struct elf_siginfo pr_info;
    short int pr_cursig;
    unsigned long int pr_sigpend;
    unsigned long int pr_sighold;
    __pid_t pr_pid;
    __pid_t pr_ppid;
    __pid_t pr_pgrp;
    __pid_t pr_sid;
    struct timeval pr_utime;
    struct timeval pr_stime;
    struct timeval pr_cutime;
    struct timeval pr_cstime;
    elf_gregset_t pr_reg;
    int pr_fpvalid;
  };




struct elf_prpsinfo
  {
    char pr_state;
    char pr_sname;
    char pr_zomb;
    char pr_nice;
    unsigned long int pr_flag;
    __pr_uid_t pr_uid;
    __pr_gid_t pr_gid;
    int pr_pid, pr_ppid, pr_pgrp, pr_sid;

    char pr_fname[16];
    char pr_psargs[(80)];
  };






typedef void *psaddr_t;

# 1 "/usr/include/aarch64-linux-gnu/bits/procfs-prregset.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/procfs-prregset.h" 3 4
typedef elf_gregset_t __prgregset_t;
typedef elf_fpregset_t __prfpregset_t;
# 107 "/usr/include/aarch64-linux-gnu/sys/procfs.h" 2 3 4


typedef __prgregset_t prgregset_t;
typedef __prfpregset_t prfpregset_t;



typedef __pid_t lwpid_t;


typedef struct elf_prstatus prstatus_t;
typedef struct elf_prpsinfo prpsinfo_t;





# 1 "/usr/include/aarch64-linux-gnu/bits/procfs-extra.h" 1 3 4
# 125 "/usr/include/aarch64-linux-gnu/sys/procfs.h" 2 3 4
# 37 "/usr/include/aarch64-linux-gnu/sys/ucontext.h" 2 3 4


typedef elf_greg_t greg_t;


typedef elf_gregset_t gregset_t;


typedef elf_fpregset_t fpregset_t;






typedef struct
  {
    unsigned long long int fault_address;
    unsigned long long int regs[31];
    unsigned long long int sp;
    unsigned long long int pc;
    unsigned long long int pstate;




    unsigned char __reserved[4096] __attribute__ ((__aligned__ (16)));
  } mcontext_t;


typedef struct ucontext_t
  {
    unsigned long uc_flags;
    struct ucontext_t *uc_link;
    stack_t uc_stack;
    sigset_t uc_sigmask;
    mcontext_t uc_mcontext;
  } ucontext_t;
# 317 "/usr/include/signal.h" 2 3 4







extern int siginterrupt (int __sig, int __interrupt) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__deprecated__ ("Use sigaction with SA_RESTART instead")));

# 1 "/usr/include/aarch64-linux-gnu/bits/sigstack.h" 1 3 4
# 328 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/sigstksz.h" 1 3 4
# 329 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/ss_flags.h" 1 3 4
# 27 "/usr/include/aarch64-linux-gnu/bits/ss_flags.h" 3 4
enum
{
  SS_ONSTACK = 1,

  SS_DISABLE

};
# 330 "/usr/include/signal.h" 2 3 4



extern int sigaltstack (const stack_t *__restrict __ss,
   stack_t *__restrict __oss) __attribute__ ((__nothrow__ , __leaf__));




# 1 "/usr/include/aarch64-linux-gnu/bits/types/struct_sigstack.h" 1 3 4
# 23 "/usr/include/aarch64-linux-gnu/bits/types/struct_sigstack.h" 3 4
struct sigstack
  {
    void *ss_sp;
    int ss_onstack;
  };
# 340 "/usr/include/signal.h" 2 3 4







extern int sigstack (struct sigstack *__ss, struct sigstack *__oss)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));






extern int sighold (int __sig) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__deprecated__ ("Use the sigprocmask function instead")));


extern int sigrelse (int __sig) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__deprecated__ ("Use the sigprocmask function instead")));


extern int sigignore (int __sig) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__deprecated__ ("Use the signal function instead")));


extern __sighandler_t sigset (int __sig, __sighandler_t __disp) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__deprecated__ ("Use the signal and sigprocmask functions instead")))
                                                        ;






# 1 "/usr/include/aarch64-linux-gnu/bits/sigthread.h" 1 3 4
# 31 "/usr/include/aarch64-linux-gnu/bits/sigthread.h" 3 4
extern int pthread_sigmask (int __how,
       const __sigset_t *__restrict __newmask,
       __sigset_t *__restrict __oldmask)__attribute__ ((__nothrow__ , __leaf__));


extern int pthread_kill (pthread_t __threadid, int __signo) __attribute__ ((__nothrow__ , __leaf__));



extern int pthread_sigqueue (pthread_t __threadid, int __signo,
        const union sigval __value) __attribute__ ((__nothrow__ , __leaf__));
# 377 "/usr/include/signal.h" 2 3 4






extern int __libc_current_sigrtmin (void) __attribute__ ((__nothrow__ , __leaf__));

extern int __libc_current_sigrtmax (void) __attribute__ ((__nothrow__ , __leaf__));





# 1 "/usr/include/aarch64-linux-gnu/bits/signal_ext.h" 1 3 4
# 29 "/usr/include/aarch64-linux-gnu/bits/signal_ext.h" 3 4
extern int tgkill (__pid_t __tgid, __pid_t __tid, int __signal);
# 392 "/usr/include/signal.h" 2 3 4


# 48 "pigpio.c" 2
# 1 "/usr/include/errno.h" 1 3 4
# 28 "/usr/include/errno.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/errno.h" 1 3 4
# 26 "/usr/include/aarch64-linux-gnu/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/aarch64-linux-gnu/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4




# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 6 "/usr/include/asm-generic/errno.h" 2 3 4
# 2 "/usr/include/aarch64-linux-gnu/asm/errno.h" 2 3 4
# 2 "/usr/include/linux/errno.h" 2 3 4
# 27 "/usr/include/aarch64-linux-gnu/bits/errno.h" 2 3 4
# 29 "/usr/include/errno.h" 2 3 4








extern int *__errno_location (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));







extern char *program_invocation_name;
extern char *program_invocation_short_name;

# 1 "/usr/include/aarch64-linux-gnu/bits/types/error_t.h" 1 3 4
# 22 "/usr/include/aarch64-linux-gnu/bits/types/error_t.h" 3 4
typedef int error_t;
# 49 "/usr/include/errno.h" 2 3 4




# 49 "pigpio.c" 2
# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4
# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 30 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/aarch64-linux-gnu/bits/time.h" 1 3 4
# 73 "/usr/include/aarch64-linux-gnu/bits/time.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/timex.h" 1 3 4
# 26 "/usr/include/aarch64-linux-gnu/bits/timex.h" 3 4
struct timex
{
# 58 "/usr/include/aarch64-linux-gnu/bits/timex.h" 3 4
  unsigned int modes;
  __syscall_slong_t offset;
  __syscall_slong_t freq;
  __syscall_slong_t maxerror;
  __syscall_slong_t esterror;
  int status;
  __syscall_slong_t constant;
  __syscall_slong_t precision;
  __syscall_slong_t tolerance;
  struct timeval time;
  __syscall_slong_t tick;
  __syscall_slong_t ppsfreq;
  __syscall_slong_t jitter;
  int shift;
  __syscall_slong_t stabil;
  __syscall_slong_t jitcnt;
  __syscall_slong_t calcnt;
  __syscall_slong_t errcnt;
  __syscall_slong_t stbcnt;

  int tai;


  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32; int :32;
  int :32; int :32; int :32;

};
# 74 "/usr/include/aarch64-linux-gnu/bits/time.h" 2 3 4




extern int clock_adjtime (__clockid_t __clock_id, struct timex *__utx) __attribute__ ((__nothrow__ , __leaf__));
# 90 "/usr/include/aarch64-linux-gnu/bits/time.h" 3 4

# 34 "/usr/include/time.h" 2 3 4





# 1 "/usr/include/aarch64-linux-gnu/bits/types/struct_tm.h" 1 3 4






struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};
# 40 "/usr/include/time.h" 2 3 4
# 48 "/usr/include/time.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/types/struct_itimerspec.h" 1 3 4







struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };
# 49 "/usr/include/time.h" 2 3 4
struct sigevent;
# 68 "/usr/include/time.h" 3 4




extern clock_t clock (void) __attribute__ ((__nothrow__ , __leaf__));



extern time_t time (time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));


extern double difftime (time_t __time1, time_t __time0)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));
# 100 "/usr/include/time.h" 3 4
extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));




extern char *strptime (const char *__restrict __s,
         const char *__restrict __fmt, struct tm *__tp)
     __attribute__ ((__nothrow__ , __leaf__));






extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));



extern char *strptime_l (const char *__restrict __s,
    const char *__restrict __fmt, struct tm *__tp,
    locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));






extern struct tm *gmtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));



extern struct tm *localtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));
# 154 "/usr/include/time.h" 3 4
extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));
# 179 "/usr/include/time.h" 3 4
extern char *asctime (const struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));



extern char *ctime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));
# 197 "/usr/include/time.h" 3 4
extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));
# 217 "/usr/include/time.h" 3 4
extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) __attribute__ ((__nothrow__ , __leaf__));



extern int daylight;
extern long int timezone;
# 249 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));

extern time_t timelocal (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));
# 262 "/usr/include/time.h" 3 4
extern int dysize (int __year) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 272 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);


extern int clock_getres (clockid_t __clock_id, struct timespec *__res) __attribute__ ((__nothrow__ , __leaf__));


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     __attribute__ ((__nothrow__ , __leaf__));
# 311 "/usr/include/time.h" 3 4
extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);
# 326 "/usr/include/time.h" 3 4
extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) __attribute__ ((__nothrow__ , __leaf__));




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_delete (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));



extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     __attribute__ ((__nothrow__ , __leaf__));
# 364 "/usr/include/time.h" 3 4
extern int timer_getoverrun (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));






extern int timespec_get (struct timespec *__ts, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 387 "/usr/include/time.h" 3 4
extern int timespec_getres (struct timespec *__ts, int __base)
     __attribute__ ((__nothrow__ , __leaf__));
# 413 "/usr/include/time.h" 3 4
extern int getdate_err;
# 422 "/usr/include/time.h" 3 4
extern struct tm *getdate (const char *__string);
# 436 "/usr/include/time.h" 3 4
extern int getdate_r (const char *__restrict __string,
        struct tm *__restrict __resbufp);



# 50 "pigpio.c" 2
# 1 "/usr/include/aarch64-linux-gnu/sys/ioctl.h" 1 3 4
# 23 "/usr/include/aarch64-linux-gnu/sys/ioctl.h" 3 4



# 1 "/usr/include/aarch64-linux-gnu/bits/ioctls.h" 1 3 4
# 23 "/usr/include/aarch64-linux-gnu/bits/ioctls.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/asm/ioctls.h" 1 3 4
# 1 "/usr/include/asm-generic/ioctls.h" 1 3 4




# 1 "/usr/include/linux/ioctl.h" 1 3 4




# 1 "/usr/include/aarch64-linux-gnu/asm/ioctl.h" 1 3 4
# 1 "/usr/include/asm-generic/ioctl.h" 1 3 4
# 2 "/usr/include/aarch64-linux-gnu/asm/ioctl.h" 2 3 4
# 6 "/usr/include/linux/ioctl.h" 2 3 4
# 6 "/usr/include/asm-generic/ioctls.h" 2 3 4
# 2 "/usr/include/aarch64-linux-gnu/asm/ioctls.h" 2 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/ioctls.h" 2 3 4
# 27 "/usr/include/aarch64-linux-gnu/sys/ioctl.h" 2 3 4


# 1 "/usr/include/aarch64-linux-gnu/bits/ioctl-types.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/ioctl-types.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/asm/ioctls.h" 1 3 4
# 25 "/usr/include/aarch64-linux-gnu/bits/ioctl-types.h" 2 3 4


struct winsize
  {
    unsigned short int ws_row;
    unsigned short int ws_col;
    unsigned short int ws_xpixel;
    unsigned short int ws_ypixel;
  };


struct termio
  {
    unsigned short int c_iflag;
    unsigned short int c_oflag;
    unsigned short int c_cflag;
    unsigned short int c_lflag;
    unsigned char c_line;
    unsigned char c_cc[8];
};
# 30 "/usr/include/aarch64-linux-gnu/sys/ioctl.h" 2 3 4






# 1 "/usr/include/aarch64-linux-gnu/sys/ttydefaults.h" 1 3 4
# 37 "/usr/include/aarch64-linux-gnu/sys/ioctl.h" 2 3 4





extern int ioctl (int __fd, unsigned long int __request, ...) __attribute__ ((__nothrow__ , __leaf__));
# 53 "/usr/include/aarch64-linux-gnu/sys/ioctl.h" 3 4

# 51 "pigpio.c" 2
# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/limits.h" 1 3 4
# 34 "/usr/lib/gcc/aarch64-linux-gnu/11/include/limits.h" 3 4
# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/limits.h" 1 3 4
# 203 "/usr/lib/gcc/aarch64-linux-gnu/11/include/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 26 "/usr/include/limits.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/libc-header-start.h" 1 3 4
# 27 "/usr/include/limits.h" 2 3 4
# 195 "/usr/include/limits.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/posix1_lim.h" 1 3 4
# 27 "/usr/include/aarch64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/wordsize.h" 1 3 4
# 28 "/usr/include/aarch64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 161 "/usr/include/aarch64-linux-gnu/bits/posix1_lim.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/local_lim.h" 1 3 4
# 38 "/usr/include/aarch64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/aarch64-linux-gnu/bits/local_lim.h" 2 3 4
# 81 "/usr/include/aarch64-linux-gnu/bits/local_lim.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/pthread_stack_min-dynamic.h" 1 3 4
# 23 "/usr/include/aarch64-linux-gnu/bits/pthread_stack_min-dynamic.h" 3 4

extern long int __sysconf (int __name) __attribute__ ((__nothrow__ , __leaf__));

# 82 "/usr/include/aarch64-linux-gnu/bits/local_lim.h" 2 3 4
# 162 "/usr/include/aarch64-linux-gnu/bits/posix1_lim.h" 2 3 4
# 196 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/aarch64-linux-gnu/bits/posix2_lim.h" 1 3 4
# 200 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/aarch64-linux-gnu/bits/xopen_lim.h" 1 3 4
# 64 "/usr/include/aarch64-linux-gnu/bits/xopen_lim.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/uio_lim.h" 1 3 4
# 65 "/usr/include/aarch64-linux-gnu/bits/xopen_lim.h" 2 3 4
# 204 "/usr/include/limits.h" 2 3 4
# 204 "/usr/lib/gcc/aarch64-linux-gnu/11/include/limits.h" 2 3 4
# 8 "/usr/lib/gcc/aarch64-linux-gnu/11/include/syslimits.h" 2 3 4
# 35 "/usr/lib/gcc/aarch64-linux-gnu/11/include/limits.h" 2 3 4
# 52 "pigpio.c" 2
# 1 "/usr/include/pthread.h" 1 3 4
# 22 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 29 "/usr/include/sched.h" 3 4
# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 30 "/usr/include/sched.h" 2 3 4
# 43 "/usr/include/sched.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/sched.h" 1 3 4
# 76 "/usr/include/aarch64-linux-gnu/bits/sched.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/types/struct_sched_param.h" 1 3 4
# 23 "/usr/include/aarch64-linux-gnu/bits/types/struct_sched_param.h" 3 4
struct sched_param
{
  int sched_priority;
};
# 77 "/usr/include/aarch64-linux-gnu/bits/sched.h" 2 3 4





extern int clone (int (*__fn) (void *__arg), void *__child_stack,
    int __flags, void *__arg, ...) __attribute__ ((__nothrow__ , __leaf__));


extern int unshare (int __flags) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_getcpu (void) __attribute__ ((__nothrow__ , __leaf__));


extern int getcpu (unsigned int *, unsigned int *) __attribute__ ((__nothrow__ , __leaf__));


extern int setns (int __fd, int __nstype) __attribute__ ((__nothrow__ , __leaf__));



# 44 "/usr/include/sched.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/cpu-set.h" 1 3 4
# 32 "/usr/include/aarch64-linux-gnu/bits/cpu-set.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 115 "/usr/include/aarch64-linux-gnu/bits/cpu-set.h" 3 4


extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
     __attribute__ ((__nothrow__ , __leaf__));
extern cpu_set_t *__sched_cpualloc (size_t __count) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));
extern void __sched_cpufree (cpu_set_t *__set) __attribute__ ((__nothrow__ , __leaf__));


# 45 "/usr/include/sched.h" 2 3 4









extern int sched_setparam (__pid_t __pid, const struct sched_param *__param)
     __attribute__ ((__nothrow__ , __leaf__));


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_setscheduler (__pid_t __pid, int __policy,
          const struct sched_param *__param) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_getscheduler (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_yield (void) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_get_priority_max (int __algorithm) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_get_priority_min (int __algorithm) __attribute__ ((__nothrow__ , __leaf__));



extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) __attribute__ ((__nothrow__ , __leaf__));
# 130 "/usr/include/sched.h" 3 4
extern int sched_setaffinity (__pid_t __pid, size_t __cpusetsize,
         const cpu_set_t *__cpuset) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_getaffinity (__pid_t __pid, size_t __cpusetsize,
         cpu_set_t *__cpuset) __attribute__ ((__nothrow__ , __leaf__));



# 23 "/usr/include/pthread.h" 2 3 4




# 1 "/usr/include/aarch64-linux-gnu/bits/setjmp.h" 1 3 4
# 30 "/usr/include/aarch64-linux-gnu/bits/setjmp.h" 3 4
__extension__ typedef unsigned long long __jmp_buf [22];
# 28 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/wordsize.h" 1 3 4
# 29 "/usr/include/pthread.h" 2 3 4


# 1 "/usr/include/aarch64-linux-gnu/bits/types/struct___jmp_buf_tag.h" 1 3 4
# 26 "/usr/include/aarch64-linux-gnu/bits/types/struct___jmp_buf_tag.h" 3 4
struct __jmp_buf_tag
  {




    __jmp_buf __jmpbuf;
    int __mask_was_saved;
    __sigset_t __saved_mask;
  };
# 32 "/usr/include/pthread.h" 2 3 4





enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL



  , PTHREAD_MUTEX_FAST_NP = PTHREAD_MUTEX_TIMED_NP

};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
# 104 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
# 124 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
# 159 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 197 "/usr/include/pthread.h" 3 4





extern int pthread_create (pthread_t *__restrict __newthread,
      const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);




extern int pthread_tryjoin_np (pthread_t __th, void **__thread_return) __attribute__ ((__nothrow__ , __leaf__));
# 233 "/usr/include/pthread.h" 3 4
extern int pthread_timedjoin_np (pthread_t __th, void **__thread_return,
     const struct timespec *__abstime);
# 243 "/usr/include/pthread.h" 3 4
extern int pthread_clockjoin_np (pthread_t __th, void **__thread_return,
                                 clockid_t __clockid,
     const struct timespec *__abstime);
# 269 "/usr/include/pthread.h" 3 4
extern int pthread_detach (pthread_t __th) __attribute__ ((__nothrow__ , __leaf__));



extern pthread_t pthread_self (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));







extern int pthread_attr_init (pthread_attr_t *__attr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
     int *__detachstate)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (const pthread_attr_t *__attr,
          size_t *__guardsize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,
           struct sched_param *__restrict __param)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           const struct sched_param *__restrict
           __param) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int pthread_attr_setaffinity_np (pthread_attr_t *__attr,
     size_t __cpusetsize,
     const cpu_set_t *__cpuset)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));



extern int pthread_attr_getaffinity_np (const pthread_attr_t *__attr,
     size_t __cpusetsize,
     cpu_set_t *__cpuset)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));


extern int pthread_getattr_default_np (pthread_attr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_setsigmask_np (pthread_attr_t *__attr,
           const __sigset_t *sigmask);




extern int pthread_attr_getsigmask_np (const pthread_attr_t *__attr,
           __sigset_t *sigmask);







extern int pthread_setattr_default_np (const pthread_attr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int pthread_getattr_np (pthread_t __th, pthread_attr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));







extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      const struct sched_param *__param)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     __attribute__ ((__nothrow__ , __leaf__));




extern int pthread_getname_np (pthread_t __target_thread, char *__buf,
          size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int pthread_setname_np (pthread_t __target_thread, const char *__name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));





extern int pthread_getconcurrency (void) __attribute__ ((__nothrow__ , __leaf__));


extern int pthread_setconcurrency (int __level) __attribute__ ((__nothrow__ , __leaf__));



extern int pthread_yield (void) __attribute__ ((__nothrow__ , __leaf__));

extern int pthread_yield (void) __asm__ ("" "sched_yield") __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__deprecated__ ("pthread_yield is deprecated, use sched_yield instead")))
                                                      ;







extern int pthread_setaffinity_np (pthread_t __th, size_t __cpusetsize,
       const cpu_set_t *__cpuset)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));


extern int pthread_getaffinity_np (pthread_t __th, size_t __cpusetsize,
       cpu_set_t *__cpuset)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));
# 509 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
# 521 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




struct __cancel_jmp_buf_tag
{
  __jmp_buf __cancel_jmp_buf;
  int __mask_was_saved;
};

typedef struct
{
  struct __cancel_jmp_buf_tag __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
# 557 "/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};
# 697 "/usr/include/pthread.h" 3 4
extern void __pthread_register_cancel (__pthread_unwind_buf_t *__buf)
     ;
# 709 "/usr/include/pthread.h" 3 4
extern void __pthread_unregister_cancel (__pthread_unwind_buf_t *__buf)
  ;
# 732 "/usr/include/pthread.h" 3 4
extern void __pthread_register_cancel_defer (__pthread_unwind_buf_t *__buf)
     ;
# 745 "/usr/include/pthread.h" 3 4
extern void __pthread_unregister_cancel_restore (__pthread_unwind_buf_t *__buf)
  ;



extern void __pthread_unwind_next (__pthread_unwind_buf_t *__buf)
     __attribute__ ((__noreturn__))

     __attribute__ ((__weak__))

     ;
# 766 "/usr/include/pthread.h" 3 4
extern int __sigsetjmp_cancel (struct __cancel_jmp_buf_tag __env[1], int __savemask) __asm__ ("" "__sigsetjmp") __attribute__ ((__nothrow__))


                     __attribute__ ((__returns_twice__));
# 781 "/usr/include/pthread.h" 3 4
extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          const pthread_mutexattr_t *__mutexattr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));




extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        const struct timespec *__restrict
        __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
# 817 "/usr/include/pthread.h" 3 4
extern int pthread_mutex_clocklock (pthread_mutex_t *__restrict __mutex,
        clockid_t __clockid,
        const struct timespec *__restrict
        __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3)));
# 835 "/usr/include/pthread.h" 3 4
extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));




extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_consistent_np (pthread_mutex_t *) __asm__ ("" "pthread_mutex_consistent") __attribute__ ((__nothrow__ , __leaf__))
                                __attribute__ ((__nonnull__ (1)))
  __attribute__ ((__deprecated__ ("pthread_mutex_consistent_np is deprecated, use pthread_mutex_consistent")))
                                                                         ;
# 874 "/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getrobust (const pthread_mutexattr_t *__attr,
     int *__robustness)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_getrobust_np (pthread_mutexattr_t *, int *) __asm__ ("" "pthread_mutexattr_getrobust") __attribute__ ((__nothrow__ , __leaf__))

                                   __attribute__ ((__nonnull__ (1)))
  __attribute__ ((__deprecated__ ("pthread_mutexattr_getrobust_np is deprecated, use pthread_mutexattr_getrobust")))
                                                                               ;






extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_setrobust_np (pthread_mutexattr_t *, int) __asm__ ("" "pthread_mutexattr_setrobust") __attribute__ ((__nothrow__ , __leaf__))

                                   __attribute__ ((__nonnull__ (1)))
  __attribute__ ((__deprecated__ ("pthread_mutexattr_setrobust_np is deprecated, use pthread_mutexattr_setrobust")))
                                                                               ;
# 967 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    const pthread_rwlockattr_t *__restrict
    __attr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));




extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
# 1004 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_clockrdlock (pthread_rwlock_t *__restrict __rwlock,
           clockid_t __clockid,
           const struct timespec *__restrict
           __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3)));
# 1023 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));




extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));
# 1051 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_clockwrlock (pthread_rwlock_t *__restrict __rwlock,
           clockid_t __clockid,
           const struct timespec *__restrict
           __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3)));
# 1071 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         const pthread_condattr_t *__restrict __cond_attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
# 1145 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 3)));
# 1171 "/usr/include/pthread.h" 3 4
extern int pthread_cond_clockwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       __clockid_t __clock_id,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 4)));
# 1194 "/usr/include/pthread.h" 3 4
extern int pthread_condattr_init (pthread_condattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 1230 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 1297 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) __attribute__ ((__nothrow__ , __leaf__));


extern void *pthread_getspecific (pthread_key_t __key) __attribute__ ((__nothrow__ , __leaf__));


extern int pthread_setspecific (pthread_key_t __key,
    const void *__pointer)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__access__ (__none__, 2)));




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
# 1332 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) __attribute__ ((__nothrow__ , __leaf__));




extern __inline __attribute__ ((__gnu_inline__)) int
__attribute__ ((__nothrow__ , __leaf__)) pthread_equal (pthread_t __thread1, pthread_t __thread2)
{
  return __thread1 == __thread2;
}



# 53 "pigpio.c" 2

# 1 "/usr/include/aarch64-linux-gnu/sys/mman.h" 1 3 4
# 25 "/usr/include/aarch64-linux-gnu/sys/mman.h" 3 4
# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 26 "/usr/include/aarch64-linux-gnu/sys/mman.h" 2 3 4
# 41 "/usr/include/aarch64-linux-gnu/sys/mman.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/mman.h" 1 3 4
# 29 "/usr/include/aarch64-linux-gnu/bits/mman.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/mman-map-flags-generic.h" 1 3 4
# 30 "/usr/include/aarch64-linux-gnu/bits/mman.h" 2 3 4


# 1 "/usr/include/aarch64-linux-gnu/bits/mman-linux.h" 1 3 4
# 117 "/usr/include/aarch64-linux-gnu/bits/mman-linux.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/mman-shared.h" 1 3 4
# 47 "/usr/include/aarch64-linux-gnu/bits/mman-shared.h" 3 4




int memfd_create (const char *__name, unsigned int __flags) __attribute__ ((__nothrow__ , __leaf__));



int mlock2 (const void *__addr, size_t __length, unsigned int __flags) __attribute__ ((__nothrow__ , __leaf__));





int pkey_alloc (unsigned int __flags, unsigned int __access_rights) __attribute__ ((__nothrow__ , __leaf__));



int pkey_set (int __key, unsigned int __access_rights) __attribute__ ((__nothrow__ , __leaf__));



int pkey_get (int __key) __attribute__ ((__nothrow__ , __leaf__));



int pkey_free (int __key) __attribute__ ((__nothrow__ , __leaf__));



int pkey_mprotect (void *__addr, size_t __len, int __prot, int __pkey) __attribute__ ((__nothrow__ , __leaf__));


# 118 "/usr/include/aarch64-linux-gnu/bits/mman-linux.h" 2 3 4
# 33 "/usr/include/aarch64-linux-gnu/bits/mman.h" 2 3 4
# 42 "/usr/include/aarch64-linux-gnu/sys/mman.h" 2 3 4





# 57 "/usr/include/aarch64-linux-gnu/sys/mman.h" 3 4
extern void *mmap (void *__addr, size_t __len, int __prot,
     int __flags, int __fd, __off_t __offset) __attribute__ ((__nothrow__ , __leaf__));
# 70 "/usr/include/aarch64-linux-gnu/sys/mman.h" 3 4
extern void *mmap64 (void *__addr, size_t __len, int __prot,
       int __flags, int __fd, __off64_t __offset) __attribute__ ((__nothrow__ , __leaf__));




extern int munmap (void *__addr, size_t __len) __attribute__ ((__nothrow__ , __leaf__));




extern int mprotect (void *__addr, size_t __len, int __prot) __attribute__ ((__nothrow__ , __leaf__));







extern int msync (void *__addr, size_t __len, int __flags);




extern int madvise (void *__addr, size_t __len, int __advice) __attribute__ ((__nothrow__ , __leaf__));



extern int posix_madvise (void *__addr, size_t __len, int __advice) __attribute__ ((__nothrow__ , __leaf__));




extern int mlock (const void *__addr, size_t __len) __attribute__ ((__nothrow__ , __leaf__));


extern int munlock (const void *__addr, size_t __len) __attribute__ ((__nothrow__ , __leaf__));




extern int mlockall (int __flags) __attribute__ ((__nothrow__ , __leaf__));



extern int munlockall (void) __attribute__ ((__nothrow__ , __leaf__));







extern int mincore (void *__start, size_t __len, unsigned char *__vec)
     __attribute__ ((__nothrow__ , __leaf__));
# 133 "/usr/include/aarch64-linux-gnu/sys/mman.h" 3 4
extern void *mremap (void *__addr, size_t __old_len, size_t __new_len,
       int __flags, ...) __attribute__ ((__nothrow__ , __leaf__));



extern int remap_file_pages (void *__start, size_t __size, int __prot,
        size_t __pgoff, int __flags) __attribute__ ((__nothrow__ , __leaf__));




extern int shm_open (const char *__name, int __oflag, mode_t __mode);


extern int shm_unlink (const char *__name);


# 55 "pigpio.c" 2

# 1 "/usr/include/aarch64-linux-gnu/sys/stat.h" 1 3 4
# 99 "/usr/include/aarch64-linux-gnu/sys/stat.h" 3 4


# 1 "/usr/include/aarch64-linux-gnu/bits/stat.h" 1 3 4
# 102 "/usr/include/aarch64-linux-gnu/sys/stat.h" 2 3 4
# 205 "/usr/include/aarch64-linux-gnu/sys/stat.h" 3 4
extern int stat (const char *__restrict __file,
   struct stat *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int fstat (int __fd, struct stat *__buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
# 240 "/usr/include/aarch64-linux-gnu/sys/stat.h" 3 4
extern int stat64 (const char *__restrict __file,
     struct stat64 *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int fstat64 (int __fd, struct stat64 *__buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
# 264 "/usr/include/aarch64-linux-gnu/sys/stat.h" 3 4
extern int fstatat (int __fd, const char *__restrict __file,
      struct stat *__restrict __buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 291 "/usr/include/aarch64-linux-gnu/sys/stat.h" 3 4
extern int fstatat64 (int __fd, const char *__restrict __file,
        struct stat64 *__restrict __buf, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 313 "/usr/include/aarch64-linux-gnu/sys/stat.h" 3 4
extern int lstat (const char *__restrict __file,
    struct stat *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 338 "/usr/include/aarch64-linux-gnu/sys/stat.h" 3 4
extern int lstat64 (const char *__restrict __file,
      struct stat64 *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 352 "/usr/include/aarch64-linux-gnu/sys/stat.h" 3 4
extern int chmod (const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int lchmod (const char *__file, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




extern int fchmod (int __fd, __mode_t __mode) __attribute__ ((__nothrow__ , __leaf__));





extern int fchmodat (int __fd, const char *__file, __mode_t __mode,
       int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) __attribute__ ((__warn_unused_result__));






extern __mode_t umask (__mode_t __mask) __attribute__ ((__nothrow__ , __leaf__));




extern __mode_t getumask (void) __attribute__ ((__nothrow__ , __leaf__));



extern int mkdir (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int mkdirat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));






extern int mknod (const char *__path, __mode_t __mode, __dev_t __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int mknodat (int __fd, const char *__path, __mode_t __mode,
      __dev_t __dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));





extern int mkfifo (const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int mkfifoat (int __fd, const char *__path, __mode_t __mode)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));






extern int utimensat (int __fd, const char *__path,
        const struct timespec __times[2],
        int __flags)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
# 452 "/usr/include/aarch64-linux-gnu/sys/stat.h" 3 4
extern int futimens (int __fd, const struct timespec __times[2]) __attribute__ ((__nothrow__ , __leaf__));
# 465 "/usr/include/aarch64-linux-gnu/sys/stat.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/statx.h" 1 3 4
# 31 "/usr/include/aarch64-linux-gnu/bits/statx.h" 3 4
# 1 "/usr/include/linux/stat.h" 1 3 4
# 56 "/usr/include/linux/stat.h" 3 4
struct statx_timestamp {
 __s64 tv_sec;
 __u32 tv_nsec;
 __s32 __reserved;
};
# 99 "/usr/include/linux/stat.h" 3 4
struct statx {

 __u32 stx_mask;
 __u32 stx_blksize;
 __u64 stx_attributes;

 __u32 stx_nlink;
 __u32 stx_uid;
 __u32 stx_gid;
 __u16 stx_mode;
 __u16 __spare0[1];

 __u64 stx_ino;
 __u64 stx_size;
 __u64 stx_blocks;
 __u64 stx_attributes_mask;

 struct statx_timestamp stx_atime;
 struct statx_timestamp stx_btime;
 struct statx_timestamp stx_ctime;
 struct statx_timestamp stx_mtime;

 __u32 stx_rdev_major;
 __u32 stx_rdev_minor;
 __u32 stx_dev_major;
 __u32 stx_dev_minor;

 __u64 stx_mnt_id;
 __u64 __spare2;

 __u64 __spare3[12];

};
# 32 "/usr/include/aarch64-linux-gnu/bits/statx.h" 2 3 4







# 1 "/usr/include/aarch64-linux-gnu/bits/statx-generic.h" 1 3 4
# 25 "/usr/include/aarch64-linux-gnu/bits/statx-generic.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/types/struct_statx_timestamp.h" 1 3 4
# 26 "/usr/include/aarch64-linux-gnu/bits/statx-generic.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/types/struct_statx.h" 1 3 4
# 27 "/usr/include/aarch64-linux-gnu/bits/statx-generic.h" 2 3 4
# 57 "/usr/include/aarch64-linux-gnu/bits/statx-generic.h" 3 4



int statx (int __dirfd, const char *__restrict __path, int __flags,
           unsigned int __mask, struct statx *__restrict __buf)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 5)));


# 40 "/usr/include/aarch64-linux-gnu/bits/statx.h" 2 3 4
# 466 "/usr/include/aarch64-linux-gnu/sys/stat.h" 2 3 4



# 57 "pigpio.c" 2
# 1 "/usr/include/aarch64-linux-gnu/sys/file.h" 1 3 4
# 27 "/usr/include/aarch64-linux-gnu/sys/file.h" 3 4

# 50 "/usr/include/aarch64-linux-gnu/sys/file.h" 3 4
extern int flock (int __fd, int __operation) __attribute__ ((__nothrow__ , __leaf__));



# 58 "pigpio.c" 2
# 1 "/usr/include/aarch64-linux-gnu/sys/socket.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/sys/socket.h" 3 4




# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 29 "/usr/include/aarch64-linux-gnu/sys/socket.h" 2 3 4




# 1 "/usr/include/aarch64-linux-gnu/bits/socket.h" 1 3 4
# 27 "/usr/include/aarch64-linux-gnu/bits/socket.h" 3 4
# 1 "/usr/lib/gcc/aarch64-linux-gnu/11/include/stddef.h" 1 3 4
# 28 "/usr/include/aarch64-linux-gnu/bits/socket.h" 2 3 4
# 38 "/usr/include/aarch64-linux-gnu/bits/socket.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/socket_type.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/bits/socket_type.h" 3 4
enum __socket_type
{
  SOCK_STREAM = 1,


  SOCK_DGRAM = 2,


  SOCK_RAW = 3,

  SOCK_RDM = 4,

  SOCK_SEQPACKET = 5,


  SOCK_DCCP = 6,

  SOCK_PACKET = 10,







  SOCK_CLOEXEC = 02000000,


  SOCK_NONBLOCK = 00004000


};
# 39 "/usr/include/aarch64-linux-gnu/bits/socket.h" 2 3 4
# 177 "/usr/include/aarch64-linux-gnu/bits/socket.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/sockaddr.h" 1 3 4
# 28 "/usr/include/aarch64-linux-gnu/bits/sockaddr.h" 3 4
typedef unsigned short int sa_family_t;
# 178 "/usr/include/aarch64-linux-gnu/bits/socket.h" 2 3 4


struct sockaddr
  {
    sa_family_t sa_family;
    char sa_data[14];
  };
# 193 "/usr/include/aarch64-linux-gnu/bits/socket.h" 3 4
struct sockaddr_storage
  {
    sa_family_t ss_family;
    char __ss_padding[(128 - (sizeof (unsigned short int)) - sizeof (unsigned long int))];
    unsigned long int __ss_align;
  };



enum
  {
    MSG_OOB = 0x01,

    MSG_PEEK = 0x02,

    MSG_DONTROUTE = 0x04,



    MSG_TRYHARD = MSG_DONTROUTE,


    MSG_CTRUNC = 0x08,

    MSG_PROXY = 0x10,

    MSG_TRUNC = 0x20,

    MSG_DONTWAIT = 0x40,

    MSG_EOR = 0x80,

    MSG_WAITALL = 0x100,

    MSG_FIN = 0x200,

    MSG_SYN = 0x400,

    MSG_CONFIRM = 0x800,

    MSG_RST = 0x1000,

    MSG_ERRQUEUE = 0x2000,

    MSG_NOSIGNAL = 0x4000,

    MSG_MORE = 0x8000,

    MSG_WAITFORONE = 0x10000,

    MSG_BATCH = 0x40000,

    MSG_ZEROCOPY = 0x4000000,

    MSG_FASTOPEN = 0x20000000,


    MSG_CMSG_CLOEXEC = 0x40000000



  };




struct msghdr
  {
    void *msg_name;
    socklen_t msg_namelen;

    struct iovec *msg_iov;
    size_t msg_iovlen;

    void *msg_control;
    size_t msg_controllen;




    int msg_flags;
  };


struct cmsghdr
  {
    size_t cmsg_len;




    int cmsg_level;
    int cmsg_type;

    __extension__ unsigned char __cmsg_data [];

  };
# 307 "/usr/include/aarch64-linux-gnu/bits/socket.h" 3 4
extern struct cmsghdr *__cmsg_nxthdr (struct msghdr *__mhdr,
          struct cmsghdr *__cmsg) __attribute__ ((__nothrow__ , __leaf__));




extern __inline __attribute__ ((__gnu_inline__)) struct cmsghdr *
__attribute__ ((__nothrow__ , __leaf__)) __cmsg_nxthdr (struct msghdr *__mhdr, struct cmsghdr *__cmsg)
{
  if ((size_t) __cmsg->cmsg_len < sizeof (struct cmsghdr))

    return (struct cmsghdr *) 0;

  __cmsg = (struct cmsghdr *) ((unsigned char *) __cmsg
          + (((__cmsg->cmsg_len) + sizeof (size_t) - 1) & (size_t) ~(sizeof (size_t) - 1)));
  if ((unsigned char *) (__cmsg + 1) > ((unsigned char *) __mhdr->msg_control
     + __mhdr->msg_controllen)
      || ((unsigned char *) __cmsg + (((__cmsg->cmsg_len) + sizeof (size_t) - 1) & (size_t) ~(sizeof (size_t) - 1))
   > ((unsigned char *) __mhdr->msg_control + __mhdr->msg_controllen)))

    return (struct cmsghdr *) 0;
  return __cmsg;
}




enum
  {
    SCM_RIGHTS = 0x01


    , SCM_CREDENTIALS = 0x02


  };



struct ucred
{
  pid_t pid;
  uid_t uid;
  gid_t gid;
};




# 1 "/usr/include/aarch64-linux-gnu/asm/socket.h" 1 3 4
# 1 "/usr/include/asm-generic/socket.h" 1 3 4





# 1 "/usr/include/aarch64-linux-gnu/asm/sockios.h" 1 3 4
# 1 "/usr/include/asm-generic/sockios.h" 1 3 4
# 2 "/usr/include/aarch64-linux-gnu/asm/sockios.h" 2 3 4
# 7 "/usr/include/asm-generic/socket.h" 2 3 4
# 2 "/usr/include/aarch64-linux-gnu/asm/socket.h" 2 3 4
# 357 "/usr/include/aarch64-linux-gnu/bits/socket.h" 2 3 4






struct linger
  {
    int l_onoff;
    int l_linger;
  };
# 34 "/usr/include/aarch64-linux-gnu/sys/socket.h" 2 3 4


# 1 "/usr/include/aarch64-linux-gnu/bits/types/struct_osockaddr.h" 1 3 4





struct osockaddr
{
  unsigned short int sa_family;
  unsigned char sa_data[14];
};
# 37 "/usr/include/aarch64-linux-gnu/sys/socket.h" 2 3 4




enum
{
  SHUT_RD = 0,

  SHUT_WR,

  SHUT_RDWR

};
# 79 "/usr/include/aarch64-linux-gnu/sys/socket.h" 3 4
typedef union { struct sockaddr *__restrict __sockaddr__; struct sockaddr_at *__restrict __sockaddr_at__; struct sockaddr_ax25 *__restrict __sockaddr_ax25__; struct sockaddr_dl *__restrict __sockaddr_dl__; struct sockaddr_eon *__restrict __sockaddr_eon__; struct sockaddr_in *__restrict __sockaddr_in__; struct sockaddr_in6 *__restrict __sockaddr_in6__; struct sockaddr_inarp *__restrict __sockaddr_inarp__; struct sockaddr_ipx *__restrict __sockaddr_ipx__; struct sockaddr_iso *__restrict __sockaddr_iso__; struct sockaddr_ns *__restrict __sockaddr_ns__; struct sockaddr_un *__restrict __sockaddr_un__; struct sockaddr_x25 *__restrict __sockaddr_x25__;
       } __SOCKADDR_ARG __attribute__ ((__transparent_union__));


typedef union { const struct sockaddr *__restrict __sockaddr__; const struct sockaddr_at *__restrict __sockaddr_at__; const struct sockaddr_ax25 *__restrict __sockaddr_ax25__; const struct sockaddr_dl *__restrict __sockaddr_dl__; const struct sockaddr_eon *__restrict __sockaddr_eon__; const struct sockaddr_in *__restrict __sockaddr_in__; const struct sockaddr_in6 *__restrict __sockaddr_in6__; const struct sockaddr_inarp *__restrict __sockaddr_inarp__; const struct sockaddr_ipx *__restrict __sockaddr_ipx__; const struct sockaddr_iso *__restrict __sockaddr_iso__; const struct sockaddr_ns *__restrict __sockaddr_ns__; const struct sockaddr_un *__restrict __sockaddr_un__; const struct sockaddr_x25 *__restrict __sockaddr_x25__;
       } __CONST_SOCKADDR_ARG __attribute__ ((__transparent_union__));





struct mmsghdr
  {
    struct msghdr msg_hdr;
    unsigned int msg_len;

  };






extern int socket (int __domain, int __type, int __protocol) __attribute__ ((__nothrow__ , __leaf__));





extern int socketpair (int __domain, int __type, int __protocol,
         int __fds[2]) __attribute__ ((__nothrow__ , __leaf__));


extern int bind (int __fd, __CONST_SOCKADDR_ARG __addr, socklen_t __len)
     __attribute__ ((__nothrow__ , __leaf__));


extern int getsockname (int __fd, __SOCKADDR_ARG __addr,
   socklen_t *__restrict __len) __attribute__ ((__nothrow__ , __leaf__));
# 126 "/usr/include/aarch64-linux-gnu/sys/socket.h" 3 4
extern int connect (int __fd, __CONST_SOCKADDR_ARG __addr, socklen_t __len);



extern int getpeername (int __fd, __SOCKADDR_ARG __addr,
   socklen_t *__restrict __len) __attribute__ ((__nothrow__ , __leaf__));






extern ssize_t send (int __fd, const void *__buf, size_t __n, int __flags);






extern ssize_t recv (int __fd, void *__buf, size_t __n, int __flags);






extern ssize_t sendto (int __fd, const void *__buf, size_t __n,
         int __flags, __CONST_SOCKADDR_ARG __addr,
         socklen_t __addr_len);
# 163 "/usr/include/aarch64-linux-gnu/sys/socket.h" 3 4
extern ssize_t recvfrom (int __fd, void *__restrict __buf, size_t __n,
    int __flags, __SOCKADDR_ARG __addr,
    socklen_t *__restrict __addr_len);
# 174 "/usr/include/aarch64-linux-gnu/sys/socket.h" 3 4
extern ssize_t sendmsg (int __fd, const struct msghdr *__message,
   int __flags);
# 195 "/usr/include/aarch64-linux-gnu/sys/socket.h" 3 4
extern int sendmmsg (int __fd, struct mmsghdr *__vmessages,
       unsigned int __vlen, int __flags);
# 216 "/usr/include/aarch64-linux-gnu/sys/socket.h" 3 4
extern ssize_t recvmsg (int __fd, struct msghdr *__message, int __flags);
# 235 "/usr/include/aarch64-linux-gnu/sys/socket.h" 3 4
extern int recvmmsg (int __fd, struct mmsghdr *__vmessages,
       unsigned int __vlen, int __flags,
       struct timespec *__tmo);
# 255 "/usr/include/aarch64-linux-gnu/sys/socket.h" 3 4
extern int getsockopt (int __fd, int __level, int __optname,
         void *__restrict __optval,
         socklen_t *__restrict __optlen) __attribute__ ((__nothrow__ , __leaf__));
# 277 "/usr/include/aarch64-linux-gnu/sys/socket.h" 3 4
extern int setsockopt (int __fd, int __level, int __optname,
         const void *__optval, socklen_t __optlen) __attribute__ ((__nothrow__ , __leaf__));
# 296 "/usr/include/aarch64-linux-gnu/sys/socket.h" 3 4
extern int listen (int __fd, int __n) __attribute__ ((__nothrow__ , __leaf__));
# 306 "/usr/include/aarch64-linux-gnu/sys/socket.h" 3 4
extern int accept (int __fd, __SOCKADDR_ARG __addr,
     socklen_t *__restrict __addr_len);






extern int accept4 (int __fd, __SOCKADDR_ARG __addr,
      socklen_t *__restrict __addr_len, int __flags);
# 324 "/usr/include/aarch64-linux-gnu/sys/socket.h" 3 4
extern int shutdown (int __fd, int __how) __attribute__ ((__nothrow__ , __leaf__));




extern int sockatmark (int __fd) __attribute__ ((__nothrow__ , __leaf__));







extern int isfdtype (int __fd, int __fdtype) __attribute__ ((__nothrow__ , __leaf__));





# 1 "/usr/include/aarch64-linux-gnu/bits/socket2.h" 1 3 4
# 23 "/usr/include/aarch64-linux-gnu/bits/socket2.h" 3 4
extern ssize_t __recv_chk (int __fd, void *__buf, size_t __n, size_t __buflen,
      int __flags);
extern ssize_t __recv_alias (int __fd, void *__buf, size_t __n, int __flags) __asm__ ("" "recv")
                          ;
extern ssize_t __recv_chk_warn (int __fd, void *__buf, size_t __n, size_t __buflen, int __flags) __asm__ ("" "__recv_chk")


     __attribute__((__warning__ ("recv called with bigger length than size of destination " "buffer")))
            ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) ssize_t
recv (int __fd, void *__buf, size_t __n, int __flags)
{
  size_t sz = __builtin_object_size (__buf, 0);
  if ((((__typeof (__n)) 0 < (__typeof (__n)) -1 || (__builtin_constant_p (__n) && (__n) > 0)) && __builtin_constant_p ((((long unsigned int) (__n)) <= (sz) / (sizeof (char)))) && (((long unsigned int) (__n)) <= (sz) / (sizeof (char)))))
    return __recv_alias (__fd, __buf, __n, __flags);
  if ((((__typeof (__n)) 0 < (__typeof (__n)) -1 || (__builtin_constant_p (__n) && (__n) > 0)) && __builtin_constant_p ((((long unsigned int) (__n)) <= (sz) / (sizeof (char)))) && !(((long unsigned int) (__n)) <= (sz) / (sizeof (char)))))
    return __recv_chk_warn (__fd, __buf, __n, sz, __flags);
  return __recv_chk (__fd, __buf, __n, sz, __flags);
}

extern ssize_t __recvfrom_chk (int __fd, void *__restrict __buf, size_t __n,
          size_t __buflen, int __flags,
          __SOCKADDR_ARG __addr,
          socklen_t *__restrict __addr_len);
extern ssize_t __recvfrom_alias (int __fd, void *__restrict __buf, size_t __n, int __flags, __SOCKADDR_ARG __addr, socklen_t *__restrict __addr_len) __asm__ ("" "recvfrom")


                                                   ;
extern ssize_t __recvfrom_chk_warn (int __fd, void *__restrict __buf, size_t __n, size_t __buflen, int __flags, __SOCKADDR_ARG __addr, socklen_t *__restrict __addr_len) __asm__ ("" "__recvfrom_chk")




     __attribute__((__warning__ ("recvfrom called with bigger length than size of " "destination buffer")))
                        ;

extern __inline __attribute__ ((__always_inline__)) __attribute__ ((__gnu_inline__)) __attribute__ ((__artificial__)) ssize_t
recvfrom (int __fd, void *__restrict __buf, size_t __n, int __flags,
   __SOCKADDR_ARG __addr, socklen_t *__restrict __addr_len)
{
  size_t sz = __builtin_object_size (__buf, 0);
  if ((((__typeof (__n)) 0 < (__typeof (__n)) -1 || (__builtin_constant_p (__n) && (__n) > 0)) && __builtin_constant_p ((((long unsigned int) (__n)) <= (sz) / (sizeof (char)))) && (((long unsigned int) (__n)) <= (sz) / (sizeof (char)))))
    return __recvfrom_alias (__fd, __buf, __n, __flags, __addr, __addr_len);
  if ((((__typeof (__n)) 0 < (__typeof (__n)) -1 || (__builtin_constant_p (__n) && (__n) > 0)) && __builtin_constant_p ((((long unsigned int) (__n)) <= (sz) / (sizeof (char)))) && !(((long unsigned int) (__n)) <= (sz) / (sizeof (char)))))
    return __recvfrom_chk_warn (__fd, __buf, __n, sz, __flags, __addr,
    __addr_len);
  return __recvfrom_chk (__fd, __buf, __n, sz, __flags, __addr, __addr_len);
}
# 344 "/usr/include/aarch64-linux-gnu/sys/socket.h" 2 3 4



# 59 "pigpio.c" 2
# 1 "/usr/include/aarch64-linux-gnu/sys/sysmacros.h" 1 3 4
# 24 "/usr/include/aarch64-linux-gnu/sys/sysmacros.h" 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/sysmacros.h" 1 3 4
# 25 "/usr/include/aarch64-linux-gnu/sys/sysmacros.h" 2 3 4
# 33 "/usr/include/aarch64-linux-gnu/sys/sysmacros.h" 3 4


extern unsigned int gnu_dev_major (__dev_t __dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern unsigned int gnu_dev_minor (__dev_t __dev) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern __dev_t gnu_dev_makedev (unsigned int __major, unsigned int __minor) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));



__extension__ extern __inline __attribute__ ((__gnu_inline__)) __attribute__ ((__const__)) unsigned int __attribute__ ((__nothrow__ , __leaf__)) gnu_dev_major (__dev_t __dev) { unsigned int __major; __major = ((__dev & (__dev_t) 0x00000000000fff00u) >> 8); __major |= ((__dev & (__dev_t) 0xfffff00000000000u) >> 32); return __major; }
__extension__ extern __inline __attribute__ ((__gnu_inline__)) __attribute__ ((__const__)) unsigned int __attribute__ ((__nothrow__ , __leaf__)) gnu_dev_minor (__dev_t __dev) { unsigned int __minor; __minor = ((__dev & (__dev_t) 0x00000000000000ffu) >> 0); __minor |= ((__dev & (__dev_t) 0x00000ffffff00000u) >> 12); return __minor; }
__extension__ extern __inline __attribute__ ((__gnu_inline__)) __attribute__ ((__const__)) __dev_t __attribute__ ((__nothrow__ , __leaf__)) gnu_dev_makedev (unsigned int __major, unsigned int __minor) { __dev_t __dev; __dev = (((__dev_t) (__major & 0x00000fffu)) << 8); __dev |= (((__dev_t) (__major & 0xfffff000u)) << 32); __dev |= (((__dev_t) (__minor & 0x000000ffu)) << 0); __dev |= (((__dev_t) (__minor & 0xffffff00u)) << 12); return __dev; }




# 60 "pigpio.c" 2
# 1 "/usr/include/netinet/tcp.h" 1 3 4
# 93 "/usr/include/netinet/tcp.h" 3 4
typedef uint32_t tcp_seq;




struct tcphdr
  {
    __extension__ union
    {
      struct
      {
 uint16_t th_sport;
 uint16_t th_dport;
 tcp_seq th_seq;
 tcp_seq th_ack;

 uint8_t th_x2:4;
 uint8_t th_off:4;





 uint8_t th_flags;






 uint16_t th_win;
 uint16_t th_sum;
 uint16_t th_urp;
      };
      struct
      {
 uint16_t source;
 uint16_t dest;
 uint32_t seq;
 uint32_t ack_seq;

 uint16_t res1:4;
 uint16_t doff:4;
 uint16_t fin:1;
 uint16_t syn:1;
 uint16_t rst:1;
 uint16_t psh:1;
 uint16_t ack:1;
 uint16_t urg:1;
 uint16_t res2:2;
# 156 "/usr/include/netinet/tcp.h" 3 4
 uint16_t window;
 uint16_t check;
 uint16_t urg_ptr;
      };
    };
};

enum
{
  TCP_ESTABLISHED = 1,
  TCP_SYN_SENT,
  TCP_SYN_RECV,
  TCP_FIN_WAIT1,
  TCP_FIN_WAIT2,
  TCP_TIME_WAIT,
  TCP_CLOSE,
  TCP_CLOSE_WAIT,
  TCP_LAST_ACK,
  TCP_LISTEN,
  TCP_CLOSING
};
# 217 "/usr/include/netinet/tcp.h" 3 4
enum tcp_ca_state
{
  TCP_CA_Open = 0,
  TCP_CA_Disorder = 1,
  TCP_CA_CWR = 2,
  TCP_CA_Recovery = 3,
  TCP_CA_Loss = 4
};

struct tcp_info
{
  uint8_t tcpi_state;
  uint8_t tcpi_ca_state;
  uint8_t tcpi_retransmits;
  uint8_t tcpi_probes;
  uint8_t tcpi_backoff;
  uint8_t tcpi_options;
  uint8_t tcpi_snd_wscale : 4, tcpi_rcv_wscale : 4;

  uint32_t tcpi_rto;
  uint32_t tcpi_ato;
  uint32_t tcpi_snd_mss;
  uint32_t tcpi_rcv_mss;

  uint32_t tcpi_unacked;
  uint32_t tcpi_sacked;
  uint32_t tcpi_lost;
  uint32_t tcpi_retrans;
  uint32_t tcpi_fackets;


  uint32_t tcpi_last_data_sent;
  uint32_t tcpi_last_ack_sent;
  uint32_t tcpi_last_data_recv;
  uint32_t tcpi_last_ack_recv;


  uint32_t tcpi_pmtu;
  uint32_t tcpi_rcv_ssthresh;
  uint32_t tcpi_rtt;
  uint32_t tcpi_rttvar;
  uint32_t tcpi_snd_ssthresh;
  uint32_t tcpi_snd_cwnd;
  uint32_t tcpi_advmss;
  uint32_t tcpi_reordering;

  uint32_t tcpi_rcv_rtt;
  uint32_t tcpi_rcv_space;

  uint32_t tcpi_total_retrans;
};
# 276 "/usr/include/netinet/tcp.h" 3 4
struct tcp_md5sig
{
  struct sockaddr_storage tcpm_addr;
  uint8_t tcpm_flags;
  uint8_t tcpm_prefixlen;
  uint16_t tcpm_keylen;
  uint32_t __tcpm_pad;
  uint8_t tcpm_key[80];
};


struct tcp_repair_opt
{
  uint32_t opt_code;
  uint32_t opt_val;
};


enum
{
  TCP_NO_QUEUE,
  TCP_RECV_QUEUE,
  TCP_SEND_QUEUE,
  TCP_QUEUES_NR,
};
# 319 "/usr/include/netinet/tcp.h" 3 4
struct tcp_cookie_transactions
{
  uint16_t tcpct_flags;
  uint8_t __tcpct_pad1;
  uint8_t tcpct_cookie_desired;
  uint16_t tcpct_s_data_desired;
  uint16_t tcpct_used;
  uint8_t tcpct_value[536U];
};


struct tcp_repair_window
{
  uint32_t snd_wl1;
  uint32_t snd_wnd;
  uint32_t max_window;
  uint32_t rcv_wnd;
  uint32_t rcv_wup;
};


struct tcp_zerocopy_receive
{
  uint64_t address;
  uint32_t length;
  uint32_t recv_skip_hint;
};
# 61 "pigpio.c" 2
# 1 "/usr/include/arpa/inet.h" 1 3 4
# 22 "/usr/include/arpa/inet.h" 3 4
# 1 "/usr/include/netinet/in.h" 1 3 4
# 27 "/usr/include/netinet/in.h" 3 4



typedef uint32_t in_addr_t;
struct in_addr
  {
    in_addr_t s_addr;
  };


# 1 "/usr/include/aarch64-linux-gnu/bits/in.h" 1 3 4
# 143 "/usr/include/aarch64-linux-gnu/bits/in.h" 3 4
struct ip_opts
  {
    struct in_addr ip_dst;
    char ip_opts[40];
  };


struct ip_mreqn
  {
    struct in_addr imr_multiaddr;
    struct in_addr imr_address;
    int imr_ifindex;
  };


struct in_pktinfo
  {
    int ipi_ifindex;
    struct in_addr ipi_spec_dst;
    struct in_addr ipi_addr;
  };
# 38 "/usr/include/netinet/in.h" 2 3 4


enum
  {
    IPPROTO_IP = 0,

    IPPROTO_ICMP = 1,

    IPPROTO_IGMP = 2,

    IPPROTO_IPIP = 4,

    IPPROTO_TCP = 6,

    IPPROTO_EGP = 8,

    IPPROTO_PUP = 12,

    IPPROTO_UDP = 17,

    IPPROTO_IDP = 22,

    IPPROTO_TP = 29,

    IPPROTO_DCCP = 33,

    IPPROTO_IPV6 = 41,

    IPPROTO_RSVP = 46,

    IPPROTO_GRE = 47,

    IPPROTO_ESP = 50,

    IPPROTO_AH = 51,

    IPPROTO_MTP = 92,

    IPPROTO_BEETPH = 94,

    IPPROTO_ENCAP = 98,

    IPPROTO_PIM = 103,

    IPPROTO_COMP = 108,

    IPPROTO_SCTP = 132,

    IPPROTO_UDPLITE = 136,

    IPPROTO_MPLS = 137,

    IPPROTO_ETHERNET = 143,

    IPPROTO_RAW = 255,

    IPPROTO_MPTCP = 262,

    IPPROTO_MAX
  };





enum
  {
    IPPROTO_HOPOPTS = 0,

    IPPROTO_ROUTING = 43,

    IPPROTO_FRAGMENT = 44,

    IPPROTO_ICMPV6 = 58,

    IPPROTO_NONE = 59,

    IPPROTO_DSTOPTS = 60,

    IPPROTO_MH = 135

  };



typedef uint16_t in_port_t;


enum
  {
    IPPORT_ECHO = 7,
    IPPORT_DISCARD = 9,
    IPPORT_SYSTAT = 11,
    IPPORT_DAYTIME = 13,
    IPPORT_NETSTAT = 15,
    IPPORT_FTP = 21,
    IPPORT_TELNET = 23,
    IPPORT_SMTP = 25,
    IPPORT_TIMESERVER = 37,
    IPPORT_NAMESERVER = 42,
    IPPORT_WHOIS = 43,
    IPPORT_MTP = 57,

    IPPORT_TFTP = 69,
    IPPORT_RJE = 77,
    IPPORT_FINGER = 79,
    IPPORT_TTYLINK = 87,
    IPPORT_SUPDUP = 95,


    IPPORT_EXECSERVER = 512,
    IPPORT_LOGINSERVER = 513,
    IPPORT_CMDSERVER = 514,
    IPPORT_EFSSERVER = 520,


    IPPORT_BIFFUDP = 512,
    IPPORT_WHOSERVER = 513,
    IPPORT_ROUTESERVER = 520,


    IPPORT_RESERVED = 1024,


    IPPORT_USERRESERVED = 5000
  };
# 219 "/usr/include/netinet/in.h" 3 4
struct in6_addr
  {
    union
      {
 uint8_t __u6_addr8[16];
 uint16_t __u6_addr16[8];
 uint32_t __u6_addr32[4];
      } __in6_u;





  };


extern const struct in6_addr in6addr_any;
extern const struct in6_addr in6addr_loopback;
# 245 "/usr/include/netinet/in.h" 3 4
struct sockaddr_in
  {
    sa_family_t sin_family;
    in_port_t sin_port;
    struct in_addr sin_addr;


    unsigned char sin_zero[sizeof (struct sockaddr)
      - (sizeof (unsigned short int))
      - sizeof (in_port_t)
      - sizeof (struct in_addr)];
  };



struct sockaddr_in6
  {
    sa_family_t sin6_family;
    in_port_t sin6_port;
    uint32_t sin6_flowinfo;
    struct in6_addr sin6_addr;
    uint32_t sin6_scope_id;
  };




struct ip_mreq
  {

    struct in_addr imr_multiaddr;


    struct in_addr imr_interface;
  };

struct ip_mreq_source
  {

    struct in_addr imr_multiaddr;


    struct in_addr imr_interface;


    struct in_addr imr_sourceaddr;
  };




struct ipv6_mreq
  {

    struct in6_addr ipv6mr_multiaddr;


    unsigned int ipv6mr_interface;
  };




struct group_req
  {

    uint32_t gr_interface;


    struct sockaddr_storage gr_group;
  };

struct group_source_req
  {

    uint32_t gsr_interface;


    struct sockaddr_storage gsr_group;


    struct sockaddr_storage gsr_source;
  };



struct ip_msfilter
  {

    struct in_addr imsf_multiaddr;


    struct in_addr imsf_interface;


    uint32_t imsf_fmode;


    uint32_t imsf_numsrc;

    struct in_addr imsf_slist[1];
  };





struct group_filter
  {

    uint32_t gf_interface;


    struct sockaddr_storage gf_group;


    uint32_t gf_fmode;


    uint32_t gf_numsrc;

    struct sockaddr_storage gf_slist[1];
};
# 382 "/usr/include/netinet/in.h" 3 4
extern uint32_t ntohl (uint32_t __netlong) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern uint16_t ntohs (uint16_t __netshort)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern uint32_t htonl (uint32_t __hostlong)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern uint16_t htons (uint16_t __hostshort)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




# 1 "/usr/include/aarch64-linux-gnu/bits/byteswap.h" 1 3 4
# 394 "/usr/include/netinet/in.h" 2 3 4
# 1 "/usr/include/aarch64-linux-gnu/bits/uintn-identity.h" 1 3 4
# 395 "/usr/include/netinet/in.h" 2 3 4
# 510 "/usr/include/netinet/in.h" 3 4
extern int bindresvport (int __sockfd, struct sockaddr_in *__sock_in) __attribute__ ((__nothrow__ , __leaf__));


extern int bindresvport6 (int __sockfd, struct sockaddr_in6 *__sock_in)
     __attribute__ ((__nothrow__ , __leaf__));
# 540 "/usr/include/netinet/in.h" 3 4
struct cmsghdr;



struct in6_pktinfo
  {
    struct in6_addr ipi6_addr;
    unsigned int ipi6_ifindex;
  };


struct ip6_mtuinfo
  {
    struct sockaddr_in6 ip6m_addr;
    uint32_t ip6m_mtu;
  };



extern int inet6_option_space (int __nbytes)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
extern int inet6_option_init (void *__bp, struct cmsghdr **__cmsgp,
         int __type) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
extern int inet6_option_append (struct cmsghdr *__cmsg,
    const uint8_t *__typep, int __multx,
    int __plusy) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
extern uint8_t *inet6_option_alloc (struct cmsghdr *__cmsg, int __datalen,
        int __multx, int __plusy)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
extern int inet6_option_next (const struct cmsghdr *__cmsg,
         uint8_t **__tptrp)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
extern int inet6_option_find (const struct cmsghdr *__cmsg,
         uint8_t **__tptrp, int __type)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));



extern int inet6_opt_init (void *__extbuf, socklen_t __extlen) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_append (void *__extbuf, socklen_t __extlen, int __offset,
        uint8_t __type, socklen_t __len, uint8_t __align,
        void **__databufp) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_finish (void *__extbuf, socklen_t __extlen, int __offset)
     __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_set_val (void *__databuf, int __offset, void *__val,
         socklen_t __vallen) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_next (void *__extbuf, socklen_t __extlen, int __offset,
      uint8_t *__typep, socklen_t *__lenp,
      void **__databufp) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_find (void *__extbuf, socklen_t __extlen, int __offset,
      uint8_t __type, socklen_t *__lenp,
      void **__databufp) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_opt_get_val (void *__databuf, int __offset, void *__val,
         socklen_t __vallen) __attribute__ ((__nothrow__ , __leaf__));



extern socklen_t inet6_rth_space (int __type, int __segments) __attribute__ ((__nothrow__ , __leaf__));
extern void *inet6_rth_init (void *__bp, socklen_t __bp_len, int __type,
        int __segments) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_rth_add (void *__bp, const struct in6_addr *__addr) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_rth_reverse (const void *__in, void *__out) __attribute__ ((__nothrow__ , __leaf__));
extern int inet6_rth_segments (const void *__bp) __attribute__ ((__nothrow__ , __leaf__));
extern struct in6_addr *inet6_rth_getaddr (const void *__bp, int __index)
     __attribute__ ((__nothrow__ , __leaf__));





extern int getipv4sourcefilter (int __s, struct in_addr __interface_addr,
    struct in_addr __group, uint32_t *__fmode,
    uint32_t *__numsrc, struct in_addr *__slist)
     __attribute__ ((__nothrow__ , __leaf__));


extern int setipv4sourcefilter (int __s, struct in_addr __interface_addr,
    struct in_addr __group, uint32_t __fmode,
    uint32_t __numsrc,
    const struct in_addr *__slist)
     __attribute__ ((__nothrow__ , __leaf__));



extern int getsourcefilter (int __s, uint32_t __interface_addr,
       const struct sockaddr *__group,
       socklen_t __grouplen, uint32_t *__fmode,
       uint32_t *__numsrc,
       struct sockaddr_storage *__slist) __attribute__ ((__nothrow__ , __leaf__));


extern int setsourcefilter (int __s, uint32_t __interface_addr,
       const struct sockaddr *__group,
       socklen_t __grouplen, uint32_t __fmode,
       uint32_t __numsrc,
       const struct sockaddr_storage *__slist) __attribute__ ((__nothrow__ , __leaf__));



# 23 "/usr/include/arpa/inet.h" 2 3 4











extern in_addr_t inet_addr (const char *__cp) __attribute__ ((__nothrow__ , __leaf__));


extern in_addr_t inet_lnaof (struct in_addr __in) __attribute__ ((__nothrow__ , __leaf__));



extern struct in_addr inet_makeaddr (in_addr_t __net, in_addr_t __host)
     __attribute__ ((__nothrow__ , __leaf__));


extern in_addr_t inet_netof (struct in_addr __in) __attribute__ ((__nothrow__ , __leaf__));



extern in_addr_t inet_network (const char *__cp) __attribute__ ((__nothrow__ , __leaf__));



extern char *inet_ntoa (struct in_addr __in) __attribute__ ((__nothrow__ , __leaf__));




extern int inet_pton (int __af, const char *__restrict __cp,
        void *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));




extern const char *inet_ntop (int __af, const void *__restrict __cp,
         char *__restrict __buf, socklen_t __len)
     __attribute__ ((__nothrow__ , __leaf__));






extern int inet_aton (const char *__cp, struct in_addr *__inp) __attribute__ ((__nothrow__ , __leaf__));



extern char *inet_neta (in_addr_t __net, char *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__))
  __attribute__ ((__deprecated__ ("Use inet_ntop instead")));




extern char *inet_net_ntop (int __af, const void *__cp, int __bits,
       char *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__));




extern int inet_net_pton (int __af, const char *__cp,
     void *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__));




extern unsigned int inet_nsap_addr (const char *__cp,
        unsigned char *__buf, int __len) __attribute__ ((__nothrow__ , __leaf__));



extern char *inet_nsap_ntoa (int __len, const unsigned char *__cp,
        char *__buf) __attribute__ ((__nothrow__ , __leaf__));



# 62 "pigpio.c" 2

# 1 "/usr/include/fnmatch.h" 1 3 4
# 56 "/usr/include/fnmatch.h" 3 4
extern int fnmatch (const char *__pattern, const char *__name, int __flags);
# 64 "pigpio.c" 2
# 1 "/usr/include/glob.h" 1 3 4
# 23 "/usr/include/glob.h" 3 4

# 80 "/usr/include/glob.h" 3 4
struct stat;

typedef struct
  {
    size_t gl_pathc;
    char **gl_pathv;
    size_t gl_offs;
    int gl_flags;



    void (*gl_closedir) (void *);

    struct dirent *(*gl_readdir) (void *);



    void *(*gl_opendir) (const char *);

    int (*gl_lstat) (const char *__restrict, struct stat *__restrict);
    int (*gl_stat) (const char *__restrict, struct stat *__restrict);




  } glob_t;



struct stat64;

typedef struct
  {
    size_t gl_pathc;
    char **gl_pathv;
    size_t gl_offs;
    int gl_flags;



    void (*gl_closedir) (void *);

    struct dirent64 *(*gl_readdir) (void *);



    void *(*gl_opendir) (const char *);

    int (*gl_lstat) (const char *__restrict, struct stat64 *__restrict);
    int (*gl_stat) (const char *__restrict, struct stat64 *__restrict);




  } glob64_t;
# 146 "/usr/include/glob.h" 3 4
extern int glob (const char *__restrict __pattern, int __flags,
   int (*__errfunc) (const char *, int),
   glob_t *__restrict __pglob) __attribute__ ((__nothrow__));


extern void globfree (glob_t *__pglob) __attribute__ ((__nothrow__ , __leaf__));
# 183 "/usr/include/glob.h" 3 4
extern int glob64 (const char *__restrict __pattern, int __flags,
     int (*__errfunc) (const char *, int),
     glob64_t *__restrict __pglob) __attribute__ ((__nothrow__));

extern void globfree64 (glob64_t *__pglob) __attribute__ ((__nothrow__ , __leaf__));
# 198 "/usr/include/glob.h" 3 4
extern int glob_pattern_p (const char *__pattern, int __quote) __attribute__ ((__nothrow__ , __leaf__));



# 65 "pigpio.c" 2


# 1 "pigpio.h" 1
# 416 "pigpio.h"

# 416 "pigpio.h"
typedef struct
{
   uint16_t func;
   uint16_t size;
} gpioHeader_t;

typedef struct
{
   size_t size;
   void *ptr;
   uint32_t data;
} gpioExtent_t;

typedef struct
{
   uint32_t tick;
   uint32_t level;
} gpioSample_t;

typedef struct
{
   uint16_t seqno;
   uint16_t flags;
   uint32_t tick;
   uint32_t level;
} gpioReport_t;

typedef struct
{
   uint32_t gpioOn;
   uint32_t gpioOff;
   uint32_t usDelay;
} gpioPulse_t;




typedef struct
{
   uint32_t gpioOn;
   uint32_t gpioOff;
   uint32_t usDelay;
   uint32_t flags;
} rawWave_t;
# 474 "pigpio.h"
typedef struct
{
   uint16_t botCB;
   uint16_t topCB;
   uint16_t botOOL;

   uint16_t topOOL;

   uint16_t deleted;
   uint16_t numCB;
   uint16_t numBOOL;
   uint16_t numTOOL;
} rawWaveInfo_t;

typedef struct
{
   int clk;
   int mosi;
   int miso;
   int ss_pol;
   int ss_us;
   int clk_pol;
   int clk_pha;
   int clk_us;
} rawSPI_t;

typedef struct {
   uint32_t info;
   uint32_t src;
   uint32_t dst;
   uint32_t length;
   uint32_t stride;
   uint32_t next;
   uint32_t pad[2];
} rawCbs_t;

typedef struct
{
   uint16_t addr;
   uint16_t flags;
   uint16_t len;
   uint8_t *buf;
} pi_i2c_msg_t;





typedef struct
{
   uint32_t control;
   int rxCnt;
   char rxBuf[512];
   int txCnt;
   char txBuf[512];
} bsc_xfer_t;


typedef void (*gpioAlertFunc_t) (int gpio,
                                    int level,
                                    uint32_t tick);

typedef void (*gpioAlertFuncEx_t) (int gpio,
                                    int level,
                                    uint32_t tick,
                                    void *userdata);

typedef void (*eventFunc_t) (int event,
                                    uint32_t tick);

typedef void (*eventFuncEx_t) (int event,
                                    uint32_t tick,
                                    void *userdata);

typedef void (*gpioISRFunc_t) (int gpio,
                                    int level,
                                    uint32_t tick);

typedef void (*gpioISRFuncEx_t) (int gpio,
                                    int level,
                                    uint32_t tick,
                                    void *userdata);

typedef void (*gpioTimerFunc_t) (void);

typedef void (*gpioTimerFuncEx_t) (void *userdata);

typedef void (*gpioSignalFunc_t) (int signum);

typedef void (*gpioSignalFuncEx_t) (int signum,
                                    void *userdata);

typedef void (*gpioGetSamplesFunc_t) (const gpioSample_t *samples,
                                        int numSamples);

typedef void (*gpioGetSamplesFuncEx_t) (const gpioSample_t *samples,
                                        int numSamples,
                                        void *userdata);

typedef void *(gpioThreadFunc_t) (void *);
# 946 "pigpio.h"
int gpioInitialise(void);
# 975 "pigpio.h"
void gpioTerminate(void);
# 993 "pigpio.h"
int gpioSetMode(unsigned gpio, unsigned mode);
# 1019 "pigpio.h"
int gpioGetMode(unsigned gpio);
# 1039 "pigpio.h"
int gpioSetPullUpDown(unsigned gpio, unsigned pud);
# 1061 "pigpio.h"
int gpioRead (unsigned gpio);
# 1080 "pigpio.h"
int gpioWrite(unsigned gpio, unsigned level);
# 1102 "pigpio.h"
int gpioPWM(unsigned user_gpio, unsigned dutycycle);
# 1133 "pigpio.h"
int gpioGetPWMdutycycle(unsigned user_gpio);
# 1158 "pigpio.h"
int gpioSetPWMrange(unsigned user_gpio, unsigned range);
# 1193 "pigpio.h"
int gpioGetPWMrange(unsigned user_gpio);
# 1212 "pigpio.h"
int gpioGetPWMrealRange(unsigned user_gpio);
# 1234 "pigpio.h"
int gpioSetPWMfrequency(unsigned user_gpio, unsigned frequency);
# 1291 "pigpio.h"
int gpioGetPWMfrequency(unsigned user_gpio);
# 1316 "pigpio.h"
int gpioServo(unsigned user_gpio, unsigned pulsewidth);
# 1375 "pigpio.h"
int gpioGetServoPulsewidth(unsigned user_gpio);
# 1389 "pigpio.h"
int gpioSetAlertFunc(unsigned user_gpio, gpioAlertFunc_t f);
# 1470 "pigpio.h"
int gpioSetAlertFuncEx(
   unsigned user_gpio, gpioAlertFuncEx_t f, void *userdata);
# 1513 "pigpio.h"
int gpioSetISRFunc(
   unsigned gpio, unsigned edge, int timeout, gpioISRFunc_t f);
# 1578 "pigpio.h"
int gpioSetISRFuncEx(
   unsigned gpio,
   unsigned edge,
   int timeout,
   gpioISRFuncEx_t f,
   void *userdata);
# 1626 "pigpio.h"
int gpioNotifyOpen(void);
# 1671 "pigpio.h"
int gpioNotifyOpenWithSize(int bufSize);
# 1683 "pigpio.h"
int gpioNotifyBegin(unsigned handle, uint32_t bits);
# 1745 "pigpio.h"
int gpioNotifyPause(unsigned handle);
# 1765 "pigpio.h"
int gpioNotifyClose(unsigned handle);
# 1783 "pigpio.h"
int gpioWaveClear(void);
# 1797 "pigpio.h"
int gpioWaveAddNew(void);
# 1813 "pigpio.h"
int gpioWaveAddGeneric(unsigned numPulses, gpioPulse_t *pulses);
# 1872 "pigpio.h"
int gpioWaveAddSerial
   (unsigned user_gpio,
    unsigned baud,
    unsigned data_bits,
    unsigned stop_bits,
    unsigned offset,
    unsigned numBytes,
    char *str);
# 1936 "pigpio.h"
int gpioWaveCreate(void);
# 1991 "pigpio.h"
int gpioWaveDelete(unsigned wave_id);
# 2015 "pigpio.h"
int gpioWaveTxSend(unsigned wave_id, unsigned wave_mode);
# 2039 "pigpio.h"
int gpioWaveChain(char *buf, unsigned bufSize);
# 2137 "pigpio.h"
int gpioWaveTxAt(void);
# 2150 "pigpio.h"
int gpioWaveTxBusy(void);
# 2160 "pigpio.h"
int gpioWaveTxStop(void);
# 2171 "pigpio.h"
int gpioWaveGetMicros(void);







int gpioWaveGetHighMicros(void);







int gpioWaveGetMaxMicros(void);







int gpioWaveGetPulses(void);






int gpioWaveGetHighPulses(void);







int gpioWaveGetMaxPulses(void);






int gpioWaveGetCbs(void);







int gpioWaveGetHighCbs(void);







int gpioWaveGetMaxCbs(void);







int gpioSerialReadOpen(unsigned user_gpio, unsigned baud, unsigned data_bits);
# 2262 "pigpio.h"
int gpioSerialReadInvert(unsigned user_gpio, unsigned invert);
# 2283 "pigpio.h"
int gpioSerialRead(unsigned user_gpio, void *buf, size_t bufSize);
# 2307 "pigpio.h"
int gpioSerialReadClose(unsigned user_gpio);
# 2319 "pigpio.h"
int i2cOpen(unsigned i2cBus, unsigned i2cAddr, unsigned i2cFlags);
# 2362 "pigpio.h"
int i2cClose(unsigned handle);
# 2375 "pigpio.h"
int i2cWriteQuick(unsigned handle, unsigned bit);
# 2396 "pigpio.h"
int i2cWriteByte(unsigned handle, unsigned bVal);
# 2416 "pigpio.h"
int i2cReadByte(unsigned handle);
# 2435 "pigpio.h"
int i2cWriteByteData(unsigned handle, unsigned i2cReg, unsigned bVal);
# 2457 "pigpio.h"
int i2cWriteWordData(unsigned handle, unsigned i2cReg, unsigned wVal);
# 2479 "pigpio.h"
int i2cReadByteData(unsigned handle, unsigned i2cReg);
# 2500 "pigpio.h"
int i2cReadWordData(unsigned handle, unsigned i2cReg);
# 2521 "pigpio.h"
int i2cProcessCall(unsigned handle, unsigned i2cReg, unsigned wVal);
# 2544 "pigpio.h"
int i2cWriteBlockData(
unsigned handle, unsigned i2cReg, char *buf, unsigned count);
# 2569 "pigpio.h"
int i2cReadBlockData(unsigned handle, unsigned i2cReg, char *buf);
# 2594 "pigpio.h"
int i2cBlockProcessCall(
unsigned handle, unsigned i2cReg, char *buf, unsigned count);
# 2624 "pigpio.h"
int i2cReadI2CBlockData(
unsigned handle, unsigned i2cReg, char *buf, unsigned count);
# 2648 "pigpio.h"
int i2cWriteI2CBlockData(
unsigned handle, unsigned i2cReg, char *buf, unsigned count);
# 2670 "pigpio.h"
int i2cReadDevice(unsigned handle, char *buf, unsigned count);
# 2690 "pigpio.h"
int i2cWriteDevice(unsigned handle, char *buf, unsigned count);
# 2709 "pigpio.h"
void i2cSwitchCombined(int setting);
# 2724 "pigpio.h"
int i2cSegments(unsigned handle, pi_i2c_msg_t *segs, unsigned numSegs);
# 2739 "pigpio.h"
int i2cZip(
   unsigned handle,
   char *inBuf,
   unsigned inLen,
   char *outBuf,
   unsigned outLen);
# 2799 "pigpio.h"
int bbI2COpen(unsigned SDA, unsigned SCL, unsigned baud);
# 2828 "pigpio.h"
int bbI2CClose(unsigned SDA);
# 2841 "pigpio.h"
int bbI2CZip(
   unsigned SDA,
   char *inBuf,
   unsigned inLen,
   char *outBuf,
   unsigned outLen);
# 2912 "pigpio.h"
int bscXfer(bsc_xfer_t *bsc_xfer);
# 3051 "pigpio.h"
int bbSPIOpen(
   unsigned CS, unsigned MISO, unsigned MOSI, unsigned SCLK,
   unsigned baud, unsigned spiFlags);
# 3107 "pigpio.h"
int bbSPIClose(unsigned CS);
# 3120 "pigpio.h"
int bbSPIXfer(
   unsigned CS,
   char *inBuf,
   char *outBuf,
   unsigned count);
# 3206 "pigpio.h"
int spiOpen(unsigned spiChan, unsigned baud, unsigned spiFlags);
# 3298 "pigpio.h"
int spiClose(unsigned handle);
# 3311 "pigpio.h"
int spiRead(unsigned handle, char *buf, unsigned count);
# 3328 "pigpio.h"
int spiWrite(unsigned handle, char *buf, unsigned count);
# 3344 "pigpio.h"
int spiXfer(unsigned handle, char *txBuf, char *rxBuf, unsigned count);
# 3363 "pigpio.h"
int serOpen(char *sertty, unsigned baud, unsigned serFlags);
# 3387 "pigpio.h"
int serClose(unsigned handle);
# 3399 "pigpio.h"
int serWriteByte(unsigned handle, unsigned bVal);
# 3412 "pigpio.h"
int serReadByte(unsigned handle);
# 3427 "pigpio.h"
int serWrite(unsigned handle, char *buf, unsigned count);
# 3444 "pigpio.h"
int serRead(unsigned handle, char *buf, unsigned count);
# 3463 "pigpio.h"
int serDataAvailable(unsigned handle);
# 3478 "pigpio.h"
int gpioTrigger(unsigned user_gpio, unsigned pulseLen, unsigned level);
# 3495 "pigpio.h"
int gpioSetWatchdog(unsigned user_gpio, unsigned timeout);
# 3539 "pigpio.h"
int gpioNoiseFilter(unsigned user_gpio, unsigned steady, unsigned active);
# 3571 "pigpio.h"
int gpioGlitchFilter(unsigned user_gpio, unsigned steady);
# 3601 "pigpio.h"
int gpioSetGetSamplesFunc(gpioGetSamplesFunc_t f, uint32_t bits);
# 3630 "pigpio.h"
int gpioSetGetSamplesFuncEx(
   gpioGetSamplesFuncEx_t f, uint32_t bits, void *userdata);
# 3655 "pigpio.h"
int gpioSetTimerFunc(unsigned timer, unsigned millis, gpioTimerFunc_t f);
# 3686 "pigpio.h"
int gpioSetTimerFuncEx(
   unsigned timer, unsigned millis, gpioTimerFuncEx_t f, void *userdata);
# 3710 "pigpio.h"
pthread_t *gpioStartThread(gpioThreadFunc_t f, void *userdata);
# 3764 "pigpio.h"
void gpioStopThread(pthread_t *pth);
# 3779 "pigpio.h"
int gpioStoreScript(char *script);
# 3795 "pigpio.h"
int gpioRunScript(unsigned script_id, unsigned numPar, uint32_t *param);
# 3813 "pigpio.h"
int gpioRunScript(unsigned script_id, unsigned numPar, uint32_t *param);
# 3833 "pigpio.h"
int gpioUpdateScript(unsigned script_id, unsigned numPar, uint32_t *param);
# 3854 "pigpio.h"
int gpioScriptStatus(unsigned script_id, uint32_t *param);
# 3882 "pigpio.h"
int gpioStopScript(unsigned script_id);
# 3895 "pigpio.h"
int gpioDeleteScript(unsigned script_id);
# 3908 "pigpio.h"
int gpioSetSignalFunc(unsigned signum, gpioSignalFunc_t f);
# 3931 "pigpio.h"
int gpioSetSignalFuncEx(
   unsigned signum, gpioSignalFuncEx_t f, void *userdata);
# 3954 "pigpio.h"
uint32_t gpioRead_Bits_0_31(void);






uint32_t gpioRead_Bits_32_53(void);






int gpioWrite_Bits_0_31_Clear(uint32_t bits);
# 3986 "pigpio.h"
int gpioWrite_Bits_32_53_Clear(uint32_t bits);
# 3999 "pigpio.h"
int gpioWrite_Bits_0_31_Set(uint32_t bits);
# 4012 "pigpio.h"
int gpioWrite_Bits_32_53_Set(uint32_t bits);
# 4029 "pigpio.h"
int gpioHardwareClock(unsigned gpio, unsigned clkfreq);
# 4067 "pigpio.h"
int gpioHardwarePWM(unsigned gpio, unsigned PWMfreq, unsigned PWMduty);
# 4119 "pigpio.h"
int gpioTime(unsigned timetype, int *seconds, int *micros);
# 4148 "pigpio.h"
int gpioSleep(unsigned timetype, int seconds, int micros);
# 4183 "pigpio.h"
uint32_t gpioDelay(uint32_t micros);
# 4198 "pigpio.h"
uint32_t gpioTick(void);
# 4229 "pigpio.h"
unsigned gpioHardwareRevision(void);
# 4257 "pigpio.h"
unsigned gpioVersion(void);






int gpioGetPad(unsigned pad);
# 4286 "pigpio.h"
int gpioSetPad(unsigned pad, unsigned padStrength);
# 4308 "pigpio.h"
int eventMonitor(unsigned handle, uint32_t bits);
# 4337 "pigpio.h"
int eventSetFunc(unsigned event, eventFunc_t f);
# 4357 "pigpio.h"
int eventSetFuncEx(unsigned event, eventFuncEx_t f, void *userdata);
# 4381 "pigpio.h"
int eventTrigger(unsigned event);
# 4407 "pigpio.h"
int shell(char *scriptName, char *scriptString);
# 4448 "pigpio.h"
#pragma GCC diagnostic push

#pragma GCC diagnostic ignored "-Wcomment"


int fileOpen(char *file, unsigned mode);
# 4558 "pigpio.h"
#pragma GCC diagnostic pop


int fileClose(unsigned handle);
# 4578 "pigpio.h"
int fileWrite(unsigned handle, char *buf, unsigned count);
# 4607 "pigpio.h"
int fileRead(unsigned handle, char *buf, unsigned count);
# 4630 "pigpio.h"
int fileSeek(unsigned handle, int32_t seekOffset, int seekFrom);
# 4654 "pigpio.h"
#pragma GCC diagnostic push

#pragma GCC diagnostic ignored "-Wcomment"


int fileList(char *fpat, char *buf, unsigned count);
# 4710 "pigpio.h"
#pragma GCC diagnostic pop



int gpioCfgBufferSize(unsigned cfgMillis);
# 4749 "pigpio.h"
int gpioCfgClock(
   unsigned cfgMicros, unsigned cfgPeripheral, unsigned cfgSource);
# 4786 "pigpio.h"
int gpioCfgDMAchannel(unsigned DMAchannel);
# 4801 "pigpio.h"
int gpioCfgDMAchannels(unsigned primaryChannel, unsigned secondaryChannel);
# 4835 "pigpio.h"
int gpioCfgPermissions(uint64_t updateMask);
# 4862 "pigpio.h"
int gpioCfgSocketPort(unsigned port);
# 4877 "pigpio.h"
int gpioCfgInterfaces(unsigned ifFlags);
# 4900 "pigpio.h"
int gpioCfgMemAlloc(unsigned memAllocMode);
# 4920 "pigpio.h"
int gpioCfgNetAddr(int numSockAddr, uint32_t *sockAddr);
# 4935 "pigpio.h"
int gpioCfgInternals(unsigned cfgWhat, unsigned cfgVal);
# 4947 "pigpio.h"
uint32_t gpioCfgGetInternals(void);






int gpioCfgSetInternals(uint32_t cfgVal);
# 4966 "pigpio.h"
int gpioCustom1(unsigned arg1, unsigned arg2, char *argx, unsigned argc);
# 4984 "pigpio.h"
int gpioCustom2(unsigned arg1, char *argx, unsigned argc,
                char *retBuf, unsigned retMax);
# 5008 "pigpio.h"
int rawWaveAddSPI(
   rawSPI_t *spi,
   unsigned offset,
   unsigned spiSS,
   char *buf,
   unsigned spiTxBits,
   unsigned spiBitFirst,
   unsigned spiBitLast,
   unsigned spiBits);
# 5039 "pigpio.h"
int rawWaveAddGeneric(unsigned numPulses, rawWave_t *pulses);
# 5067 "pigpio.h"
unsigned rawWaveCB(void);







rawCbs_t *rawWaveCBAdr(int cbNum);
# 5087 "pigpio.h"
uint32_t rawWaveGetOOL(int pos);
# 5100 "pigpio.h"
void rawWaveSetOOL(int pos, uint32_t lVal);
# 5113 "pigpio.h"
uint32_t rawWaveGetOut(int pos);
# 5128 "pigpio.h"
void rawWaveSetOut(int pos, uint32_t lVal);
# 5143 "pigpio.h"
uint32_t rawWaveGetIn(int pos);
# 5158 "pigpio.h"
void rawWaveSetIn(int pos, uint32_t lVal);
# 5173 "pigpio.h"
rawWaveInfo_t rawWaveInfo(int wave_id);
# 5185 "pigpio.h"
int getBitInBytes(int bitPos, char *buf, int numBits);
# 5199 "pigpio.h"
void putBitInBytes(int bitPos, char *buf, int bit);
# 5212 "pigpio.h"
double time_time(void);






void time_sleep(double seconds);
# 5230 "pigpio.h"
void rawDumpWave(void);
# 5239 "pigpio.h"
void rawDumpScript(unsigned script_id);
# 68 "pigpio.c" 2

# 1 "command.h" 1
# 55 "command.h"
typedef struct
{
   uint32_t cmd;
   uint32_t p1;
   uint32_t p2;
   union
   {
      uint32_t p3;
      uint32_t ext_len;
      uint32_t res;
   };
} cmdCmd_t;

typedef struct
{
   int eaten;
   int8_t opt[4];
} cmdCtlParse_t;

typedef struct
{
   int cmd;
   char *name;
   int vt;
   int rv;
   int cvis;
} cmdInfo_t;

typedef struct
{
   uint32_t tag;
   int step;
} cmdTagStep_t;

typedef struct
{
   uintptr_t p[5];
   int8_t opt[4];
} cmdInstr_t;

typedef struct
{





   int *par;
   int *var;
   cmdInstr_t *instr;
   int instrs;
   char *str_area;
   int str_area_len;
   int str_area_pos;
} cmdScript_t;

extern cmdInfo_t cmdInfo[];

extern char *cmdUsage;

int cmdParse(char *buf, uintptr_t *p, unsigned ext_len, char *ext, cmdCtlParse_t *ctl);

int cmdParseScript(char *script, cmdScript_t *s, int diags);

char *cmdErrStr(int error);

char *cmdStr(void);
# 70 "pigpio.c" 2
# 896 "pigpio.c"
typedef void (*callbk_t) ();

typedef struct
{
   rawCbs_t cb [128];
} dmaPage_t;

typedef struct
{
   rawCbs_t cb [117];
   uint32_t level [38];
   uint32_t gpioOff [38];
   uint32_t tick [2];
   uint32_t gpioOn [2];
   uint32_t periphData;
   uint32_t pad [7];
} dmaIPage_t;

typedef struct
{
   rawCbs_t cb [118];
   uint32_t OOL [79];
   uint32_t periphData;
} dmaOPage_t;

typedef struct
{
   uint8_t is;
   uint8_t pad;
   uint16_t width;
   uint16_t range;
   uint16_t freqIdx;
   uint16_t deferOff;
   uint16_t deferRng;
} gpioInfo_t;

typedef struct
{
   callbk_t func;
   unsigned ex;
   void *userdata;

   int wdSteadyUs;
   uint32_t wdTick;
   uint32_t wdLBitV;

   int nfSteadyUs;
   int nfActiveUs;
   int nfActive;
   uint32_t nfTick1;
   uint32_t nfTick2;
   uint32_t nfLBitV;
   uint32_t nfRBitV;

   uint32_t gfSteadyUs;
   uint32_t gfTick;
   uint32_t gfLBitV;
   uint32_t gfRBitV;

} gpioAlert_t;

typedef struct
{
   callbk_t func;
   unsigned ex;
   void *userdata;
   int ignore;
   int fired;
} eventAlert_t;

typedef struct
{
   unsigned gpio;
   pthread_t *pth;
   callbk_t func;
   unsigned edge;
   int timeout;
   unsigned ex;
   void *userdata;
   int fd;
   int inited;
} gpioISR_t;

typedef struct
{
   callbk_t func;
   unsigned ex;
   void *userdata;
} gpioSignal_t;

typedef struct
{
   callbk_t func;
   unsigned ex;
   void *userdata;
   uint32_t bits;
} gpioGetSamples_t;

typedef struct
{
   callbk_t func;
   unsigned ex;
   void *userdata;
   unsigned id;
   unsigned running;
   unsigned millis;
   pthread_t pthId;
} gpioTimer_t;

typedef struct
{
   unsigned id;
   unsigned state;
   unsigned request;
   unsigned run_state;
   uint32_t waitBits;
   uint32_t eventBits;
   uint32_t changedBits;
   pthread_t *pthIdp;
   pthread_mutex_t pthMutex;
   pthread_cond_t pthCond;
   cmdScript_t script;
} gpioScript_t;


typedef struct
{
   uint16_t valid;
   uint16_t servoIdx;
} clkCfg_t;

typedef struct
{
   uint16_t seqno;
   uint16_t state;
   uint32_t bits;
   uint32_t eventBits;
   uint32_t lastReportTick;
   int fd;
   int pipe;
   int max_emits;
} gpioNotify_t;

typedef struct
{
   uint16_t state;
   int16_t fd;
   uint32_t mode;
} fileInfo_t;

typedef struct
{
   uint16_t state;
   int16_t fd;
   uint32_t addr;
   uint32_t flags;
   uint32_t funcs;
} i2cInfo_t;

typedef struct
{
   uint16_t state;
   int16_t fd;
   uint32_t flags;
} serInfo_t;

typedef struct
{
   uint16_t state;
   unsigned speed;
   uint32_t flags;
} spiInfo_t;

typedef struct
{
   uint32_t alertTicks;
   uint32_t lateTicks;
   uint32_t moreToDo;
   uint32_t diffTick[50];
   uint32_t cbTicks;
   uint32_t cbCalls;
   uint32_t maxEmit;
   uint32_t emitFrags;
   uint32_t maxSamples;
   uint32_t numSamples;
   uint32_t DMARestarts;
   uint32_t dmaInitCbsCount;
   uint32_t goodPipeWrite;
   uint32_t shortPipeWrite;
   uint32_t wouldBlockPipeWrite;
} gpioStats_t;

typedef struct
{
   unsigned bufferMilliseconds;
   unsigned clockMicros;
   unsigned clockPeriph;
   unsigned DMAprimaryChannel;
   unsigned DMAsecondaryChannel;
   unsigned socketPort;
   unsigned ifFlags;
   unsigned memAllocMode;
   unsigned dbgLevel;
   unsigned alertFreq;
   uint32_t internals;




} gpioCfg_t;

typedef struct
{
   uint32_t micros;
   uint32_t highMicros;
   uint32_t maxMicros;
   uint32_t pulses;
   uint32_t highPulses;
   uint32_t maxPulses;
   uint32_t cbs;
   uint32_t highCbs;
   uint32_t maxCbs;
} wfStats_t;

typedef struct
{
   char *buf;
   uint32_t bufSize;
   int readPos;
   int writePos;
   uint32_t fullBit;
   uint32_t halfBit;
   int timeout;
   uint32_t startBitTick;
   uint32_t nextBitDiff;
   int bit;
   uint32_t data;
   int bytes;
   int level;
   int dataBits;
   int invert;
} wfRxSerial_t;

typedef struct
{
   int SDA;
   int SCL;
   int delay;
   int SDAMode;
   int SCLMode;
   int started;
} wfRxI2C_t;

typedef struct
{
   int CS;
   int MISO;
   int MOSI;
   int SCLK;
   int usage;
   int delay;
   int spiFlags;
   int MISOMode;
   int MOSIMode;
   int CSMode;
   int SCLKMode;
} wfRxSPI_t;

typedef struct
{
   int mode;
   int gpio;
   uint32_t baud;
   pthread_mutex_t mutex;
   union
   {
      wfRxSerial_t s;
      wfRxI2C_t I;
      wfRxSPI_t S;
   };
} wfRx_t;

union my_smbus_data
{
   uint8_t byte;
   uint16_t word;
   uint8_t block[32 + 2];
};

struct my_smbus_ioctl_data
{
   uint8_t read_write;
   uint8_t command;
   uint32_t size;
   union my_smbus_data *data;
};

typedef struct
{
   pi_i2c_msg_t *msgs;
   uint32_t nmsgs;
} my_i2c_rdwr_ioctl_data_t;

typedef struct
{
   unsigned div;
   unsigned frac;
   unsigned clock;
} clkInf_t;

typedef struct
{
   unsigned handle;
   uintptr_t bus_addr;
   uintptr_t *virtual_addr;
   unsigned size;
} DMAMem_t;





static volatile uint32_t piCores = 0;
static volatile uint32_t pi_peri_phys = 0x20000000;
static volatile uint32_t pi_dram_bus = 0x40000000;
static volatile uint32_t pi_mem_flag = 0x0C;
static volatile uint32_t pi_ispi = 0;
static volatile uint32_t pi_is_2711 = 0;
static volatile uint32_t clk_osc_freq = 19200000;
static volatile uint32_t clk_plld_freq = 500000000;
static volatile uint32_t hw_pwm_max_freq = 125000000;
static volatile uint32_t hw_clk_min_freq = 4689;
static volatile uint32_t hw_clk_max_freq = 250000000;

static int libInitialised = 0;



static struct timespec libStarted;

static uint32_t sockNetAddr[256];

static int numSockNetAddr = 0;

static uint32_t reportedLevel = 0;

static int waveClockInited = 0;
static int PWMClockInited = 0;

static volatile gpioStats_t gpioStats;

static int gpioMaskSet = 0;



static uint64_t gpioMask;

static rawWave_t wf[3][(4 * 3000)];

static int wfc[3]={0, 0, 0};

static int wfcur=0;

static wfStats_t wfStats=
{
   0, 0, (30 * 60 * 1000000),
   0, 0, (4 * 3000),
   0, 0, ((53 * 4) * 118)
};

static rawWaveInfo_t waveInfo[250];

static wfRx_t wfRx[31 +1];

static int waveOutBotCB = 10*118;
static int waveOutBotOOL = 10*79;
static int waveOutTopOOL = ((53 * 4) * 79);
static int waveOutCount = 0;

static uint32_t *waveEndPtr = 
# 1275 "pigpio.c" 3 4
                             ((void *)0)
# 1275 "pigpio.c"
                                 ;

static volatile uint32_t alertBits = 0;
static volatile uint32_t monitorBits = 0;
static volatile uint32_t notifyBits = 0;
static volatile uint32_t scriptBits = 0;
static volatile uint32_t gFilterBits = 0;
static volatile uint32_t nFilterBits = 0;
static volatile uint32_t wdogBits = 0;

static volatile uint32_t scriptEventBits = 0;

static volatile int runState = 0;

static int pthAlertRunning = 0;
static int pthFifoRunning = 0;
static int pthSocketRunning = 0;

static gpioAlert_t gpioAlert [31 +1];

static eventAlert_t eventAlert [31 +1];

static gpioISR_t gpioISR [53 +1];

static gpioGetSamples_t gpioGetSamples;

static gpioInfo_t gpioInfo [53 +1];

static gpioNotify_t gpioNotify [32];

static fileInfo_t fileInfo [16];
static i2cInfo_t i2cInfo [512];
static serInfo_t serInfo [16];
static spiInfo_t spiInfo [32];

static gpioScript_t gpioScript [32];

static gpioSignal_t gpioSignal [63 +1];

static gpioTimer_t gpioTimer [9 +1];

static int pwmFreq[18];





static FILE * inpFifo = 
# 1322 "pigpio.c" 3 4
                       ((void *)0)
# 1322 "pigpio.c"
                           ;
static FILE * outFifo = 
# 1323 "pigpio.c" 3 4
                       ((void *)0)
# 1323 "pigpio.c"
                           ;

static int fdLock = -1;
static int fdMem = -1;
static int fdSock = -1;
static int fdPmap = -1;
static int fdMbox = -1;

static DMAMem_t *dmaMboxBlk = 
# 1331 "pigpio.c" 3 4
                             ((void *) -1)
# 1331 "pigpio.c"
                                       ;
static uintptr_t * * dmaPMapBlk = 
# 1332 "pigpio.c" 3 4
                                 ((void *) -1)
# 1332 "pigpio.c"
                                           ;
static dmaPage_t * * dmaVirt = 
# 1333 "pigpio.c" 3 4
                              ((void *) -1)
# 1333 "pigpio.c"
                                        ;
static dmaPage_t * * dmaBus = 
# 1334 "pigpio.c" 3 4
                             ((void *) -1)
# 1334 "pigpio.c"
                                       ;

static dmaIPage_t * * dmaIVirt = 
# 1336 "pigpio.c" 3 4
                                ((void *) -1)
# 1336 "pigpio.c"
                                          ;
static dmaIPage_t * * dmaIBus = 
# 1337 "pigpio.c" 3 4
                               ((void *) -1)
# 1337 "pigpio.c"
                                         ;

static dmaOPage_t * * dmaOVirt = 
# 1339 "pigpio.c" 3 4
                                ((void *) -1)
# 1339 "pigpio.c"
                                          ;
static dmaOPage_t * * dmaOBus = 
# 1340 "pigpio.c" 3 4
                               ((void *) -1)
# 1340 "pigpio.c"
                                         ;

static volatile uint32_t * auxReg = 
# 1342 "pigpio.c" 3 4
                                    ((void *) -1)
# 1342 "pigpio.c"
                                              ;
static volatile uint32_t * bscsReg = 
# 1343 "pigpio.c" 3 4
                                    ((void *) -1)
# 1343 "pigpio.c"
                                              ;
static volatile uint32_t * clkReg = 
# 1344 "pigpio.c" 3 4
                                    ((void *) -1)
# 1344 "pigpio.c"
                                              ;
static volatile uint32_t * dmaReg = 
# 1345 "pigpio.c" 3 4
                                    ((void *) -1)
# 1345 "pigpio.c"
                                              ;
static volatile uint32_t * gpioReg = 
# 1346 "pigpio.c" 3 4
                                    ((void *) -1)
# 1346 "pigpio.c"
                                              ;
static volatile uint32_t * padsReg = 
# 1347 "pigpio.c" 3 4
                                    ((void *) -1)
# 1347 "pigpio.c"
                                              ;
static volatile uint32_t * pcmReg = 
# 1348 "pigpio.c" 3 4
                                    ((void *) -1)
# 1348 "pigpio.c"
                                              ;
static volatile uint32_t * pwmReg = 
# 1349 "pigpio.c" 3 4
                                    ((void *) -1)
# 1349 "pigpio.c"
                                              ;
static volatile uint32_t * spiReg = 
# 1350 "pigpio.c" 3 4
                                    ((void *) -1)
# 1350 "pigpio.c"
                                              ;
static volatile uint32_t * systReg = 
# 1351 "pigpio.c" 3 4
                                    ((void *) -1)
# 1351 "pigpio.c"
                                              ;

static volatile uint32_t * dmaIn = 
# 1353 "pigpio.c" 3 4
                                    ((void *) -1)
# 1353 "pigpio.c"
                                              ;
static volatile uint32_t * dmaOut = 
# 1354 "pigpio.c" 3 4
                                    ((void *) -1)
# 1354 "pigpio.c"
                                              ;

static uint32_t hw_clk_freq[3];
static uint32_t hw_pwm_freq[2];
static uint32_t hw_pwm_duty[2];
static uint32_t hw_pwm_real_range[2];

static volatile gpioCfg_t gpioCfg =
{
   120,
   5,
   1,
   15,
   15,
   8888,
   0,
   0,
   0,
   0,
   0,
};



static unsigned bufferBlocks;
static unsigned bufferCycles;

static pthread_t pthAlert;
static pthread_t pthFifo;
static pthread_t pthSocket;

static uint32_t spi_dummy;

static unsigned old_mode_ce0;
static unsigned old_mode_ce1;
static unsigned old_mode_sclk;
static unsigned old_mode_miso;
static unsigned old_mode_mosi;

static uint32_t old_spi_cs;
static uint32_t old_spi_clk;

static unsigned old_mode_ace0;
static unsigned old_mode_ace1;
static unsigned old_mode_ace2;
static unsigned old_mode_asclk;
static unsigned old_mode_amiso;
static unsigned old_mode_amosi;

static uint32_t old_spi_cntl0;
static uint32_t old_spi_cntl1;

static uint32_t bscFR;



static const uint8_t clkDef[53 + 1] =
{

             0x00, 0x00, 0x00, 0x00, 0x84, 0x94, 0xA4, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x82, 0x92, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x84, 0x00, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x94, 0xA4, 0x94, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00,
};
# 1442 "pigpio.c"
static const uint8_t PWMDef[53 + 1] =
{

             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x84, 0x94, 0x00, 0x00, 0x00, 0x00, 0x82, 0x92,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
             0x84, 0x94, 0x00, 0x00, 0x00, 0x94, 0x00, 0x00, 0x00, 0x00,
             0x00, 0x00, 0x85, 0x95,
};
# 1472 "pigpio.c"
static const clkCfg_t clkCfg[]=
{

      { 0, 0},
      { 1, 17},
      { 1, 16},
      { 0, 0},
      { 1, 15},
      { 1, 14},
      { 0, 0},
      { 0, 0},
      { 1, 13},
      { 0, 0},
      { 1, 12},
};

static const uint16_t pwmCycles[18]=
   { 1, 2, 4, 5, 8, 10, 16, 20, 25,
     32, 40, 50, 80, 100, 160, 200, 400, 800};

static const uint16_t pwmRealRange[18]=
   { 25, 50, 100, 125, 200, 250, 400, 500, 625,
    800, 1000, 1250, 2000, 2500, 4000, 5000, 10000, 20000};



static void intNotifyBits(void);

static void intScriptBits(void);

static void intScriptEventBits(void);

static int gpioNotifyOpenInBand(int fd);

static void initHWClk
   (int clkCtl, int clkDiv, int clkSrc, int divI, int divF, int MASH);

static void initDMAgo(volatile uint32_t *dmaAddr, uint32_t cbAddr);

int gpioWaveTxStart(unsigned wave_mode);

static void closeOrphanedNotifications(int slot, int fd);




int myScriptNameValid(char *name)
{
   int i, c, len, valid;

   len = strlen(name);

   valid = 1;

   for (i=0; i<len; i++)
   {
      c = name[i];

      if ((!
# 1530 "pigpio.c" 3 4
           ((*__ctype_b_loc ())[(int) ((
# 1530 "pigpio.c"
           c
# 1530 "pigpio.c" 3 4
           ))] & (unsigned short int) _ISalnum)
# 1530 "pigpio.c"
                     ) && (c != '_') && (c != '-'))
      {
         valid = 0;
         break;
      }
   }
   return valid;
}



static char * myTimeStamp()
{
   static struct timeval last;
   static char buf[32];
   struct timeval now;

   struct tm tmp;

   gettimeofday(&now, 
# 1549 "pigpio.c" 3 4
                     ((void *)0)
# 1549 "pigpio.c"
                         );

   if (now.tv_sec != last.tv_sec)
   {
      localtime_r(&now.tv_sec, &tmp);
      strftime(buf, sizeof(buf), "%F %T", &tmp);
      last.tv_sec = now.tv_sec;
   }

   return buf;
}



int myPathBad(char *name)
{
   int i, c, len, in_part, parts, last_char_dot;
   char *bad="/*?.";

   parts = 0;
   in_part = 0;
   last_char_dot = 0;

   len = strlen(name);

   for (i=0; i<len; i++)
   {
      c = name[i];

      if (memchr(bad, c, 4))
      {
         if (c == '.')
         {
            if (last_char_dot) return 1;
            last_char_dot = 1;
         }
         else last_char_dot = 0;

         in_part = 0;
      }
      else
      {
         last_char_dot = 0;

         if (!in_part) parts++;

         in_part = 1;
      }
   }

   if (parts < 2) return 1; else return 0;
}



static char *myBuf2Str(unsigned count, char *buf)
{
   static char str[128];
   int i, c;

   if (count && buf)
   {
      if (count > 40) c = 40; else c = count;

      for (i=0; i<c; i++) sprintf(str+(3*i), "%02X ", buf[i]);
      str[(3*c)-1] = 0;
   }
   else str[0] = 0;

   return str;
}



static int my_smbus_access(
   int fd, char rw, uint8_t cmd, int size, union my_smbus_data *data)
{
   struct my_smbus_ioctl_data args;

   { if ((gpioCfg.dbgLevel >= 5) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 1628 "pigpio.c" 3 4
  stderr
# 1628 "pigpio.c"
  , "%s %s: " "rw=%d reg=%d cmd=%d data=%s" "\n" , myTimeStamp(), __FUNCTION__ , rw, cmd, size, myBuf2Str(data->byte+1, (char*)data)); }
                                                          ;

   args.read_write = rw;
   args.command = cmd;
   args.size = size;
   args.data = data;

   return ioctl(fd, 0x0720, &args);
}



static void myGpioSetMode(unsigned gpio, unsigned mode)
{
   int reg, shift;

   reg = gpio/10;
   shift = (gpio%10) * 3;

   gpioReg[reg] = (gpioReg[reg] & ~(7<<shift)) | (mode<<shift);
}




static int myGpioRead(unsigned gpio)
{
   if ((*(gpioReg + 13 + (gpio>>5)) & (1<<(gpio&0x1F))) != 0) return 1;
   else return 0;
}




static void myGpioWrite(unsigned gpio, unsigned level)
{
   if (level == 0) *(gpioReg + 10 + (gpio>>5)) = (1<<(gpio&0x1F));
   else *(gpioReg + 7 + (gpio>>5)) = (1<<(gpio&0x1F));
}



static void myGpioSleep(int seconds, int micros)
{
   struct timespec ts, rem;

   ts.tv_sec = seconds;
   ts.tv_nsec = micros * 1000;

   while (clock_nanosleep(
# 1678 "pigpio.c" 3 4
                         0
# 1678 "pigpio.c"
                                       , 0, &ts, &rem))
   {

      ts = rem;
   }
}



static uint32_t myGpioDelay(uint32_t micros)
{
   uint32_t start;

   start = systReg[1];

   if (micros <= 100)
   {
      while ((systReg[1] - start) <= micros);
   }
   else
   {
      myGpioSleep(micros/1000000, micros%1000000);
   }

   return (systReg[1] - start);
}



static void myCreatePipe(char * name, int perm)
{
   unlink(name);

   mkfifo(name, perm);

   if (chmod(name, perm) < 0)
   {
      { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 1715 "pigpio.c" 3 4
     stderr
# 1715 "pigpio.c"
     , "%s %s: " "Can't set permissions (%d) for %s, %m" "\n" , myTimeStamp(), __FUNCTION__ , perm, name); };
      return;
   }
}



static void myOffPageSlot(int pos, int * page, int * slot)
{
   *page = pos/38;
   *slot = pos%38;
}



static void myLvsPageSlot(int pos, int * page, int * slot)
{
   *page = pos/38;
   *slot = pos%38;
}



static void myTckPageSlot(int pos, int * page, int * slot)
{
   *page = pos/2;
   *slot = pos%2;
}



static uint32_t myGetLevel(int pos)
{
   uint32_t level;
   int page, slot;

   myLvsPageSlot(pos, &page, &slot);

   level = dmaIVirt[page]->level[slot];

   return level;
}



static int myI2CGetPar(char *inBuf, int *inPos, int inLen, int *esc)
{
   int bytes;

   if (*esc) bytes = 2; else bytes = 1;

   *esc = 0;

   if (*inPos <= (inLen - bytes))
   {
      if (bytes == 1)
      {
         return inBuf[(*inPos)++];
      }
      else
      {
         (*inPos) += 2;
         return inBuf[*inPos-2] + (inBuf[*inPos-1]<<8);
      }
   }
   return -1;
}



static uint32_t myGetTick(int pos)
{
   uint32_t tick;
   int page, slot;

   myTckPageSlot(pos, &page, &slot);

   tick = dmaIVirt[page]->tick[slot];

   return tick;
}

static int myPermit(unsigned gpio)
{
   if (gpio <= 53)
   {
      if (gpioMask & ((uint64_t)(1)<<gpio)) return 1;
      else return 0;
   }
   return 1;
}

static void flushMemory(void)
{
   static int val = 0;

   void *dummy;

   dummy = mmap(
       0, (1024*4096),
       
# 1815 "pigpio.c" 3 4
      0x1
# 1815 "pigpio.c"
               |
# 1815 "pigpio.c" 3 4
                0x2
# 1815 "pigpio.c"
                          |
# 1815 "pigpio.c" 3 4
                           0x4
# 1815 "pigpio.c"
                                    ,
       
# 1816 "pigpio.c" 3 4
      0x01
# 1816 "pigpio.c"
                |
# 1816 "pigpio.c" 3 4
                 0x20
# 1816 "pigpio.c"
                              |
# 1816 "pigpio.c" 3 4
                               0x04000
# 1816 "pigpio.c"
                                            |
# 1816 "pigpio.c" 3 4
                                             0x02000
# 1816 "pigpio.c"
                                                       ,
       -1, 0);

   if (dummy == 
# 1819 "pigpio.c" 3 4
               ((void *) -1)
# 1819 "pigpio.c"
                         )
   {
      { if ((gpioCfg.dbgLevel >= 1) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 1821 "pigpio.c" 3 4
     stderr
# 1821 "pigpio.c"
     , "%s %s: " "mmap dummy failed (%m)" "\n" , myTimeStamp(), __FUNCTION__); };
   }
   else
   {
      memset(dummy, val++, (1024*4096));
      memset(dummy, val++, (1024*4096));
      munmap(dummy, 1024*4096);
   }
}



static void wfRx_lock(int i)
{
   pthread_mutex_lock(&wfRx[i].mutex);
}



static void wfRx_unlock(int i)
{
   pthread_mutex_unlock(&wfRx[i].mutex);
}



static void spinWhileStarting(void)
{
   while (runState == 0)
   {
      if (piCores == 1) myGpioDelay(1000);
      else flushMemory();
   }
}



static int myDoCommand(uintptr_t *p, unsigned bufSize, char *buf)
{
   int res, i, j;
   uint32_t mask;
   uint32_t tmp1, tmp2, tmp3, tmp4, tmp5;
   gpioPulse_t *pulse;
   bsc_xfer_t xfer;
   int masked;
   res = 0;

   switch (p[0])
   {
      case 12:
         mask = gpioMask;

         res = gpioWrite_Bits_0_31_Clear(p[1]&mask);

         if ((mask | p[1]) != mask)
         {
            { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 1877 "pigpio.c" 3 4
           stderr
# 1877 "pigpio.c"
           , "%s %s: " "gpioWrite_Bits_0_31_Clear: bad bits %08"
# 1877 "pigpio.c" 3 4
           "l" "X"
# 1877 "pigpio.c"
           " (permissions %08X)" "\n" , myTimeStamp(), __FUNCTION__ , p[1], mask); }

                          ;
            res = -42;
         }
         break;

      case 13:
         mask = gpioMask>>32;

         res = gpioWrite_Bits_32_53_Clear(p[1]&mask);

         if ((mask | p[1]) != mask)
         {
            { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 1891 "pigpio.c" 3 4
           stderr
# 1891 "pigpio.c"
           , "%s %s: " "gpioWrite_Bits_32_53_Clear: bad bits %08"
# 1891 "pigpio.c" 3 4
           "l" "X"
# 1891 "pigpio.c"
           " (permissions %08X)" "\n" , myTimeStamp(), __FUNCTION__ , p[1], mask); }

                          ;
            res = -42;
         }
         break;

      case 89:
         res = bbI2CClose(p[1]);
         break;

      case 90:
         memcpy(&p[4], buf, 4);
         res = bbI2COpen(p[1], p[2], p[4]);
         break;

      case 91:

         if (p[3] > (bufSize/2)) p[3] = bufSize/2;
         res = bbI2CZip(p[1], buf, p[3], buf+(bufSize/2), bufSize/2);
         if (res > 0)
         {
            memcpy(buf, buf+(bufSize/2), res);
         }
         break;

      case 114:
         xfer.control = p[1];
         if (p[3] > 512) p[3] = 512;
         xfer.txCnt = p[3];
         if (p[3]) memcpy(&xfer.txBuf, buf, p[3]);
         res = bscXfer(&xfer);
         if (res >= 0)
         {
            memcpy(buf, &res, 4);
            res = 4 + xfer.rxCnt;
            if (res > 4) memcpy(buf+4, &xfer.rxBuf, res-4);
         }
         break;

      case 112:

         memcpy(&tmp1, buf+ 0, 4);
         memcpy(&tmp2, buf+ 4, 4);
         memcpy(&tmp3, buf+ 8, 4);
         memcpy(&tmp4, buf+12, 4);
         memcpy(&tmp5, buf+16, 4);

         if (!myPermit(p[1]))
         {
            { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 1941 "pigpio.c" 3 4
           stderr
# 1941 "pigpio.c"
           , "%s %s: " "bbSPIOpen: gpio %"
# 1941 "pigpio.c" 3 4
           "l" "d"
# 1941 "pigpio.c"
           ", no permission to update CS" "\n" , myTimeStamp(), __FUNCTION__ , p[1]); }
                                                                              ;
            res = -41;
         }

         if (!myPermit(tmp1))
         {
            { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 1948 "pigpio.c" 3 4
           stderr
# 1948 "pigpio.c"
           , "%s %s: " "bbSPIOpen: gpio %d, no permission to update MISO" "\n" , myTimeStamp(), __FUNCTION__ , tmp1); }
                                                                        ;
            res = -41;
         }

         if (!myPermit(tmp2))
         {
            { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 1955 "pigpio.c" 3 4
           stderr
# 1955 "pigpio.c"
           , "%s %s: " "bbSPIOpen: gpio %d, no permission to update MOSI" "\n" , myTimeStamp(), __FUNCTION__ , tmp2); }
                                                                        ;
            res = -41;
         }

         if (!myPermit(tmp3))
         {
            { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 1962 "pigpio.c" 3 4
           stderr
# 1962 "pigpio.c"
           , "%s %s: " "bbSPIOpen: gpio %d, no permission to update SCLK" "\n" , myTimeStamp(), __FUNCTION__ , tmp3); }
                                                                        ;
            res = -41;
         }

         if (!res) res = bbSPIOpen(p[1], tmp1, tmp2, tmp3, tmp4, tmp5);
         break;

      case 111:
         res = bbSPIClose(p[1]);
         break;

      case 113:
         if (p[3] > bufSize) p[3] = bufSize;
            res = bbSPIXfer(p[1], buf, buf, p[3]);
         break;

      case 10: res = gpioRead_Bits_0_31(); break;

      case 11: res = gpioRead_Bits_32_53(); break;

      case 14:
         mask = gpioMask;

         res = gpioWrite_Bits_0_31_Set(p[1]&mask);

         if ((mask | p[1]) != mask)
         {
            { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 1990 "pigpio.c" 3 4
           stderr
# 1990 "pigpio.c"
           , "%s %s: " "gpioWrite_Bits_0_31_Set: bad bits %08"
# 1990 "pigpio.c" 3 4
           "l" "X"
# 1990 "pigpio.c"
           " (permissions %08X)" "\n" , myTimeStamp(), __FUNCTION__ , p[1], mask); }

                          ;
            res = -42;
         }
         break;

      case 15:
         mask = gpioMask>>32;

         res = gpioWrite_Bits_32_53_Set(p[1]&mask);

         if ((mask | p[1]) != mask)
         {
            { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 2004 "pigpio.c" 3 4
           stderr
# 2004 "pigpio.c"
           , "%s %s: " "gpioWrite_Bits_32_53_Set: bad bits %08"
# 2004 "pigpio.c" 3 4
           "l" "X"
# 2004 "pigpio.c"
           " (permissions %08X)" "\n" , myTimeStamp(), __FUNCTION__ , p[1], mask); }

                          ;
            res = -42;
         }
         break;

      case 87:
         res = gpioCustom1(p[1], p[2], buf, p[3]);
         break;

      case 88:

         if (p[2] > bufSize) p[2] = bufSize;
         res = gpioCustom2(p[1], buf, p[3], buf, p[2]);
         if (res > p[2]) res = p[2];
         break;

      case 95: res = gpioCfgGetInternals(); break;

      case 96: res = gpioCfgSetInternals(p[1]); break;

      case 115: res = eventMonitor(p[1], p[2]); break;

      case 116: res = eventTrigger(p[1]); break;

      case 105: res = fileClose(p[1]); break;

      case 97:
         res = gpioGlitchFilter(p[1], p[2]);
         break;

      case 109:
         if (p[1] > bufSize) p[1] = bufSize;
         res = fileList(buf, buf, p[1]);
         break;

      case 98:
         memcpy(&p[4], buf, 4);
         res = gpioNoiseFilter(p[1], p[2], p[4]);
         break;

      case 104: res = fileOpen(buf, p[1]); break;

      case 106:
         if (p[2] > bufSize) p[2] = bufSize;
         res = fileRead(p[1], buf, p[2]);
         break;

      case 108:
         memcpy(&p[4], buf, 4);
         res = fileSeek(p[1], p[2], p[4]);
         break;

      case 107: res = fileWrite(p[1], buf, p[3]); break;

      case 83: res = gpioGetPWMdutycycle(p[1]); break;

      case 84: res = gpioGetServoPulsewidth(p[1]); break;

      case 85:

         if (myPermit(p[1]&0xFFFFFF)) res = gpioHardwareClock(p[1], p[2]);
         else
         {
            { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 2069 "pigpio.c" 3 4
           stderr
# 2069 "pigpio.c"
           , "%s %s: " "gpioHardwareClock: gpio %"
# 2069 "pigpio.c" 3 4
           "l" "d"
# 2069 "pigpio.c"
           ", no permission to update" "\n" , myTimeStamp(), __FUNCTION__ , p[1] & 0xFFFFFF); }

                                ;
            res = -41;
         }
         break;

      case 25: break;

      case 86:
         if (myPermit(p[1]))
         {
            memcpy(&p[4], buf, 4);
            res = gpioHardwarePWM(p[1], p[2], p[4]);
         }
         else
         {
            { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 2086 "pigpio.c" 3 4
           stderr
# 2086 "pigpio.c"
           , "%s %s: " "gpioHardwarePWM: gpio %"
# 2086 "pigpio.c" 3 4
           "l" "d"
# 2086 "pigpio.c"
           ", no permission to update" "\n" , myTimeStamp(), __FUNCTION__ , p[1]); }
                                                                                 ;
            res = -41;
         }
         break;

      case 17: res = gpioHardwareRevision(); break;



      case 55: res = i2cClose(p[1]); break;

      case 54:
         memcpy(&p[4], buf, 4);
         res = i2cOpen(p[1], p[2], p[4]);
         break;

      case 69:
         memcpy(&p[4], buf, 4);
         res = i2cProcessCall(p[1], p[2], p[4]);
         break;

      case 70:
         res = i2cBlockProcessCall(p[1], p[2], buf, p[3]);
         break;

      case 61: res = i2cReadByteData(p[1], p[2]); break;

      case 56:
         if (p[2] > bufSize) p[2] = bufSize;
         res = i2cReadDevice(p[1], buf, p[2]);
         break;

      case 67:
         memcpy(&p[4], buf, 4);
         res = i2cReadI2CBlockData(p[1], p[2], buf, p[4]);
         break;

      case 65:
         res = i2cReadBlockData(p[1], p[2], buf);
         break;

      case 59: res = i2cReadByte(p[1]); break;

      case 63: res = i2cReadWordData(p[1], p[2]); break;

      case 62:
         memcpy(&p[4], buf, 4);
         res = i2cWriteByteData(p[1], p[2], p[4]);
         break;

      case 57:
         res = i2cWriteDevice(p[1], buf, p[3]);
         break;

      case 68:
         res = i2cWriteI2CBlockData(p[1], p[2], buf, p[3]);
         break;

      case 66:
         res = i2cWriteBlockData(p[1], p[2], buf, p[3]);
         break;

      case 58: res = i2cWriteQuick(p[1], p[2]); break;

      case 60: res = i2cWriteByte(p[1], p[2]); break;

      case 64:
         memcpy(&p[4], buf, 4);
         res = i2cWriteWordData(p[1], p[2], p[4]);
         break;

      case 92:

         if (p[3] > (bufSize/2)) p[3] = bufSize/2;
         res = i2cZip(p[1], buf, p[3], buf+(bufSize/2), bufSize/2);
         if (res > 0)
         {
            memcpy(buf, buf+(bufSize/2), res);
         }
         break;

      case 46:
         if (p[1] <= 1000000) myGpioDelay(p[1]);
         else res = -64;
         break;

      case 47:
         if (p[1] <= 60000) myGpioDelay(p[1] * 1000);
         else res = -65;
         break;

      case 1: res = gpioGetMode(p[1]); break;

      case 0:
         if (myPermit(p[1])) res = gpioSetMode(p[1], p[2]);
         else
         {
            { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 2184 "pigpio.c" 3 4
           stderr
# 2184 "pigpio.c"
           , "%s %s: " "gpioSetMode: gpio %"
# 2184 "pigpio.c" 3 4
           "l" "d"
# 2184 "pigpio.c"
           ", no permission to update" "\n" , myTimeStamp(), __FUNCTION__ , p[1]); }
                                                                             ;
            res = -41;
         }
         break;

      case 19: res = gpioNotifyBegin(p[1], p[2]); break;

      case 21: res = gpioNotifyClose(p[1]); break;

      case 18: res = gpioNotifyOpen(); break;

      case 20: res = gpioNotifyPause(p[1]); break;

      case 103: res = gpioGetPad(p[1]); break;

      case 102: res = gpioSetPad(p[1], p[2]); break;

      case 23: res = gpioGetPWMfrequency(p[1]); break;

      case 7:
         if (myPermit(p[1])) res = gpioSetPWMfrequency(p[1], p[2]);
         else
         {
            { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 2208 "pigpio.c" 3 4
           stderr
# 2208 "pigpio.c"
           , "%s %s: " "gpioSetPWMfrequency: gpio %"
# 2208 "pigpio.c" 3 4
           "l" "d"
# 2208 "pigpio.c"
           ", no permission to update" "\n" , myTimeStamp(), __FUNCTION__ , p[1]); }
                                                                                     ;
            res = -41;
         }
         break;

      case 26: res = gpioVersion(); break;

      case 22: res = gpioGetPWMrange(p[1]); break;

      case 38:
         res = gpioStoreScript(buf);
         break;

      case 39: res = gpioDeleteScript(p[1]); break;

      case 45:
         res = gpioScriptStatus(p[1], (uint32_t *)buf);
         break;

      case 40:
         res = gpioRunScript(p[1], p[3]/4, (uint32_t *)buf);
         break;

      case 41: res = gpioStopScript(p[1]); break;

      case 117:
         res = gpioUpdateScript(p[1], p[3]/4, (uint32_t *)buf);
         break;

      case 24: res = gpioGetPWMrealRange(p[1]); break;

      case 6:
         if (myPermit(p[1])) res = gpioSetPWMrange(p[1], p[2]);
         else
         {
            { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 2244 "pigpio.c" 3 4
           stderr
# 2244 "pigpio.c"
           , "%s %s: " "gpioSetPWMrange: gpio %"
# 2244 "pigpio.c" 3 4
           "l" "d"
# 2244 "pigpio.c"
           ", no permission to update" "\n" , myTimeStamp(), __FUNCTION__ , p[1]); }
                                                                                 ;
            res = -41;
         }
         break;

      case 2:
         if (myPermit(p[1])) res = gpioSetPullUpDown(p[1], p[2]);
         else
         {
            { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 2254 "pigpio.c" 3 4
           stderr
# 2254 "pigpio.c"
           , "%s %s: " "gpioSetPullUpDown: gpio %"
# 2254 "pigpio.c" 3 4
           "l" "d"
# 2254 "pigpio.c"
           ", no permission to update" "\n" , myTimeStamp(), __FUNCTION__ , p[1]); }
                                                                                   ;
            res = -41;
         }
         break;

      case 5:
         if (myPermit(p[1])) res = gpioPWM(p[1], p[2]);
         else
         {
            { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 2264 "pigpio.c" 3 4
           stderr
# 2264 "pigpio.c"
           , "%s %s: " "gpioPWM: gpio %"
# 2264 "pigpio.c" 3 4
           "l" "d"
# 2264 "pigpio.c"
           ", no permission to update" "\n" , myTimeStamp(), __FUNCTION__ , p[1]); };
            res = -41;
         }
         break;

      case 3: res = gpioRead(p[1]); break;

      case 8:
         if (myPermit(p[1])) res = gpioServo(p[1], p[2]);
         else
         {
            { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 2275 "pigpio.c" 3 4
           stderr
# 2275 "pigpio.c"
           , "%s %s: " "gpioServo: gpio %"
# 2275 "pigpio.c" 3 4
           "l" "d"
# 2275 "pigpio.c"
           ", no permission to update" "\n" , myTimeStamp(), __FUNCTION__ , p[1]); }
                                                                           ;
            res = -41;
         }
         break;



      case 78: res = serReadByte(p[1]); break;

      case 79: res = serWriteByte(p[1], p[2]); break;

      case 77: res = serClose(p[1]); break;

      case 82: res = serDataAvailable(p[1]); break;

      case 76: res = serOpen(buf, p[1], p[2]); break;

      case 80:
         if (p[2] > bufSize) p[2] = bufSize;
         res = serRead(p[1], buf, p[2]);
         break;

      case 81: res = serWrite(p[1], buf, p[3]); break;


      case 110:
          res = shell(buf, buf+p[1]+1);
          break;


      case 43:
         if (p[2] > bufSize) p[2] = bufSize;
         res = gpioSerialRead(p[1], buf, p[2]);
         break;

      case 44: res = gpioSerialReadClose(p[1]); break;

      case 42:
         memcpy(&p[4], buf, 4);
         res = gpioSerialReadOpen(p[1], p[2], p[4]); break;

      case 94: res = gpioSerialReadInvert(p[1], p[2]); break;

      case 72:
         res = spiClose(p[1]);
         break;

      case 71:
         memcpy(&p[4], buf, 4);
         res = spiOpen(p[1], p[2], p[4]);
         break;

      case 73:
         if (p[2] > bufSize) p[2] = bufSize;
         res = spiRead(p[1], buf, p[2]);
         break;

      case 74:
         if (p[3] > bufSize) p[3] = bufSize;
         res = spiWrite(p[1], buf, p[3]);
         break;

      case 75:
         if (p[3] > bufSize) p[3] = bufSize;
         res = spiXfer(p[1], buf, buf, p[3]);
         break;

      case 16: res = gpioTick(); break;

      case 37:
         if (myPermit(p[1]))
         {
            memcpy(&p[4], buf, 4);
            res = gpioTrigger(p[1], p[2], p[4]);
         }
         else
         {
            { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 2353 "pigpio.c" 3 4
           stderr
# 2353 "pigpio.c"
           , "%s %s: " "gpioTrigger: gpio %"
# 2353 "pigpio.c" 3 4
           "l" "d"
# 2353 "pigpio.c"
           ", no permission to update" "\n" , myTimeStamp(), __FUNCTION__ , p[1]); }
                                                                             ;
            res = -41;
         }
         break;

      case 9: res = gpioSetWatchdog(p[1], p[2]); break;

      case 4:
         if (myPermit(p[1])) res = gpioWrite(p[1], p[2]);
         else
         {
            { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 2365 "pigpio.c" 3 4
           stderr
# 2365 "pigpio.c"
           , "%s %s: " "gpioWrite: gpio %"
# 2365 "pigpio.c" 3 4
           "l" "d"
# 2365 "pigpio.c"
           ", no permission to update" "\n" , myTimeStamp(), __FUNCTION__ , p[1]); };
            res = -41;
         }
         break;



      case 28:



         mask = gpioMask;
         pulse = (gpioPulse_t *)buf;
         j = p[3]/sizeof(gpioPulse_t);
         masked = 0;

         for (i=0; i<j; i++)
         {
            tmp1 = pulse[i].gpioOn & mask;
            if (tmp1 != pulse[i].gpioOn)
            {
               pulse[i].gpioOn = tmp1;
               masked = 1;
            }

            tmp1 = pulse[i].gpioOff & mask;
            if (tmp1 != pulse[i].gpioOff)
            {
               pulse[i].gpioOff = tmp1;
               masked = 1;
            }
            { if ((gpioCfg.dbgLevel >= 3) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 2396 "pigpio.c" 3 4
           stderr
# 2396 "pigpio.c"
           , "%s %s: " "on=%X off=%X delay=%d" "\n" , myTimeStamp(), __FUNCTION__ , pulse[i].gpioOn, pulse[i].gpioOff, pulse[i].usDelay); }
                                                                   ;
         }

         res = gpioWaveAddGeneric(j, pulse);


         if (masked && (res >= 0)) res = -42;

         break;

      case 29:
         if (myPermit(p[1]))
         {
            memcpy(&tmp1, buf, 4);
            memcpy(&tmp2, buf+4, 4);
            memcpy(&tmp3, buf+8, 4);
            res = gpioWaveAddSerial
               (p[1], p[2], tmp1, tmp2, tmp3, p[3]-12, buf+12);
         }
         else
         {
            { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 2418 "pigpio.c" 3 4
           stderr
# 2418 "pigpio.c"
           , "%s %s: " "gpioWaveAddSerial: gpio %"
# 2418 "pigpio.c" 3 4
           "l" "d"
# 2418 "pigpio.c"
           ", no permission to update" "\n" , myTimeStamp(), __FUNCTION__ , p[1]); }

                                                                                   ;
            res = -41;
         }
         break;

      case 32: res = gpioWaveTxBusy(); break;

      case 93:
         if (p[3] > bufSize) p[3] = bufSize;
         res = gpioWaveChain(buf, p[3]);
         break;


      case 27: res = gpioWaveClear(); break;

      case 49: res = gpioWaveCreate(); break;

      case 50: res = gpioWaveDelete(p[1]); break;

      case 30: res = gpioWaveTxStart(0); break;

      case 31: res = gpioWaveTxStart(1); break;

      case 33: res = gpioWaveTxStop(); break;

      case 53: res = gpioWaveAddNew(); break;

      case 36:
         switch(p[1])
         {
            case 0: res = gpioWaveGetCbs(); break;
            case 1: res = gpioWaveGetHighCbs(); break;
            case 2: res = gpioWaveGetMaxCbs(); break;
            default: res = -43;
         }
         break;

      case 34:
         switch(p[1])
         {
            case 0: res = gpioWaveGetMicros(); break;
            case 1: res = gpioWaveGetHighMicros(); break;
            case 2: res = gpioWaveGetMaxMicros(); break;
            default: res = -44;
         }
         break;

      case 35:
         switch(p[1])
         {
            case 0: res = gpioWaveGetPulses(); break;
            case 1: res = gpioWaveGetHighPulses(); break;
            case 2: res = gpioWaveGetMaxPulses(); break;
            default: res = -45;
         }
         break;

      case 101: res = gpioWaveTxAt(); break;

      case 51:
         res = gpioWaveTxSend(p[1], 0); break;

      case 100:
         res = gpioWaveTxSend(p[1], p[2]); break;

      case 52:
         res = gpioWaveTxSend(p[1], 1); break;

      default:
         res = -88;
         break;
   }

   return res;
}



static void mySetGpioOff(unsigned gpio, int pos)
{
   int page, slot;

   myOffPageSlot(pos, &page, &slot);

   dmaIVirt[page]->gpioOff[slot] |= (1<<gpio);
}



static void myClearGpioOff(unsigned gpio, int pos)
{
   int page, slot;

   myOffPageSlot(pos, &page, &slot);

   dmaIVirt[page]->gpioOff[slot] &= ~(1<<gpio);
}



static void mySetGpioOn(unsigned gpio, int pos)
{
   int page, slot;

   page = pos/2;
   slot = pos%2;

   dmaIVirt[page]->gpioOn[slot] |= (1<<gpio);
}



static void myClearGpioOn(unsigned gpio, int pos)
{
   int page, slot;

   page = pos/2;
   slot = pos%2;

   dmaIVirt[page]->gpioOn[slot] &= ~(1<<gpio);
}



static void myGpioSetPwm(unsigned gpio, int oldVal, int newVal)
{
   int switchGpioOff;
   int newOff, oldOff, realRange, cycles, i;
   int deferOff, deferRng;

   { if ((gpioCfg.dbgLevel >= 5) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 2550 "pigpio.c" 3 4
  stderr
# 2550 "pigpio.c"
  , "%s %s: " "myGpioSetPwm %d from %d to %d" "\n" , myTimeStamp(), __FUNCTION__ , gpio, oldVal, newVal); }
                                                            ;

   switchGpioOff = 0;

   realRange = pwmRealRange[gpioInfo[gpio].freqIdx];

   cycles = pwmCycles [gpioInfo[gpio].freqIdx];

   newOff = (newVal * realRange)/gpioInfo[gpio].range;
   oldOff = (oldVal * realRange)/gpioInfo[gpio].range;

   deferOff = gpioInfo[gpio].deferOff;
   deferRng = gpioInfo[gpio].deferRng;

   if (gpioInfo[gpio].deferOff)
   {
      for (i=0; i<20000; i+=deferRng)
      {
         myClearGpioOff(gpio, i+deferOff);
      }
      gpioInfo[gpio].deferOff = 0;
   }

   if (newOff != oldOff)
   {
      if (newOff && oldOff)
      {
         if (newOff != realRange)
         {
            for (i=0; i<20000; i+=realRange) mySetGpioOff(gpio, i+newOff);
         }

         if (newOff > oldOff)
         {
            for (i=0; i<20000; i+=realRange)
               myClearGpioOff(gpio, i+oldOff);
         }
         else
         {
            gpioInfo[gpio].deferOff = oldOff;
            gpioInfo[gpio].deferRng = realRange;
         }
      }
      else if (newOff)
      {
         if (newOff != realRange)
         {
            for (i=0; i<20000; i+=realRange) mySetGpioOff(gpio, i+newOff);
         }



         for (i=0; i<800; i+=cycles) mySetGpioOn(gpio, i);
      }
      else
      {


         for (i=0; i<800; i+=cycles)
            myClearGpioOn(gpio, i);

         for (i=0; i<20000; i+=realRange)
            myClearGpioOff(gpio, i+oldOff);

         switchGpioOff = 1;
      }

      if (switchGpioOff)
      {
         *(gpioReg + 10) = (1<<gpio);
         *(gpioReg + 10) = (1<<gpio);
      }
   }
}



static void myGpioSetServo(unsigned gpio, int oldVal, int newVal)
{
   int newOff, oldOff, realRange, cycles, i;
   int deferOff, deferRng;

   { if ((gpioCfg.dbgLevel >= 5) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 2633 "pigpio.c" 3 4
  stderr
# 2633 "pigpio.c"
  , "%s %s: " "myGpioSetServo %d from %d to %d" "\n" , myTimeStamp(), __FUNCTION__ , gpio, oldVal, newVal); }
                                                              ;

   realRange = pwmRealRange[clkCfg[gpioCfg.clockMicros].servoIdx];
   cycles = pwmCycles [clkCfg[gpioCfg.clockMicros].servoIdx];

   newOff = (newVal * realRange)/20000;
   oldOff = (oldVal * realRange)/20000;

   deferOff = gpioInfo[gpio].deferOff;
   deferRng = gpioInfo[gpio].deferRng;

   if (gpioInfo[gpio].deferOff)
   {
      for (i=0; i<20000; i+=deferRng)
      {
         myClearGpioOff(gpio, i+deferOff);
      }
      gpioInfo[gpio].deferOff = 0;
   }

   if (newOff != oldOff)
   {
      if (newOff && oldOff)
      {
         for (i=0; i<20000; i+=realRange)
            mySetGpioOff(gpio, i+newOff);

         if (newOff > oldOff)
         {
            for (i=0; i<20000; i+=realRange)
               myClearGpioOff(gpio, i+oldOff);
         }
         else
         {
            gpioInfo[gpio].deferOff = oldOff;
            gpioInfo[gpio].deferRng = realRange;
         }
      }
      else if (newOff)
      {
         for (i=0; i<20000; i+=realRange)
            mySetGpioOff(gpio, i+newOff);



         for (i=0; i<800; i+=cycles) mySetGpioOn(gpio, i);
      }
      else
      {


         for (i=0; i<800; i+=cycles)
            myClearGpioOn(gpio, i);



         if (myGpioRead(gpio)) myGpioDelay(2500);



         for (i=0; i<20000; i+=realRange)
            myClearGpioOff(gpio, i+oldOff);
      }
   }
}







static int mbCreate(char *dev)
{


   unlink(dev);

   return mknod(dev, 
# 2712 "pigpio.c" 3 4
                    0020000
# 2712 "pigpio.c"
                           |0600, 
# 2712 "pigpio.c" 3 4
                                  gnu_dev_makedev (
# 2712 "pigpio.c"
                                  100
# 2712 "pigpio.c" 3 4
                                  , 
# 2712 "pigpio.c"
                                  0
# 2712 "pigpio.c" 3 4
                                  )
# 2712 "pigpio.c"
                                                          );
}

static int mbOpen(void)
{


   int fd;

   fd = open("/dev/vcio", 0);

   if (fd < 0)
   {
      mbCreate("/dev/pigpio-mb");
      fd = open("/dev/pigpio-mb", 0);
   }
   return fd;
}

static void mbClose(int fd)
{
   close(fd);
}

static int mbProperty(int fd, void *buf)
{
   return ioctl(fd, 
# 2738 "pigpio.c" 3 4
                   (((2U|1U) << (((0 +8)+8)+14)) | (((
# 2738 "pigpio.c"
                   100
# 2738 "pigpio.c" 3 4
                   )) << (0 +8)) | (((
# 2738 "pigpio.c"
                   0
# 2738 "pigpio.c" 3 4
                   )) << 0) | ((((sizeof(
# 2738 "pigpio.c"
                   char *
# 2738 "pigpio.c" 3 4
                   )))) << ((0 +8)+8)))
# 2738 "pigpio.c"
                           , buf);
}

static unsigned mbAllocateMemory(
   int fd, unsigned size, unsigned align, unsigned flags)
{
   int i=1;
   unsigned p[32];

   p[i++] = 0;
   p[i++] = 0x3000C;
   p[i++] = 12;
   p[i++] = 12;
   p[i++] = size;
   p[i++] = align;
   p[i++] = flags;
   p[i++] = 0;
   p[0] = i*sizeof(*p);

   mbProperty(fd, p);

   return p[5];
}

static unsigned mbLockMemory(int fd, unsigned handle)
{
   int i=1;
   unsigned p[32];

   p[i++] = 0;
   p[i++] = 0x3000D;
   p[i++] = 4;
   p[i++] = 4;
   p[i++] = handle;
   p[i++] = 0;
   p[0] = i*sizeof(*p);

   mbProperty(fd, p);

   return p[5];
}

static unsigned mbUnlockMemory(int fd, unsigned handle)
{
   int i=1;
   unsigned p[32];

   p[i++] = 0;
   p[i++] = 0x3000E;
   p[i++] = 4;
   p[i++] = 4;
   p[i++] = handle;
   p[i++] = 0;
   p[0] = i*sizeof(*p);

   mbProperty(fd, p);

   return p[5];
}

static unsigned mbReleaseMemory(int fd, unsigned handle)
{
   int i=1;
   unsigned p[32];

   p[i++] = 0;
   p[i++] = 0x3000F;
   p[i++] = 4;
   p[i++] = 4;
   p[i++] = handle;
   p[i++] = 0;
   p[0] = i*sizeof(*p);

   mbProperty(fd, p);

   return p[5];
}

static void *mbMapMem(unsigned base, unsigned size)
{
   void *mem = 
# 2818 "pigpio.c" 3 4
              ((void *) -1)
# 2818 "pigpio.c"
                        ;

   mem = mmap(0, size, 
# 2820 "pigpio.c" 3 4
                      0x1
# 2820 "pigpio.c"
                               |
# 2820 "pigpio.c" 3 4
                                0x2
# 2820 "pigpio.c"
                                          , 
# 2820 "pigpio.c" 3 4
                                            0x01
# 2820 "pigpio.c"
                                                      , fdMem, base);

   return mem;
}

static int mbUnmapMem(void *addr, unsigned size)
{

   return munmap(addr, size);
}

static void mbDMAFree(DMAMem_t *DMAMemP)
{
   if (DMAMemP->handle)
   {
      mbUnmapMem(DMAMemP->virtual_addr, DMAMemP->size);
      mbUnlockMemory(fdMbox, DMAMemP->handle);
      mbReleaseMemory(fdMbox, DMAMemP->handle);
      DMAMemP->handle = 0;
   }
}

static int mbDMAAlloc(DMAMem_t *DMAMemP, unsigned size, uint32_t pi_mem_flag)
{
   DMAMemP->size = size;

   DMAMemP->handle =
      mbAllocateMemory(fdMbox, size, 4096, pi_mem_flag);

   if (DMAMemP->handle)
   {
      DMAMemP->bus_addr = mbLockMemory(fdMbox, DMAMemP->handle);

      DMAMemP->virtual_addr =
         mbMapMem(((DMAMemP->bus_addr)&~0xC0000000), size);

      return 1;
   }
   return 0;
}




rawCbs_t * rawWaveCBAdr(int cbNum)
{
   int page, slot;

   page = cbNum/118;
   slot = cbNum%118;

   return &dmaOVirt[page]->cb[slot];
}




static uint32_t waveCbPOadr(int pos)
{
   int page, slot;

   page = pos/118;
   slot = pos%118;



   return (uint32_t)(uintptr_t) &dmaOBus[page]->cb[slot];
}



static void waveOOLPageSlot(int pos, int *page, int *slot)
{
   *page = pos/79;
   *slot = pos%79;
}




static void waveSetOOL(int pos, uint32_t OOL)
{
   int page, slot;

   waveOOLPageSlot(pos, &page, &slot);

   dmaOVirt[page]->OOL[slot] = OOL;
}



static uint32_t waveOOLPOadr(int pos)
{
   int page, slot;

   waveOOLPageSlot(pos, &page, &slot);



   return (uint32_t)(uintptr_t) &dmaOBus[page]->OOL[slot];
}




static void waveBitDelay
   (unsigned baud, unsigned bits, unsigned stops, unsigned *bitDelay)
{
   unsigned fullBit, last, diff, t, i;



   fullBit = 1000000000 / baud;
   last = 0;

   for (i=0; i<=bits; i++)
   {
      t = (((i+1)*fullBit)+500)/1000;
      diff = t - last;
      last = t;
      bitDelay[i] = diff;
   }

   t = (((bits+1)*fullBit) + ((stops*fullBit)/2) + 500)/1000;
   diff = t - last;
   bitDelay[i] = diff;
}

static int waveDelayCBs(uint32_t delay)
{
   uint32_t cbs;

   if (!delay) return 0;
   if (gpioCfg.DMAsecondaryChannel < 7) return 1;
   cbs = 4 * delay / 0xfffc;
   if ((4 * delay) % 0xfffc) cbs++;
   return cbs;
}



static void waveCBsOOLs(int *numCBs, int *numBOOLs, int *numTOOLs)
{
   int numCB=0, numBOOL=0, numTOOL=0;

   unsigned i;

   unsigned numWaves;

   rawWave_t *waves;

   numWaves = wfc[wfcur];
   waves = wf [wfcur];



   numCB++;

   for (i=0; i<numWaves; i++)
   {
      if (waves[i].gpioOn) {numCB++; numBOOL++;}
      if (waves[i].gpioOff) {numCB++; numBOOL++;}
      if (waves[i].flags & 1) {numCB++; numTOOL++;}
      if (waves[i].flags & 2) {numCB++; numTOOL++;}

      numCB += waveDelayCBs(waves[i].usDelay);
   }

   *numCBs = numCB;
   *numBOOLs = numBOOL;
   *numTOOLs = numTOOL;
}



static int wave2Cbs(unsigned wave_mode, int *CB, int *BOOL, int *TOOL)
{
   int botCB=*CB, botOOL=*BOOL, topOOL=*TOOL;

   int status;

   rawCbs_t *p=
# 3001 "pigpio.c" 3 4
              ((void *)0)
# 3001 "pigpio.c"
                  ;

   unsigned i, repeatCB;

   unsigned numWaves;

   unsigned delayCBs, dcb;

   uint32_t delayLeft;

   rawWave_t * waves;

   numWaves = wfc[wfcur];
   waves = wf [wfcur];



   p = rawWaveCBAdr(botCB++);



   if (gpioCfg.clockPeriph != 1)
   {
      p->info = ((1<<26) | (1<< 3)) | ((1<< 6) | ((2)<<16));
      p->dst = ((((pi_peri_phys + 0x00203000) + 1*4) & 0x00ffffff) | 0x7E000000);
   }
   else
   {
      p->info = ((1<<26) | (1<< 3)) | ((1<< 6) | ((5)<<16));
      p->dst = ((((pi_peri_phys + 0x0020C000) + 6*4) & 0x00ffffff) | 0x7E000000);
   }



   p->src = (uint32_t)(uintptr_t) (&dmaOBus[0]->periphData);
   p->length = 4 * 20 / 1;
   p->next = waveCbPOadr(botCB);

   repeatCB = botCB;

   for (i=0; i<numWaves; i++)
   {
      if (waves[i].gpioOn)
      {
         waveSetOOL(botOOL, waves[i].gpioOn);

         p = rawWaveCBAdr(botCB++);

         p->info = ((1<<26) | (1<< 3));
         p->src = waveOOLPOadr(botOOL++);
         p->dst = (((pi_peri_phys + 0x00200000) + (7*4)) & 0x00ffffff) | 0x7E000000;
         p->length = 4;
         p->next = waveCbPOadr(botCB);
      }

      if (waves[i].gpioOff)
      {
         waveSetOOL(botOOL, waves[i].gpioOff);

         p = rawWaveCBAdr(botCB++);

         p->info = ((1<<26) | (1<< 3));
         p->src = waveOOLPOadr(botOOL++);
         p->dst = (((pi_peri_phys + 0x00200000) + (10*4)) & 0x00ffffff) | 0x7E000000;
         p->length = 4;
         p->next = waveCbPOadr(botCB);
      }

      if (waves[i].flags & 1)
      {
         p = rawWaveCBAdr(botCB++);

         p->info = ((1<<26) | (1<< 3));
         p->src = (((pi_peri_phys + 0x00200000) + (13*4)) & 0x00ffffff) | 0x7E000000;
         p->dst = waveOOLPOadr(--topOOL);
         p->length = 4;
         p->next = waveCbPOadr(botCB);
      }

      if (waves[i].flags & 2)
      {
         p = rawWaveCBAdr(botCB++);

         p->info = ((1<<26) | (1<< 3));
         p->src = (((pi_peri_phys + 0x00003000) + (1*4)) & 0x00ffffff) | 0x7E000000;
         p->dst = waveOOLPOadr(--topOOL);
         p->length = 4;
         p->next = waveCbPOadr(botCB);
      }

      if (waves[i].usDelay)
      {
         delayLeft = waves[i].usDelay;

         delayCBs = waveDelayCBs(delayLeft);

         for (dcb=0; dcb<delayCBs; dcb++)
         {
            p = rawWaveCBAdr(botCB++);



            if (gpioCfg.clockPeriph != 1)
            {
               p->info = ((1<<26) | (1<< 3)) | ((1<< 6) | ((2)<<16));
               p->dst = ((((pi_peri_phys + 0x00203000) + 1*4) & 0x00ffffff) | 0x7E000000);
            }
            else
            {
               p->info = ((1<<26) | (1<< 3)) | ((1<< 6) | ((5)<<16));
               p->dst = ((((pi_peri_phys + 0x0020C000) + 6*4) & 0x00ffffff) | 0x7E000000);
            }



            p->src = (uint32_t)(uintptr_t) (&dmaOBus[0]->periphData);

            p->length = 4 * delayLeft / 1;

            if ((gpioCfg.DMAsecondaryChannel >= 7) &&
                (p->length > 0xfffc))
            {
               p->length = 0xfffc;
            }

            delayLeft -= (p->length / 4);

            p->next = waveCbPOadr(botCB);
         }
      }
   }

   if (p != 
# 3133 "pigpio.c" 3 4
           ((void *)0)
# 3133 "pigpio.c"
               )
   {
      if (wave_mode == 0)
           p->next = 0;
      else p->next = waveCbPOadr(repeatCB);
   }

   status = botCB - *CB;

   *CB = botCB;
   *BOOL = botOOL;
   *TOOL = topOOL;

   return status;
}



static void waveRxSerial(wfRx_t *w, int level, uint32_t tick)
{
   int diffTicks, lastLevel;
   int newWritePos;

   level = level ^ w->s.invert;

   if (w->s.bit >= 0)
   {
      diffTicks = tick - w->s.startBitTick;

      if (level != 2)
      {
         w->s.level = level;
         lastLevel = !level;
      }
      else lastLevel = w->s.level;

      while ((w->s.bit <= w->s.dataBits) &&
             (diffTicks > (w->s.nextBitDiff/1000)))
      {
         if (w->s.bit)
         {
            if (lastLevel) w->s.data |= (1<<(w->s.bit-1));
         }
         else w->s.data = 0;

         ++(w->s.bit);

         w->s.nextBitDiff += w->s.fullBit;
      }

      if (w->s.bit > w->s.dataBits)
      {
         memcpy(w->s.buf + w->s.writePos, &w->s.data, w->s.bytes);



         newWritePos = (w->s.writePos + w->s.bytes) % (w->s.bufSize);

         if (newWritePos != w->s.readPos) w->s.writePos = newWritePos;

         if (level == 0)
         {
            gpioSetWatchdog(w->gpio, w->s.timeout);
            w->s.bit = 0;
            w->s.startBitTick = tick;
            w->s.nextBitDiff = w->s.halfBit;
         }
         else
         {
            w->s.bit = -1;
            gpioSetWatchdog(w->gpio, 0);
         }
      }
   }
   else
   {


      if (level == 0)
      {
         gpioSetWatchdog(w->gpio, w->s.timeout);
         w->s.level = 0;
         w->s.bit = 0;
         w->s.startBitTick = tick;
         w->s.nextBitDiff = w->s.halfBit;
      }
   }
}




static void waveRxBit(int gpio, int level, uint32_t tick)
{
   switch (wfRx[gpio].mode)
   {
      case 1:
         waveRxSerial(&wfRx[gpio], level, tick);
   }
}




int rawWaveAddGeneric(unsigned numIn1, rawWave_t *in1)
{
   unsigned inPos1=0, inPos2=0, outPos=0, level = ((53 * 4) * 79);

   unsigned cbs=0;

   unsigned numIn2, numOut;

   uint32_t tNow, tNext1, tNext2, tDelay, tMax;

   rawWave_t *in2, *out;

   numIn2 = wfc[wfcur];
   in2 = wf[wfcur];

   numOut = (4 * 3000);
   out = wf[1-wfcur];

   tNow = 0;
   tMax = 0;

   if (!numIn1) tNext1 = -1; else tNext1 = 0;
   if (!numIn2) tNext2 = -1; else tNext2 = 0;

   while (((inPos1<numIn1) || (inPos2<numIn2)) && (outPos<numOut))
   {
      if (tNext1 < tNext2)
      {


         if (tNow < tNext1)
         {

            out[outPos-1].usDelay += (tNext1 - tNow);
            tNow = tNext1;
         }

         out[outPos].gpioOn = in1[inPos1].gpioOn;
         out[outPos].gpioOff = in1[inPos1].gpioOff;
         out[outPos].flags = in1[inPos1].flags;

         tNext1 = tNow + in1[inPos1].usDelay; ++inPos1;
         if (tMax < tNext1) tMax = tNext1;
      }
      else if (tNext2 < tNext1)
      {


         if (tNow < tNext2)
         {

            out[outPos-1].usDelay += (tNext2 - tNow);
            tNow = tNext2;
         }

         out[outPos].gpioOn = in2[inPos2].gpioOn;
         out[outPos].gpioOff = in2[inPos2].gpioOff;
         out[outPos].flags = in2[inPos2].flags;

         tNext2 = tNow + in2[inPos2].usDelay; ++inPos2;
         if (tMax < tNext2) tMax = tNext2;
      }
      else
      {


         if (tNow < tNext1)
         {

            out[outPos-1].usDelay += (tNext1 - tNow);
            tNow = tNext1;
         }

         out[outPos].gpioOn = in1[inPos1].gpioOn | in2[inPos2].gpioOn;
         out[outPos].gpioOff = in1[inPos1].gpioOff | in2[inPos2].gpioOff;
         out[outPos].flags = in1[inPos1].flags | in2[inPos2].flags;

         tNext1 = tNow + in1[inPos1].usDelay; ++inPos1;
         tNext2 = tNow + in2[inPos2].usDelay; ++inPos2;
         if (tMax < tNext1) tMax = tNext1;
         if (tMax < tNext2) tMax = tNext2;
      }

      if (tNext1 <= tNext2) { tDelay = tNext1 - tNow; tNow = tNext1; }
      else { tDelay = tNext2 - tNow; tNow = tNext2; }

      out[outPos].usDelay = tDelay;

      cbs += waveDelayCBs(tDelay);

      if (out[outPos].gpioOn) cbs++;

      if (out[outPos].gpioOff) cbs++;

      if (out[outPos].flags & 1)
      {
         cbs++;
         --level;
      }

      if (out[outPos].flags & 2)
      {
         cbs++;
         --level;
      }

      outPos++;

      if (inPos1 >= numIn1) tNext1 = -1;
      if (inPos2 >= numIn2) tNext2 = -1;

   }

   if (tNow < tMax)
   {

      out[outPos-1].usDelay += (tMax - tNow);
      tNow = tMax;
   }

   if ((outPos < numOut) && (outPos < level))
   {
      wfStats.micros = tNow;

      if (tNow > wfStats.highMicros) wfStats.highMicros = tNow;

      wfStats.pulses = outPos;

      if (outPos > wfStats.highPulses) wfStats.highPulses = outPos;

      wfStats.cbs = cbs;

      if (cbs > wfStats.highCbs) wfStats.highCbs = cbs;

      wfc[1-wfcur] = outPos;
      wfcur = 1 - wfcur;

      return outPos;
   }
   else return -36;
}



int i2cWriteQuick(unsigned handle, unsigned bit)
{
   int status;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3385 "pigpio.c" 3 4
  stderr
# 3385 "pigpio.c"
  , "%s %s: " "handle=%d bit=%d" "\n" , myTimeStamp(), __FUNCTION__ , handle, bit); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3387 "pigpio.c" 3 4
  stderr
# 3387 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (handle >= 512)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3390 "pigpio.c" 3 4
     stderr
# 3390 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (i2cInfo[handle].state != 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3393 "pigpio.c" 3 4
     stderr
# 3393 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if ((i2cInfo[handle].funcs & 0x00010000) == 0)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3396 "pigpio.c" 3 4
     stderr
# 3396 "pigpio.c"
     , "%s %s: " "SMBUS command not supported by driver" "\n" , myTimeStamp(), __FUNCTION__); }; return -107; } while (0);

   if (bit > 1)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3399 "pigpio.c" 3 4
     stderr
# 3399 "pigpio.c"
     , "%s %s: " "bad bit (%d)" "\n" , myTimeStamp(), __FUNCTION__ , bit); }; return -81; } while (0);

   status = my_smbus_access(
      i2cInfo[handle].fd, bit, 0, 0, 
# 3402 "pigpio.c" 3 4
                                                     ((void *)0)
# 3402 "pigpio.c"
                                                         );

   if (status < 0)
   {
      { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3406 "pigpio.c" 3 4
     stderr
# 3406 "pigpio.c"
     , "%s %s: " "error=%d (%m)" "\n" , myTimeStamp(), __FUNCTION__ , status); };
      return -82;
   }

   return status;
}

int i2cReadByte(unsigned handle)
{
   union my_smbus_data data;
   int status;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3418 "pigpio.c" 3 4
  stderr
# 3418 "pigpio.c"
  , "%s %s: " "handle=%d" "\n" , myTimeStamp(), __FUNCTION__ , handle); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3420 "pigpio.c" 3 4
  stderr
# 3420 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (handle >= 512)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3423 "pigpio.c" 3 4
     stderr
# 3423 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (i2cInfo[handle].state != 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3426 "pigpio.c" 3 4
     stderr
# 3426 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if ((i2cInfo[handle].funcs & 0x00020000) == 0)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3429 "pigpio.c" 3 4
     stderr
# 3429 "pigpio.c"
     , "%s %s: " "SMBUS command not supported by driver" "\n" , myTimeStamp(), __FUNCTION__); }; return -107; } while (0);

   status = my_smbus_access(
      i2cInfo[handle].fd, 1, 0, 1, &data);

   if (status < 0)
   {
      { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3436 "pigpio.c" 3 4
     stderr
# 3436 "pigpio.c"
     , "%s %s: " "error=%d (%m)" "\n" , myTimeStamp(), __FUNCTION__ , status); };
      return -83;
   }

   return 0xFF & data.byte;
}


int i2cWriteByte(unsigned handle, unsigned bVal)
{
   int status;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3448 "pigpio.c" 3 4
  stderr
# 3448 "pigpio.c"
  , "%s %s: " "handle=%d bVal=%d" "\n" , myTimeStamp(), __FUNCTION__ , handle, bVal); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3450 "pigpio.c" 3 4
  stderr
# 3450 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (handle >= 512)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3453 "pigpio.c" 3 4
     stderr
# 3453 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (i2cInfo[handle].state != 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3456 "pigpio.c" 3 4
     stderr
# 3456 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if ((i2cInfo[handle].funcs & 0x00040000) == 0)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3459 "pigpio.c" 3 4
     stderr
# 3459 "pigpio.c"
     , "%s %s: " "SMBUS command not supported by driver" "\n" , myTimeStamp(), __FUNCTION__); }; return -107; } while (0);

   if (bVal > 0xFF)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3462 "pigpio.c" 3 4
     stderr
# 3462 "pigpio.c"
     , "%s %s: " "bad bVal (%d)" "\n" , myTimeStamp(), __FUNCTION__ , bVal); }; return -81; } while (0);

   status = my_smbus_access(
            i2cInfo[handle].fd,
            0,
            bVal,
            1,
            
# 3469 "pigpio.c" 3 4
           ((void *)0)
# 3469 "pigpio.c"
               );

   if (status < 0)
   {
      { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3473 "pigpio.c" 3 4
     stderr
# 3473 "pigpio.c"
     , "%s %s: " "error=%d (%m)" "\n" , myTimeStamp(), __FUNCTION__ , status); };
      return -82;
   }

   return status;
}


int i2cReadByteData(unsigned handle, unsigned reg)
{
   union my_smbus_data data;
   int status;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3486 "pigpio.c" 3 4
  stderr
# 3486 "pigpio.c"
  , "%s %s: " "handle=%d reg=%d" "\n" , myTimeStamp(), __FUNCTION__ , handle, reg); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3488 "pigpio.c" 3 4
  stderr
# 3488 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (handle >= 512)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3491 "pigpio.c" 3 4
     stderr
# 3491 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (i2cInfo[handle].state != 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3494 "pigpio.c" 3 4
     stderr
# 3494 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if ((i2cInfo[handle].funcs & 0x00080000) == 0)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3497 "pigpio.c" 3 4
     stderr
# 3497 "pigpio.c"
     , "%s %s: " "SMBUS command not supported by driver" "\n" , myTimeStamp(), __FUNCTION__); }; return -107; } while (0);

   if (reg > 0xFF)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3500 "pigpio.c" 3 4
     stderr
# 3500 "pigpio.c"
     , "%s %s: " "bad reg (%d)" "\n" , myTimeStamp(), __FUNCTION__ , reg); }; return -81; } while (0);

   status = my_smbus_access(i2cInfo[handle].fd,
            1, reg, 2, &data);

   if (status < 0)
   {
      { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3507 "pigpio.c" 3 4
     stderr
# 3507 "pigpio.c"
     , "%s %s: " "error=%d (%m)" "\n" , myTimeStamp(), __FUNCTION__ , status); };
      return -83;
   }

   return 0xFF & data.byte;
}


int i2cWriteByteData(unsigned handle, unsigned reg, unsigned bVal)
{
   union my_smbus_data data;

   int status;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3521 "pigpio.c" 3 4
  stderr
# 3521 "pigpio.c"
  , "%s %s: " "handle=%d reg=%d bVal=%d" "\n" , myTimeStamp(), __FUNCTION__ , handle, reg, bVal); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3523 "pigpio.c" 3 4
  stderr
# 3523 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (handle >= 512)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3526 "pigpio.c" 3 4
     stderr
# 3526 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (i2cInfo[handle].state != 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3529 "pigpio.c" 3 4
     stderr
# 3529 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if ((i2cInfo[handle].funcs & 0x00100000) == 0)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3532 "pigpio.c" 3 4
     stderr
# 3532 "pigpio.c"
     , "%s %s: " "SMBUS command not supported by driver" "\n" , myTimeStamp(), __FUNCTION__); }; return -107; } while (0);

   if (reg > 0xFF)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3535 "pigpio.c" 3 4
     stderr
# 3535 "pigpio.c"
     , "%s %s: " "bad reg (%d)" "\n" , myTimeStamp(), __FUNCTION__ , reg); }; return -81; } while (0);

   if (bVal > 0xFF)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3538 "pigpio.c" 3 4
     stderr
# 3538 "pigpio.c"
     , "%s %s: " "bad bVal (%d)" "\n" , myTimeStamp(), __FUNCTION__ , bVal); }; return -81; } while (0);

   data.byte = bVal;

   status = my_smbus_access(
            i2cInfo[handle].fd,
            0,
            reg,
            2,
            &data);

   if (status < 0)
   {
      { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3551 "pigpio.c" 3 4
     stderr
# 3551 "pigpio.c"
     , "%s %s: " "error=%d (%m)" "\n" , myTimeStamp(), __FUNCTION__ , status); };
      return -82;
   }

   return status;
}


int i2cReadWordData(unsigned handle, unsigned reg)
{
   union my_smbus_data data;
   int status;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3564 "pigpio.c" 3 4
  stderr
# 3564 "pigpio.c"
  , "%s %s: " "handle=%d reg=%d" "\n" , myTimeStamp(), __FUNCTION__ , handle, reg); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3566 "pigpio.c" 3 4
  stderr
# 3566 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (handle >= 512)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3569 "pigpio.c" 3 4
     stderr
# 3569 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (i2cInfo[handle].state != 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3572 "pigpio.c" 3 4
     stderr
# 3572 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if ((i2cInfo[handle].funcs & 0x00200000) == 0)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3575 "pigpio.c" 3 4
     stderr
# 3575 "pigpio.c"
     , "%s %s: " "SMBUS command not supported by driver" "\n" , myTimeStamp(), __FUNCTION__); }; return -107; } while (0);

   if (reg > 0xFF)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3578 "pigpio.c" 3 4
     stderr
# 3578 "pigpio.c"
     , "%s %s: " "bad reg (%d)" "\n" , myTimeStamp(), __FUNCTION__ , reg); }; return -81; } while (0);

   status = (my_smbus_access(
      i2cInfo[handle].fd,
      1,
      reg,
      3,
      &data));

   if (status < 0)
   {
      { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3589 "pigpio.c" 3 4
     stderr
# 3589 "pigpio.c"
     , "%s %s: " "error=%d (%m)" "\n" , myTimeStamp(), __FUNCTION__ , status); };
      return -83;
   }

   return 0xFFFF & data.word;
}


int i2cWriteWordData(unsigned handle, unsigned reg, unsigned wVal)
{
   union my_smbus_data data;

   int status;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3603 "pigpio.c" 3 4
  stderr
# 3603 "pigpio.c"
  , "%s %s: " "handle=%d reg=%d wVal=%d" "\n" , myTimeStamp(), __FUNCTION__ , handle, reg, wVal); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3605 "pigpio.c" 3 4
  stderr
# 3605 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (handle >= 512)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3608 "pigpio.c" 3 4
     stderr
# 3608 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (i2cInfo[handle].state != 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3611 "pigpio.c" 3 4
     stderr
# 3611 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if ((i2cInfo[handle].funcs & 0x00400000) == 0)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3614 "pigpio.c" 3 4
     stderr
# 3614 "pigpio.c"
     , "%s %s: " "SMBUS command not supported by driver" "\n" , myTimeStamp(), __FUNCTION__); }; return -107; } while (0);

   if (reg > 0xFF)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3617 "pigpio.c" 3 4
     stderr
# 3617 "pigpio.c"
     , "%s %s: " "bad reg (%d)" "\n" , myTimeStamp(), __FUNCTION__ , reg); }; return -81; } while (0);

   if (wVal > 0xFFFF)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3620 "pigpio.c" 3 4
     stderr
# 3620 "pigpio.c"
     , "%s %s: " "bad wVal (%d)" "\n" , myTimeStamp(), __FUNCTION__ , wVal); }; return -81; } while (0);

   data.word = wVal;

   status = my_smbus_access(
            i2cInfo[handle].fd,
            0,
            reg,
            3,
            &data);

   if (status < 0)
   {
      { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3633 "pigpio.c" 3 4
     stderr
# 3633 "pigpio.c"
     , "%s %s: " "error=%d (%m)" "\n" , myTimeStamp(), __FUNCTION__ , status); };
      return -82;
   }

   return status;
}


int i2cProcessCall(unsigned handle, unsigned reg, unsigned wVal)
{
   union my_smbus_data data;
   int status;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3646 "pigpio.c" 3 4
  stderr
# 3646 "pigpio.c"
  , "%s %s: " "handle=%d reg=%d wVal=%d" "\n" , myTimeStamp(), __FUNCTION__ , handle, reg, wVal); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3648 "pigpio.c" 3 4
  stderr
# 3648 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (handle >= 512)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3651 "pigpio.c" 3 4
     stderr
# 3651 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (i2cInfo[handle].state != 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3654 "pigpio.c" 3 4
     stderr
# 3654 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if ((i2cInfo[handle].funcs & 0x00800000) == 0)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3657 "pigpio.c" 3 4
     stderr
# 3657 "pigpio.c"
     , "%s %s: " "SMBUS command not supported by driver" "\n" , myTimeStamp(), __FUNCTION__); }; return -107; } while (0);

   if (reg > 0xFF)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3660 "pigpio.c" 3 4
     stderr
# 3660 "pigpio.c"
     , "%s %s: " "bad reg (%d)" "\n" , myTimeStamp(), __FUNCTION__ , reg); }; return -81; } while (0);

   if (wVal > 0xFFFF)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3663 "pigpio.c" 3 4
     stderr
# 3663 "pigpio.c"
     , "%s %s: " "bad wVal (%d)" "\n" , myTimeStamp(), __FUNCTION__ , wVal); }; return -81; } while (0);

   data.word = wVal;

   status = (my_smbus_access(
      i2cInfo[handle].fd,
      0,
      reg, 4,
      &data));

   if (status < 0)
   {
      { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3675 "pigpio.c" 3 4
     stderr
# 3675 "pigpio.c"
     , "%s %s: " "error=%d (%m)" "\n" , myTimeStamp(), __FUNCTION__ , status); };
      return -83;
   }

   return 0xFFFF & data.word;
}


int i2cReadBlockData(unsigned handle, unsigned reg, char *buf)
{
   union my_smbus_data data;

   int i, status;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3689 "pigpio.c" 3 4
  stderr
# 3689 "pigpio.c"
  , "%s %s: " "handle=%d reg=%d buf=%08"
# 3689 "pigpio.c" 3 4
  "l" "X" 
# 3689 "pigpio.c"
  "\n" , myTimeStamp(), __FUNCTION__ , handle, reg, (uintptr_t)buf); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3691 "pigpio.c" 3 4
  stderr
# 3691 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (handle >= 512)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3694 "pigpio.c" 3 4
     stderr
# 3694 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (i2cInfo[handle].state != 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3697 "pigpio.c" 3 4
     stderr
# 3697 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if ((i2cInfo[handle].funcs & 0x01000000) == 0)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3700 "pigpio.c" 3 4
     stderr
# 3700 "pigpio.c"
     , "%s %s: " "SMBUS command not supported by driver" "\n" , myTimeStamp(), __FUNCTION__); }; return -107; } while (0);

   if (reg > 0xFF)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3703 "pigpio.c" 3 4
     stderr
# 3703 "pigpio.c"
     , "%s %s: " "bad reg (%d)" "\n" , myTimeStamp(), __FUNCTION__ , reg); }; return -81; } while (0);

   status = (my_smbus_access(
      i2cInfo[handle].fd,
      1,
      reg,
      5,
      &data));

   if (status < 0)
   {
      { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3714 "pigpio.c" 3 4
     stderr
# 3714 "pigpio.c"
     , "%s %s: " "error=%d (%m)" "\n" , myTimeStamp(), __FUNCTION__ , status); };
      return -83;
   }
   else
   {
      if (data.block[0] <= 32)
      {
         for (i=0; i<data.block[0]; i++) buf[i] = data.block[i+1];
         return data.block[0];
      }
      else return -83;
   }
}


int i2cWriteBlockData(
   unsigned handle, unsigned reg, char *buf, unsigned count)
{
   union my_smbus_data data;

   int i, status;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3736 "pigpio.c" 3 4
  stderr
# 3736 "pigpio.c"
  , "%s %s: " "handle=%d reg=%d count=%d [%s]" "\n" , myTimeStamp(), __FUNCTION__ , handle, reg, count, myBuf2Str(count, buf)); }
                                                ;

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3739 "pigpio.c" 3 4
  stderr
# 3739 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (handle >= 512)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3742 "pigpio.c" 3 4
     stderr
# 3742 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (i2cInfo[handle].state != 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3745 "pigpio.c" 3 4
     stderr
# 3745 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if ((i2cInfo[handle].funcs & 0x02000000) == 0)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3748 "pigpio.c" 3 4
     stderr
# 3748 "pigpio.c"
     , "%s %s: " "SMBUS command not supported by driver" "\n" , myTimeStamp(), __FUNCTION__); }; return -107; } while (0);

   if (reg > 0xFF)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3751 "pigpio.c" 3 4
     stderr
# 3751 "pigpio.c"
     , "%s %s: " "bad reg (%d)" "\n" , myTimeStamp(), __FUNCTION__ , reg); }; return -81; } while (0);

   if ((count < 1) || (count > 32))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3754 "pigpio.c" 3 4
     stderr
# 3754 "pigpio.c"
     , "%s %s: " "bad count (%d)" "\n" , myTimeStamp(), __FUNCTION__ , count); }; return -81; } while (0);

   for (i=1; i<=count; i++) data.block[i] = buf[i-1];
   data.block[0] = count;

   status = my_smbus_access(
            i2cInfo[handle].fd,
            0,
            reg,
            5,
            &data);

   if (status < 0)
   {
      { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3768 "pigpio.c" 3 4
     stderr
# 3768 "pigpio.c"
     , "%s %s: " "error=%d (%m)" "\n" , myTimeStamp(), __FUNCTION__ , status); };
      return -82;
   }

   return status;
}


int i2cBlockProcessCall(
   unsigned handle, unsigned reg, char *buf, unsigned count)
{
   union my_smbus_data data;

   int i, status;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3783 "pigpio.c" 3 4
  stderr
# 3783 "pigpio.c"
  , "%s %s: " "handle=%d reg=%d count=%d [%s]" "\n" , myTimeStamp(), __FUNCTION__ , handle, reg, count, myBuf2Str(count, buf)); }
                                                ;

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3786 "pigpio.c" 3 4
  stderr
# 3786 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (handle >= 512)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3789 "pigpio.c" 3 4
     stderr
# 3789 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (i2cInfo[handle].state != 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3792 "pigpio.c" 3 4
     stderr
# 3792 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if ((i2cInfo[handle].funcs & 0x00800000) == 0)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3795 "pigpio.c" 3 4
     stderr
# 3795 "pigpio.c"
     , "%s %s: " "SMBUS command not supported by driver" "\n" , myTimeStamp(), __FUNCTION__); }; return -107; } while (0);

   if (reg > 0xFF)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3798 "pigpio.c" 3 4
     stderr
# 3798 "pigpio.c"
     , "%s %s: " "bad reg (%d)" "\n" , myTimeStamp(), __FUNCTION__ , reg); }; return -81; } while (0);

   if ((count < 1) || (count > 32))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3801 "pigpio.c" 3 4
     stderr
# 3801 "pigpio.c"
     , "%s %s: " "bad count (%d)" "\n" , myTimeStamp(), __FUNCTION__ , count); }; return -81; } while (0);

   for (i=1; i<=count; i++) data.block[i] = buf[i-1];
   data.block[0] = count;

   status = (my_smbus_access(
      i2cInfo[handle].fd, 0, reg,
      7, &data));

   if (status < 0)
   {
      { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3812 "pigpio.c" 3 4
     stderr
# 3812 "pigpio.c"
     , "%s %s: " "error=%d (%m)" "\n" , myTimeStamp(), __FUNCTION__ , status); };
      return -83;
   }
   else
   {
      if (data.block[0] <= 32)
      {
         for (i=0; i<data.block[0]; i++) buf[i] = data.block[i+1];
         return data.block[0];
      }
      else return -83;
   }
}


int i2cReadI2CBlockData(
   unsigned handle, unsigned reg, char *buf, unsigned count)
{
   union my_smbus_data data;

   int i, status;
   uint32_t size;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3835 "pigpio.c" 3 4
  stderr
# 3835 "pigpio.c"
  , "%s %s: " "handle=%d reg=%d count=%d buf=%08"
# 3835 "pigpio.c" 3 4
  "l" "X" 
# 3835 "pigpio.c"
  "\n" , myTimeStamp(), __FUNCTION__ , handle, reg, count, (uintptr_t)buf); }
                                         ;

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3838 "pigpio.c" 3 4
  stderr
# 3838 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (handle >= 512)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3841 "pigpio.c" 3 4
     stderr
# 3841 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (i2cInfo[handle].state != 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3844 "pigpio.c" 3 4
     stderr
# 3844 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if ((i2cInfo[handle].funcs & 0x04000000) == 0)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3847 "pigpio.c" 3 4
     stderr
# 3847 "pigpio.c"
     , "%s %s: " "SMBUS command not supported by driver" "\n" , myTimeStamp(), __FUNCTION__); }; return -107; } while (0);

   if (reg > 0xFF)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3850 "pigpio.c" 3 4
     stderr
# 3850 "pigpio.c"
     , "%s %s: " "bad reg (%d)" "\n" , myTimeStamp(), __FUNCTION__ , reg); }; return -81; } while (0);

   if ((count < 1) || (count > 32))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3853 "pigpio.c" 3 4
     stderr
# 3853 "pigpio.c"
     , "%s %s: " "bad count (%d)" "\n" , myTimeStamp(), __FUNCTION__ , count); }; return -81; } while (0);

   if (count == 32)
      size = 6;
   else
      size = 8;

   data.block[0] = count;

   status = (my_smbus_access(
      i2cInfo[handle].fd, 1, reg, size, &data));

   if (status < 0)
   {
      { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3867 "pigpio.c" 3 4
     stderr
# 3867 "pigpio.c"
     , "%s %s: " "error=%d (%m)" "\n" , myTimeStamp(), __FUNCTION__ , status); };
      return -83;
   }
   else
   {
      if (data.block[0] <= 32)
      {
         for (i=0; i<data.block[0]; i++) buf[i] = data.block[i+1];
         return data.block[0];
      }
      else return -83;
   }
}


int i2cWriteI2CBlockData(
   unsigned handle, unsigned reg, char *buf, unsigned count)
{
   union my_smbus_data data;

   int i, status;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3889 "pigpio.c" 3 4
  stderr
# 3889 "pigpio.c"
  , "%s %s: " "handle=%d reg=%d count=%d [%s]" "\n" , myTimeStamp(), __FUNCTION__ , handle, reg, count, myBuf2Str(count, buf)); }
                                                ;

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3892 "pigpio.c" 3 4
  stderr
# 3892 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (handle >= 512)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3895 "pigpio.c" 3 4
     stderr
# 3895 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (i2cInfo[handle].state != 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3898 "pigpio.c" 3 4
     stderr
# 3898 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if ((i2cInfo[handle].funcs & 0x08000000) == 0)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3901 "pigpio.c" 3 4
     stderr
# 3901 "pigpio.c"
     , "%s %s: " "SMBUS command not supported by driver" "\n" , myTimeStamp(), __FUNCTION__); }; return -107; } while (0);

   if (reg > 0xFF)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3904 "pigpio.c" 3 4
     stderr
# 3904 "pigpio.c"
     , "%s %s: " "bad reg (%d)" "\n" , myTimeStamp(), __FUNCTION__ , reg); }; return -81; } while (0);

   if ((count < 1) || (count > 32))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3907 "pigpio.c" 3 4
     stderr
# 3907 "pigpio.c"
     , "%s %s: " "bad count (%d)" "\n" , myTimeStamp(), __FUNCTION__ , count); }; return -81; } while (0);

   for (i=1; i<=count; i++) data.block[i] = buf[i-1];

   data.block[0] = count;

   status = my_smbus_access(
            i2cInfo[handle].fd,
            0,
            reg,
            6,
            &data);

   if (status < 0)
   {
      { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3922 "pigpio.c" 3 4
     stderr
# 3922 "pigpio.c"
     , "%s %s: " "error=%d (%m)" "\n" , myTimeStamp(), __FUNCTION__ , status); };
      return -82;
   }

   return status;
}

int i2cWriteDevice(unsigned handle, char *buf, unsigned count)
{
   int bytes;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3933 "pigpio.c" 3 4
  stderr
# 3933 "pigpio.c"
  , "%s %s: " "handle=%d count=%d [%s]" "\n" , myTimeStamp(), __FUNCTION__ , handle, count, myBuf2Str(count, buf)); }
                                           ;

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3936 "pigpio.c" 3 4
  stderr
# 3936 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (handle >= 512)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3939 "pigpio.c" 3 4
     stderr
# 3939 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (i2cInfo[handle].state != 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3942 "pigpio.c" 3 4
     stderr
# 3942 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if ((count < 1) || (count > (1<<16)))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3945 "pigpio.c" 3 4
     stderr
# 3945 "pigpio.c"
     , "%s %s: " "bad count (%d)" "\n" , myTimeStamp(), __FUNCTION__ , count); }; return -81; } while (0);

   bytes = write(i2cInfo[handle].fd, buf, count);

   if (bytes != count)
   {
      { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3951 "pigpio.c" 3 4
     stderr
# 3951 "pigpio.c"
     , "%s %s: " "error=%d (%m)" "\n" , myTimeStamp(), __FUNCTION__ , bytes); };
      return -82;
   }

   return 0;
}

int i2cReadDevice(unsigned handle, char *buf, unsigned count)
{
   int bytes;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3962 "pigpio.c" 3 4
  stderr
# 3962 "pigpio.c"
  , "%s %s: " "handle=%d count=%d buf=%08"
# 3962 "pigpio.c" 3 4
  "l" "X" 
# 3962 "pigpio.c"
  "\n" , myTimeStamp(), __FUNCTION__ , handle, count, (uintptr_t)buf); }
                                    ;

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3965 "pigpio.c" 3 4
  stderr
# 3965 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (handle >= 512)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3968 "pigpio.c" 3 4
     stderr
# 3968 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (i2cInfo[handle].state != 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3971 "pigpio.c" 3 4
     stderr
# 3971 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if ((count < 1) || (count > (1<<16)))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3974 "pigpio.c" 3 4
     stderr
# 3974 "pigpio.c"
     , "%s %s: " "bad count (%d)" "\n" , myTimeStamp(), __FUNCTION__ , count); }; return -81; } while (0);

   bytes = read(i2cInfo[handle].fd, buf, count);

   if (bytes != count)
   {
      { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3980 "pigpio.c" 3 4
     stderr
# 3980 "pigpio.c"
     , "%s %s: " "error=%d (%m)" "\n" , myTimeStamp(), __FUNCTION__ , bytes); };
      return -83;
   }

   return bytes;
}

int i2cOpen(unsigned i2cBus, unsigned i2cAddr, unsigned i2cFlags)
{
   static pthread_mutex_t mutex = 
# 3989 "pigpio.c" 3 4
                                 { { 0, 0, 0, 0, PTHREAD_MUTEX_TIMED_NP, 0, { 0, 0 } } }
# 3989 "pigpio.c"
                                                          ;
   char dev[32];
   int i, slot, fd;
   uint32_t funcs;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3994 "pigpio.c" 3 4
  stderr
# 3994 "pigpio.c"
  , "%s %s: " "i2cBus=%d i2cAddr=%d flags=0x%X" "\n" , myTimeStamp(), __FUNCTION__ , i2cBus, i2cAddr, i2cFlags); }
                                ;

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 3997 "pigpio.c" 3 4
  stderr
# 3997 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (i2cAddr > 0x7F)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4000 "pigpio.c" 3 4
     stderr
# 4000 "pigpio.c"
     , "%s %s: " "bad I2C address (%d)" "\n" , myTimeStamp(), __FUNCTION__ , i2cAddr); }; return -75; } while (0);

   if (i2cFlags)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4003 "pigpio.c" 3 4
     stderr
# 4003 "pigpio.c"
     , "%s %s: " "bad flags (0x%X)" "\n" , myTimeStamp(), __FUNCTION__ , i2cFlags); }; return -77; } while (0);

   slot = -1;

   pthread_mutex_lock(&mutex);

   for (i=0; i<512; i++)
   {
      if (i2cInfo[i].state == 0)
      {
         slot = i;
         i2cInfo[slot].state = 1;
         break;
      }
   }

   pthread_mutex_unlock(&mutex);

   if (slot < 0) do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4021 "pigpio.c" 3 4
                stderr
# 4021 "pigpio.c"
                , "%s %s: " "no I2C handles" "\n" , myTimeStamp(), __FUNCTION__); }; return -24; } while (0);

   sprintf(dev, "/dev/i2c-%d", i2cBus);

   if ((fd = open(dev, 
# 4025 "pigpio.c" 3 4
                      02
# 4025 "pigpio.c"
                            )) < 0)
   {


      if (system("/sbin/modprobe i2c_dev") == -1) { }
      if (system("/sbin/modprobe i2c_bcm2835") == -1) { }

      myGpioDelay(100000);

      if ((fd = open(dev, 
# 4034 "pigpio.c" 3 4
                         02
# 4034 "pigpio.c"
                               )) < 0)
      {
         i2cInfo[slot].state = 0;
         return -74;
      }
   }

   if (ioctl(fd, 0x0703, i2cAddr) < 0)
   {
      close(fd);
      i2cInfo[slot].state = 0;
      return -71;
   }

   if (ioctl(fd, 0x0705, &funcs) < 0)
   {
      funcs = -1;
   }

   i2cInfo[slot].fd = fd;
   i2cInfo[slot].addr = i2cAddr;
   i2cInfo[slot].flags = i2cFlags;
   i2cInfo[slot].funcs = funcs;
   i2cInfo[i].state = 2;

   return slot;
}

int i2cClose(unsigned handle)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4064 "pigpio.c" 3 4
  stderr
# 4064 "pigpio.c"
  , "%s %s: " "handle=%d" "\n" , myTimeStamp(), __FUNCTION__ , handle); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4066 "pigpio.c" 3 4
  stderr
# 4066 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (handle >= 512)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4069 "pigpio.c" 3 4
     stderr
# 4069 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (i2cInfo[handle].state != 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4072 "pigpio.c" 3 4
     stderr
# 4072 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (i2cInfo[handle].fd >= 0) close(i2cInfo[handle].fd);

   i2cInfo[handle].fd = -1;
   i2cInfo[handle].state = 0;

   return 0;
}

void i2cSwitchCombined(int setting)
{
   int fd;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4086 "pigpio.c" 3 4
  stderr
# 4086 "pigpio.c"
  , "%s %s: " "setting=%d" "\n" , myTimeStamp(), __FUNCTION__ , setting); };

   fd = open("/sys/module/i2c_bcm2708/parameters/combined", 
# 4088 "pigpio.c" 3 4
                             01
# 4088 "pigpio.c"
                                     );

   if (fd >= 0)
   {
      if (setting)
      {
         if (write(fd, "1\n", 2) == -1) { }
      }
      else
      {
         if (write(fd, "0\n", 2) == -1) { }
      }

      close(fd);
   }
}

int i2cSegments(unsigned handle, pi_i2c_msg_t *segs, unsigned numSegs)
{
   int retval;
   my_i2c_rdwr_ioctl_data_t rdwr;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4110 "pigpio.c" 3 4
  stderr
# 4110 "pigpio.c"
  , "%s %s: " "handle=%d" "\n" , myTimeStamp(), __FUNCTION__ , handle); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4112 "pigpio.c" 3 4
  stderr
# 4112 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (handle >= 512)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4115 "pigpio.c" 3 4
     stderr
# 4115 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (i2cInfo[handle].state != 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4118 "pigpio.c" 3 4
     stderr
# 4118 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (segs == 
# 4120 "pigpio.c" 3 4
              ((void *)0)
# 4120 "pigpio.c"
                  )
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4121 "pigpio.c" 3 4
     stderr
# 4121 "pigpio.c"
     , "%s %s: " "null segments" "\n" , myTimeStamp(), __FUNCTION__); }; return -90; } while (0);

   if (numSegs > 42)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4124 "pigpio.c" 3 4
     stderr
# 4124 "pigpio.c"
     , "%s %s: " "too many segments (%d)" "\n" , myTimeStamp(), __FUNCTION__ , numSegs); }; return -105; } while (0);

   rdwr.msgs = segs;
   rdwr.nmsgs = numSegs;

   retval = ioctl(i2cInfo[handle].fd, 0x0707, &rdwr);

   if (retval >= 0) return retval;
   else return -106;
}

int i2cZip(
   unsigned handle,
   char *inBuf, unsigned inLen, char *outBuf, unsigned outLen)
{
   int numSegs, inPos, outPos, status, bytes, flags, addr;
   int esc, setesc;
   pi_i2c_msg_t segs[42];

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4143 "pigpio.c" 3 4
  stderr
# 4143 "pigpio.c"
  , "%s %s: " "handle=%d inBuf=%s outBuf=%08"
# 4143 "pigpio.c" 3 4
  "l" "X"
# 4143 "pigpio.c"
  " len=%d" "\n" , myTimeStamp(), __FUNCTION__ , handle, myBuf2Str(inLen, (char *)inBuf), (uintptr_t)outBuf, outLen); }
                                                                         ;

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4146 "pigpio.c" 3 4
  stderr
# 4146 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (handle >= 512)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4149 "pigpio.c" 3 4
     stderr
# 4149 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (i2cInfo[handle].state != 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4152 "pigpio.c" 3 4
     stderr
# 4152 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (!inBuf || !inLen)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4155 "pigpio.c" 3 4
     stderr
# 4155 "pigpio.c"
     , "%s %s: " "input buffer can't be NULL" "\n" , myTimeStamp(), __FUNCTION__); }; return -90; } while (0);

   if (!outBuf && outLen)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4158 "pigpio.c" 3 4
     stderr
# 4158 "pigpio.c"
     , "%s %s: " "output buffer can't be NULL" "\n" , myTimeStamp(), __FUNCTION__); }; return -90; } while (0);

   numSegs = 0;

   inPos = 0;
   outPos = 0;
   status = 0;

   addr = i2cInfo[handle].addr;
   flags = 0;
   esc = 0;
   setesc = 0;

   while (!status && (inPos < inLen))
   {
      { if ((gpioCfg.dbgLevel >= 5) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4173 "pigpio.c" 3 4
     stderr
# 4173 "pigpio.c"
     , "%s %s: " "status=%d inpos=%d inlen=%d cmd=%d addr=%d flags=%x" "\n" , myTimeStamp(), __FUNCTION__ , status, inPos, inLen, inBuf[inPos], addr, flags); }
                                                         ;

      switch (inBuf[inPos++])
      {
         case 0:
            status = 1;
            break;

         case 2:

            if (numSegs)
            {
               status = i2cSegments(handle, segs, numSegs);
               if (status >= 0) status = 0;
               numSegs = 0;
            }
            i2cSwitchCombined(1);
            break;

         case 3:

            if (numSegs)
            {
               status = i2cSegments(handle, segs, numSegs);
               if (status >= 0) status = 0;
               numSegs = 0;
            }
            i2cSwitchCombined(0);
            break;

         case 4:
            addr = myI2CGetPar(inBuf, &inPos, inLen, &esc);
            if (addr < 0) status = -111;
            break;

         case 5:

            esc = 1;
            flags = myI2CGetPar(inBuf, &inPos, inLen, &esc);
            if (flags < 0) status = -111;
            break;

         case 1:
            setesc = 1;
            break;

         case 6:

            bytes = myI2CGetPar(inBuf, &inPos, inLen, &esc);

            if (bytes >= 0)
            {
               if ((bytes + outPos) < outLen)
               {
                  segs[numSegs].addr = addr;
                  segs[numSegs].flags = (flags|1);
                  segs[numSegs].len = bytes;
                  segs[numSegs].buf = (uint8_t *)(outBuf + outPos);
                  outPos += bytes;
                  numSegs++;
                  if (numSegs >= 42)
                  {
                     status = i2cSegments(handle, segs, numSegs);
                     if (status >= 0) status = 0;
                     numSegs = 0;
                  }
               }
               else status = -110;
            }
            else status = -110;
            break;

         case 7:

            bytes = myI2CGetPar(inBuf, &inPos, inLen, &esc);

            if (bytes >= 0)
            {
               if ((bytes + inPos) < inLen)
               {
                  segs[numSegs].addr = addr;
                  segs[numSegs].flags = (flags&0xfffe);
                  segs[numSegs].len = bytes;
                  segs[numSegs].buf = (uint8_t *)(inBuf + inPos);
                  inPos += bytes;
                  numSegs++;
                  if (numSegs >= 42)
                  {
                     status = i2cSegments(handle, segs, numSegs);
                     if (status >= 0) status = 0;
                     numSegs = 0;
                  }
               }
               else status = -109;
            }
            else status = -109;
            break;

         default:
            status = -111;
      }

      if (setesc) esc = 1; else esc = 0;

      setesc = 0;
   }

   if (status >= 0)
   {
      if (numSegs) status = i2cSegments(handle, segs, numSegs);
   }

   if (status >= 0) status = outPos;

   return status;
}





static uint32_t _spiTXBits(char *buf, int pos, int bitlen, int msbf)
{
   uint32_t bits=0;

   if (buf)
   {
      if (bitlen <= 8) bits = *((( uint8_t*)buf)+pos);
      else if (bitlen <= 16) bits = *(((uint16_t*)buf)+pos);
      else bits = *(((uint32_t*)buf)+pos);

      if (msbf) bits <<= (32-bitlen);
   }

   return bits;
}

static void _spiRXBits(
   char *buf, int pos, int bitlen, int msbf, uint32_t bits)
{
   if (buf)
   {
      if (!msbf) bits >>= (32-bitlen);

      if (bitlen <= 8) *((( uint8_t*)buf)+pos) = bits;
      else if (bitlen <= 16) *(((uint16_t*)buf)+pos) = bits;
      else *(((uint32_t*)buf)+pos) = bits;
   }
}

static void spiACS(int channel, int on)
{
   int gpio;

   switch (channel)
   {
       case 0: gpio = 18; break;
       case 1: gpio = 17; break;
       default: gpio = 16; break;
   }
   myGpioWrite(gpio, on);
}

static void spiGoA(
   unsigned speed,
   uint32_t flags,
   char *txBuf,
   char *rxBuf,
   unsigned count)
{
   int cs;
   char bit_ir[4] = {1, 0, 0, 1};
   char bit_or[4] = {0, 1, 1, 0};
   char bit_ic[4] = {0, 0, 1, 1};

   int mode, bitlen, txmsbf, rxmsbf, channel;
   unsigned txCnt=0;
   unsigned rxCnt=0;
   uint32_t spiDefaults;
   uint32_t statusReg;
   int txFull, rxEmpty;

   channel = (((flags)>>29)&7);
   mode = ((flags)&3);

   bitlen = (((flags)>>16)&63);

   if (!bitlen) bitlen = 8;



   if (bitlen > 8) count /= 2;
   if (bitlen > 16) count /= 2;

   txmsbf = !(((flags)>>14)&1);
   rxmsbf = !(((flags)>>15)&1);

   cs = (((flags)>>2)&7) & (1<<channel);

   spiDefaults = (((125000000/speed)-1)<<20)|
                 ((bit_ir[mode])<<10) |
                 ((bit_or[mode])<<8) |
                 ((bit_ic[mode])<<7) |
                 ((txmsbf)<<6) |
                 ((bitlen)<<0);

   if (!count)
   {
      auxReg[32] =
         (1<<11) | (1<<9);

      myGpioDelay(10);

      auxReg[32] = (1<<11) | spiDefaults;

      auxReg[33] = ((rxmsbf)<<1);

      return;
   }

   auxReg[32] = (1<<11) | spiDefaults;

   auxReg[33] = ((rxmsbf)<<1);

   spiACS(channel, cs);

   while ((txCnt < count) || (rxCnt < count))
   {
      statusReg = auxReg[34];

      rxEmpty = statusReg & (1<<7);

      txFull = (((statusReg>>28)&15) > 2);

      if (rxCnt < count)
      {
         if (!rxEmpty)
         {
            _spiRXBits(
               rxBuf, rxCnt++, bitlen, rxmsbf, auxReg[40]);
         }
      }

      if (txCnt < count)
      {
         if (!txFull)
         {
            if (txCnt != (count-1))
            {
               auxReg[44] =
                  _spiTXBits(txBuf, txCnt++, bitlen, txmsbf);
            }
            else
            {
               auxReg[40] =
                  _spiTXBits(txBuf, txCnt++, bitlen, txmsbf);
            }
         }
      }
   }

   while ((auxReg[34] & (1<<6))) ;

   spiACS(channel, !cs);
}

static void spiGoS(
   unsigned speed,
   uint32_t flags,
   char *txBuf,
   char *rxBuf,
   unsigned count)
{
   unsigned txCnt=0;
   unsigned rxCnt=0;
   unsigned cnt, cnt4w, cnt3w;
   uint32_t spiDefaults;
   unsigned mode, channel, cspol, cspols, flag3w, ren3w;

   channel = (((flags)>>29)&7);
   mode = ((flags)&3);
   cspols = (((flags)>>2)&7);
   cspol = (cspols>>channel) & 1;
   flag3w = (((flags)>>9)&1);
   ren3w = (((flags)>>10)&15);

   spiDefaults = ((mode)<<2) |
                 ((cspols)<<21) |
                 ((channel)<<0) |
                 ((cspol)<<6) |
                 ((3)<<4);

   spiReg[3] = 2;

   spiReg[0] = spiDefaults;

   if (!count) return;

   if (flag3w)
   {
      if (ren3w < count)
      {
         cnt4w = ren3w;
         cnt3w = count - ren3w;
      }
      else
      {
         cnt4w = count;
         cnt3w = 0;
      }
   }
   else
   {
      cnt4w = count;
      cnt3w = 0;
   }

   spiReg[2] = 250000000/speed;

   spiReg[0] = spiDefaults | (1<<7);

   cnt = cnt4w;

   while((txCnt < cnt) || (rxCnt < cnt))
   {
      while((rxCnt < cnt) && ((spiReg[0] & (1<<17))))
      {
         if (rxBuf) rxBuf[rxCnt] = spiReg[1];
         else spi_dummy = spiReg[1];
         rxCnt++;
      }

      while((txCnt < cnt) && ((spiReg[0] & (1<<18))))
      {
         if (txBuf) spiReg[1] = txBuf[txCnt];
         else spiReg[1] = 0;
         txCnt++;
      }
   }

   while (!(spiReg[0] & (1<<16))) ;



   cnt += cnt3w;

   spiReg[0] |= (1<<12);

   while((txCnt < cnt) || (rxCnt < cnt))
   {
      while((rxCnt < cnt) && ((spiReg[0] & (1<<17))))
      {
         if (rxBuf) rxBuf[rxCnt] = spiReg[1];
         else spi_dummy = spiReg[1];
         rxCnt++;
      }

      while((txCnt < cnt) && ((spiReg[0] & (1<<18))))
      {
         if (txBuf) spiReg[1] = txBuf[txCnt];
         else spiReg[1] = 0;
         txCnt++;
      }
   }

   while (!(spiReg[0] & (1<<16))) ;

   spiReg[0] = spiDefaults;
}

static void spiGo(
   unsigned speed,
   uint32_t flags,
   char *txBuf,
   char *rxBuf,
   unsigned count)
{
   static pthread_mutex_t main_mutex = 
# 4551 "pigpio.c" 3 4
                                      { { 0, 0, 0, 0, PTHREAD_MUTEX_TIMED_NP, 0, { 0, 0 } } }
# 4551 "pigpio.c"
                                                               ;
   static pthread_mutex_t aux_mutex = 
# 4552 "pigpio.c" 3 4
                                     { { 0, 0, 0, 0, PTHREAD_MUTEX_TIMED_NP, 0, { 0, 0 } } }
# 4552 "pigpio.c"
                                                              ;

   if ((((flags)>>8)&1))
   {
      pthread_mutex_lock(&aux_mutex);
      spiGoA(speed, flags, txBuf, rxBuf, count);
      pthread_mutex_unlock(&aux_mutex);
   }
   else
   {
      pthread_mutex_lock(&main_mutex);
      spiGoS(speed, flags, txBuf, rxBuf, count);
      pthread_mutex_unlock(&main_mutex);
   }
}

static int spiAnyOpen(uint32_t flags)
{
   int i, aux;

   aux = (((flags)>>8)&1);

   for (i=0; i<32; i++)
   {
      if ((spiInfo[i].state == 2) &&
         ((((spiInfo[i].flags)>>8)&1) == aux))
            return 1;
   }
   return 0;
}

static void spiInit(uint32_t flags)
{
   uint32_t resvd, cspols;

   resvd = (((flags)>>5)&7);
   cspols = (((flags)>>2)&7);

   if ((((flags)>>8)&1))
   {


      auxReg[1] |= (1<<1);



      old_mode_ace0 = gpioGetMode(18);
      old_mode_ace1 = gpioGetMode(17);
      old_mode_ace2 = gpioGetMode(16);
      old_mode_asclk = gpioGetMode(21);
      old_mode_amiso = gpioGetMode(19);
      old_mode_amosi = gpioGetMode(20);

      old_spi_cntl0 = auxReg[32];
      old_spi_cntl1 = auxReg[33];



      if (!(resvd&1))
      {
         myGpioSetMode(18, 1);
         myGpioWrite(18, !(cspols&1));
      }

      if (!(resvd&2))
      {
         myGpioSetMode(17, 1);
         myGpioWrite(17, !(cspols&2));
      }

      if (!(resvd&4))
      {
         myGpioSetMode(16, 1);
         myGpioWrite(16, !(cspols&4));
      }



      myGpioSetMode(21, 3);
      myGpioSetMode(19, 3);
      myGpioSetMode(20, 3);
   }
   else
   {


      old_mode_ce0 = gpioGetMode(8);
      old_mode_ce1 = gpioGetMode(7);
      old_mode_sclk = gpioGetMode(11);
      old_mode_miso = gpioGetMode(9);
      old_mode_mosi = gpioGetMode(10);

      old_spi_cs = spiReg[0];
      old_spi_clk = spiReg[2];



      if (!(resvd&1)) myGpioSetMode(8, 4);
      if (!(resvd&2)) myGpioSetMode(7, 4);

      myGpioSetMode(11, 4);
      myGpioSetMode(9, 4);
      myGpioSetMode(10, 4);
   }
}

static void spiTerm(uint32_t flags)
{
   int resvd;

   resvd = (((flags)>>5)&7);

   if ((((flags)>>8)&1))
   {


      auxReg[1] &= (~(1<<1));



      if (!(resvd&1)) myGpioSetMode(18, old_mode_ace0);
      if (!(resvd&2)) myGpioSetMode(17, old_mode_ace1);
      if (!(resvd&4)) myGpioSetMode(16, old_mode_ace2);

      myGpioSetMode(21, old_mode_asclk);
      myGpioSetMode(19, old_mode_amiso);
      myGpioSetMode(20, old_mode_amosi);

      auxReg[32] = old_spi_cntl0;
      auxReg[33] = old_spi_cntl1;
   }
   else
   {


      if (!(resvd&1)) myGpioSetMode(8, old_mode_ce0);
      if (!(resvd&2)) myGpioSetMode(7, old_mode_ce1);

      myGpioSetMode(11, old_mode_sclk);
      myGpioSetMode(9, old_mode_miso);
      myGpioSetMode(10, old_mode_mosi);

      spiReg[0] = old_spi_cs;
      spiReg[2] = old_spi_clk;
   }
}

int spiOpen(unsigned spiChan, unsigned baud, unsigned spiFlags)
{
   static pthread_mutex_t mutex = 
# 4701 "pigpio.c" 3 4
                                 { { 0, 0, 0, 0, PTHREAD_MUTEX_TIMED_NP, 0, { 0, 0 } } }
# 4701 "pigpio.c"
                                                          ;
   int i, slot;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4704 "pigpio.c" 3 4
  stderr
# 4704 "pigpio.c"
  , "%s %s: " "spiChan=%d baud=%d spiFlags=0x%X" "\n" , myTimeStamp(), __FUNCTION__ , spiChan, baud, spiFlags); }
                              ;

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4707 "pigpio.c" 3 4
  stderr
# 4707 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if ((((spiFlags)>>8)&1))
   {
      if (gpioHardwareRevision() < 16)
         do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4712 "pigpio.c" 3 4
        stderr
# 4712 "pigpio.c"
        , "%s %s: " "no auxiliary SPI on Pi A or B" "\n" , myTimeStamp(), __FUNCTION__); }; return -91; } while (0);

      i = 3;
   }
   else
      i = 2;

   if (spiChan >= i)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4720 "pigpio.c" 3 4
     stderr
# 4720 "pigpio.c"
     , "%s %s: " "bad spiChan (%d)" "\n" , myTimeStamp(), __FUNCTION__ , spiChan); }; return -76; } while (0);

   if ((baud < 32000) || (baud > 125000000))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4723 "pigpio.c" 3 4
     stderr
# 4723 "pigpio.c"
     , "%s %s: " "bad baud (%d)" "\n" , myTimeStamp(), __FUNCTION__ , baud); }; return -78; } while (0);

   if (spiFlags > (1<<22))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4726 "pigpio.c" 3 4
     stderr
# 4726 "pigpio.c"
     , "%s %s: " "bad spiFlags (0x%X)" "\n" , myTimeStamp(), __FUNCTION__ , spiFlags); }; return -77; } while (0);

   if (!spiAnyOpen(spiFlags))
   {
      spiInit(spiFlags);
      spiGo(baud, spiFlags, 
# 4731 "pigpio.c" 3 4
                           ((void *)0)
# 4731 "pigpio.c"
                               , 
# 4731 "pigpio.c" 3 4
                                 ((void *)0)
# 4731 "pigpio.c"
                                     , 0);
   }

   slot = -1;

   pthread_mutex_lock(&mutex);

   for (i=0; i<32; i++)
   {
      if (spiInfo[i].state == 0)
      {
         slot = i;
         spiInfo[slot].state = 1;
         break;
      }
   }

   pthread_mutex_unlock(&mutex);

   if (slot < 0) do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4750 "pigpio.c" 3 4
                stderr
# 4750 "pigpio.c"
                , "%s %s: " "no SPI handles" "\n" , myTimeStamp(), __FUNCTION__); }; return -24; } while (0);

   spiInfo[slot].speed = baud;
   spiInfo[slot].flags = spiFlags | ((spiChan&7)<<29);
   spiInfo[slot].state = 2;

   return slot;
}

int spiClose(unsigned handle)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4761 "pigpio.c" 3 4
  stderr
# 4761 "pigpio.c"
  , "%s %s: " "handle=%d" "\n" , myTimeStamp(), __FUNCTION__ , handle); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4763 "pigpio.c" 3 4
  stderr
# 4763 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (handle >= 32)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4766 "pigpio.c" 3 4
     stderr
# 4766 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (spiInfo[handle].state != 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4769 "pigpio.c" 3 4
     stderr
# 4769 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   spiInfo[handle].state = 0;

   if (!spiAnyOpen(spiInfo[handle].flags))
      spiTerm(spiInfo[handle].flags);

   return 0;
}

int spiRead(unsigned handle, char *buf, unsigned count)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4781 "pigpio.c" 3 4
  stderr
# 4781 "pigpio.c"
  , "%s %s: " "handle=%d count=%d [%s]" "\n" , myTimeStamp(), __FUNCTION__ , handle, count, myBuf2Str(count, buf)); }
                                           ;

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4784 "pigpio.c" 3 4
  stderr
# 4784 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (handle >= 32)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4787 "pigpio.c" 3 4
     stderr
# 4787 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (spiInfo[handle].state != 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4790 "pigpio.c" 3 4
     stderr
# 4790 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (count > (1<<16))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4793 "pigpio.c" 3 4
     stderr
# 4793 "pigpio.c"
     , "%s %s: " "bad count (%d)" "\n" , myTimeStamp(), __FUNCTION__ , count); }; return -84; } while (0);

   spiGo(spiInfo[handle].speed, spiInfo[handle].flags, 
# 4795 "pigpio.c" 3 4
                                                      ((void *)0)
# 4795 "pigpio.c"
                                                          , buf, count);

   return count;
}

int spiWrite(unsigned handle, char *buf, unsigned count)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4802 "pigpio.c" 3 4
  stderr
# 4802 "pigpio.c"
  , "%s %s: " "handle=%d count=%d [%s]" "\n" , myTimeStamp(), __FUNCTION__ , handle, count, myBuf2Str(count, buf)); }
                                           ;

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4805 "pigpio.c" 3 4
  stderr
# 4805 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (handle >= 32)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4808 "pigpio.c" 3 4
     stderr
# 4808 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (spiInfo[handle].state != 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4811 "pigpio.c" 3 4
     stderr
# 4811 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (count > (1<<16))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4814 "pigpio.c" 3 4
     stderr
# 4814 "pigpio.c"
     , "%s %s: " "bad count (%d)" "\n" , myTimeStamp(), __FUNCTION__ , count); }; return -84; } while (0);

   spiGo(spiInfo[handle].speed, spiInfo[handle].flags, buf, 
# 4816 "pigpio.c" 3 4
                                                           ((void *)0)
# 4816 "pigpio.c"
                                                               , count);

   return count;
}

int spiXfer(unsigned handle, char *txBuf, char *rxBuf, unsigned count)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4823 "pigpio.c" 3 4
  stderr
# 4823 "pigpio.c"
  , "%s %s: " "handle=%d count=%d [%s]" "\n" , myTimeStamp(), __FUNCTION__ , handle, count, myBuf2Str(count, txBuf)); }
                                             ;

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4826 "pigpio.c" 3 4
  stderr
# 4826 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (handle >= 32)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4829 "pigpio.c" 3 4
     stderr
# 4829 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (spiInfo[handle].state != 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4832 "pigpio.c" 3 4
     stderr
# 4832 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (count > (1<<16))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4835 "pigpio.c" 3 4
     stderr
# 4835 "pigpio.c"
     , "%s %s: " "bad count (%d)" "\n" , myTimeStamp(), __FUNCTION__ , count); }; return -84; } while (0);

   spiGo(spiInfo[handle].speed, spiInfo[handle].flags, txBuf, rxBuf, count);

   return count;
}




int serOpen(char *tty, unsigned serBaud, unsigned serFlags)
{
   static pthread_mutex_t mutex = 
# 4847 "pigpio.c" 3 4
                                 { { 0, 0, 0, 0, PTHREAD_MUTEX_TIMED_NP, 0, { 0, 0 } } }
# 4847 "pigpio.c"
                                                          ;
   struct termios new;
   int speed;
   int fd;
   int i, slot;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4853 "pigpio.c" 3 4
  stderr
# 4853 "pigpio.c"
  , "%s %s: " "tty=%s serBaud=%d serFlags=0x%X" "\n" , myTimeStamp(), __FUNCTION__ , tty, serBaud, serFlags); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4855 "pigpio.c" 3 4
  stderr
# 4855 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (strncmp("/dev/tty", tty, 8) && strncmp("/dev/serial", tty, 11))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4858 "pigpio.c" 3 4
     stderr
# 4858 "pigpio.c"
     , "%s %s: " "bad device (%s)" "\n" , myTimeStamp(), __FUNCTION__ , tty); }; return -79; } while (0);

   switch (serBaud)
   {
      case 50: speed = 
# 4862 "pigpio.c" 3 4
                              0000001
# 4862 "pigpio.c"
                                 ; break;
      case 75: speed = 
# 4863 "pigpio.c" 3 4
                              0000002
# 4863 "pigpio.c"
                                 ; break;
      case 110: speed = 
# 4864 "pigpio.c" 3 4
                             0000003
# 4864 "pigpio.c"
                                 ; break;
      case 134: speed = 
# 4865 "pigpio.c" 3 4
                             0000004
# 4865 "pigpio.c"
                                 ; break;
      case 150: speed = 
# 4866 "pigpio.c" 3 4
                             0000005
# 4866 "pigpio.c"
                                 ; break;
      case 200: speed = 
# 4867 "pigpio.c" 3 4
                             0000006
# 4867 "pigpio.c"
                                 ; break;
      case 300: speed = 
# 4868 "pigpio.c" 3 4
                             0000007
# 4868 "pigpio.c"
                                 ; break;
      case 600: speed = 
# 4869 "pigpio.c" 3 4
                             0000010
# 4869 "pigpio.c"
                                 ; break;
      case 1200: speed = 
# 4870 "pigpio.c" 3 4
                            0000011
# 4870 "pigpio.c"
                                 ; break;
      case 1800: speed = 
# 4871 "pigpio.c" 3 4
                            0000012
# 4871 "pigpio.c"
                                 ; break;
      case 2400: speed = 
# 4872 "pigpio.c" 3 4
                            0000013
# 4872 "pigpio.c"
                                 ; break;
      case 4800: speed = 
# 4873 "pigpio.c" 3 4
                            0000014
# 4873 "pigpio.c"
                                 ; break;
      case 9600: speed = 
# 4874 "pigpio.c" 3 4
                            0000015
# 4874 "pigpio.c"
                                 ; break;
      case 19200: speed = 
# 4875 "pigpio.c" 3 4
                           0000016
# 4875 "pigpio.c"
                                 ; break;
      case 38400: speed = 
# 4876 "pigpio.c" 3 4
                           0000017
# 4876 "pigpio.c"
                                 ; break;
      case 57600: speed = 
# 4877 "pigpio.c" 3 4
                           0010001
# 4877 "pigpio.c"
                                 ; break;
      case 115200: speed = 
# 4878 "pigpio.c" 3 4
                          0010002
# 4878 "pigpio.c"
                                 ; break;
      case 230400: speed = 
# 4879 "pigpio.c" 3 4
                          0010003
# 4879 "pigpio.c"
                                 ; break;

      default:
         do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4882 "pigpio.c" 3 4
        stderr
# 4882 "pigpio.c"
        , "%s %s: " "bad speed (%d)" "\n" , myTimeStamp(), __FUNCTION__ , serBaud); }; return -80; } while (0);
   }

   if (serFlags)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4886 "pigpio.c" 3 4
     stderr
# 4886 "pigpio.c"
     , "%s %s: " "bad flags (0x%X)" "\n" , myTimeStamp(), __FUNCTION__ , serFlags); }; return -77; } while (0);

   slot = -1;

   pthread_mutex_lock(&mutex);

   for (i=0; i<16; i++)
   {
      if (serInfo[i].state == 0)
      {
         slot = i;
         serInfo[slot].state = 1;
         break;
      }
   }

   pthread_mutex_unlock(&mutex);

   if (slot < 0) do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4904 "pigpio.c" 3 4
                stderr
# 4904 "pigpio.c"
                , "%s %s: " "no serial handles" "\n" , myTimeStamp(), __FUNCTION__); }; return -24; } while (0);

   if ((fd = open(tty, 
# 4906 "pigpio.c" 3 4
                      02 
# 4906 "pigpio.c"
                             | 
# 4906 "pigpio.c" 3 4
                               0400 
# 4906 "pigpio.c"
                                        | 
# 4906 "pigpio.c" 3 4
                                          04000 
# 4906 "pigpio.c"
                                                   | 
# 4906 "pigpio.c" 3 4
                                                     04000
# 4906 "pigpio.c"
                                                               )) == -1)
   {
      serInfo[slot].state = 0;
      return -72;
   }

   tcgetattr(fd, &new);

   cfmakeraw(&new);

   cfsetispeed(&new, speed);
   cfsetospeed(&new, speed);

   new.c_cc [
# 4919 "pigpio.c" 3 4
            6
# 4919 "pigpio.c"
                ] = 0;
   new.c_cc [
# 4920 "pigpio.c" 3 4
            5
# 4920 "pigpio.c"
                 ] = 0;

   tcflush(fd, 
# 4922 "pigpio.c" 3 4
              0
# 4922 "pigpio.c"
                      );
   tcsetattr(fd, 
# 4923 "pigpio.c" 3 4
                0
# 4923 "pigpio.c"
                       , &new);



   serInfo[slot].fd = fd;
   serInfo[slot].flags = serFlags;
   serInfo[slot].state = 2;

   return slot;
}

int serClose(unsigned handle)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4936 "pigpio.c" 3 4
  stderr
# 4936 "pigpio.c"
  , "%s %s: " "handle=%d" "\n" , myTimeStamp(), __FUNCTION__ , handle); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4938 "pigpio.c" 3 4
  stderr
# 4938 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (handle >= 16)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4941 "pigpio.c" 3 4
     stderr
# 4941 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (serInfo[handle].state != 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4944 "pigpio.c" 3 4
     stderr
# 4944 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (serInfo[handle].fd >= 0) close(serInfo[handle].fd);

   serInfo[handle].fd = -1;
   serInfo[handle].state = 0;

   return 0;
}

int serWriteByte(unsigned handle, unsigned bVal)
{
   char c;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4958 "pigpio.c" 3 4
  stderr
# 4958 "pigpio.c"
  , "%s %s: " "handle=%d bVal=%d" "\n" , myTimeStamp(), __FUNCTION__ , handle, bVal); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4960 "pigpio.c" 3 4
  stderr
# 4960 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (handle >= 16)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4963 "pigpio.c" 3 4
     stderr
# 4963 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (serInfo[handle].state != 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4966 "pigpio.c" 3 4
     stderr
# 4966 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (bVal > 0xFF)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4969 "pigpio.c" 3 4
     stderr
# 4969 "pigpio.c"
     , "%s %s: " "bad parameter (%d)" "\n" , myTimeStamp(), __FUNCTION__ , bVal); }; return -81; } while (0);

   c = bVal;

   if (write(serInfo[handle].fd, &c, 1) != 1)
      return -85;
   else
      return 0;
}

int serReadByte(unsigned handle)
{
   int r;
   char x;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4984 "pigpio.c" 3 4
  stderr
# 4984 "pigpio.c"
  , "%s %s: " "handle=%d" "\n" , myTimeStamp(), __FUNCTION__ , handle); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4986 "pigpio.c" 3 4
  stderr
# 4986 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (handle >= 16)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4989 "pigpio.c" 3 4
     stderr
# 4989 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (serInfo[handle].state != 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 4992 "pigpio.c" 3 4
     stderr
# 4992 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   r = read(serInfo[handle].fd, &x, 1);

   if (r == 1)
      return ((int)x) & 0xFF;

   else if (r == 0)
      return -87;

   else if ((r == -1) && (
# 5002 "pigpio.c" 3 4
                         (*__errno_location ()) 
# 5002 "pigpio.c"
                               == 
# 5002 "pigpio.c" 3 4
                                  11
# 5002 "pigpio.c"
                                        ))
      return -87;

   else
      return -86;
}

int serWrite(unsigned handle, char *buf, unsigned count)
{
   int written=0, wrote=0;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 5013 "pigpio.c" 3 4
  stderr
# 5013 "pigpio.c"
  , "%s %s: " "handle=%d count=%d [%s]" "\n" , myTimeStamp(), __FUNCTION__ , handle, count, myBuf2Str(count, buf)); }
                                           ;

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 5016 "pigpio.c" 3 4
  stderr
# 5016 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (handle >= 16)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 5019 "pigpio.c" 3 4
     stderr
# 5019 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (serInfo[handle].state != 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 5022 "pigpio.c" 3 4
     stderr
# 5022 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (!count)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 5025 "pigpio.c" 3 4
     stderr
# 5025 "pigpio.c"
     , "%s %s: " "bad count (%d)" "\n" , myTimeStamp(), __FUNCTION__ , count); }; return -81; } while (0);

   while ((written != count) && (wrote >= 0))
   {
      wrote = write(serInfo[handle].fd, buf+written, count-written);

      if (wrote >= 0)
      {
         written += wrote;

         if (written != count) time_sleep(0.05);
      }
   }

   if (written != count)
      return -85;
   else
      return 0;
}

int serRead(unsigned handle, char *buf, unsigned count)
{
   int r;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 5049 "pigpio.c" 3 4
  stderr
# 5049 "pigpio.c"
  , "%s %s: " "handle=%d count=%d buf=0x%"
# 5049 "pigpio.c" 3 4
  "l" "X" 
# 5049 "pigpio.c"
  "\n" , myTimeStamp(), __FUNCTION__ , handle, count, (uintptr_t)buf); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 5051 "pigpio.c" 3 4
  stderr
# 5051 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (handle >= 16)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 5054 "pigpio.c" 3 4
     stderr
# 5054 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (serInfo[handle].state != 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 5057 "pigpio.c" 3 4
     stderr
# 5057 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (!count)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 5060 "pigpio.c" 3 4
     stderr
# 5060 "pigpio.c"
     , "%s %s: " "bad count (%d)" "\n" , myTimeStamp(), __FUNCTION__ , count); }; return -81; } while (0);

   r = read(serInfo[handle].fd, buf, count);

   if (r == -1)
   {
      if (
# 5066 "pigpio.c" 3 4
         (*__errno_location ()) 
# 5066 "pigpio.c"
               == 
# 5066 "pigpio.c" 3 4
                  11
# 5066 "pigpio.c"
                        )
         return -87;
      else
         return -86;
   }
   else
   {
      if (r < count) buf[r] = 0;
      return r;
   }
}

int serDataAvailable(unsigned handle)
{
   int result;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 5082 "pigpio.c" 3 4
  stderr
# 5082 "pigpio.c"
  , "%s %s: " "handle=%d" "\n" , myTimeStamp(), __FUNCTION__ , handle); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 5084 "pigpio.c" 3 4
  stderr
# 5084 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (handle >= 16)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 5087 "pigpio.c" 3 4
     stderr
# 5087 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (serInfo[handle].state != 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 5090 "pigpio.c" 3 4
     stderr
# 5090 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (ioctl(serInfo[handle].fd, 
# 5092 "pigpio.c" 3 4
                                0x541B
# 5092 "pigpio.c"
                                        , &result) == -1) return 0;

   return result;
}



static int chooseBestClock
   (clkInf_t *clkInf, unsigned f, unsigned numc, unsigned *cf)
{
   int c, valid;
   double fdiv, offby, best_offby;
   unsigned div, frac;

   valid = 0;
   best_offby = 0;

   for (c=0; c<numc; c++)
   {
      fdiv = (double)cf[c] / (double)f;
      if (f < 23800000)
      {
         fdiv += (0.5 / 4096.0);
         div = fdiv;
         frac = (fdiv - div) * 4096.0;
      }
      else
      {
         fdiv += 0.5;
         div = fdiv;
         frac = 0;
      }

      if ((div > 1) && (div < 4096))
      {
         offby = f - (cf[c] / (div + (frac / 4096.0)));
         if (offby < 0) offby = - offby;
         if ((!valid) || (offby <= best_offby))
         {
            valid = 1;
            clkInf->div = div;
            clkInf->frac = frac;
            clkInf->clock = c;
            best_offby = offby;
         }
      }
   }
   return valid;
}



static rawCbs_t * dmaCB2adr(int pos)
{
   int page, slot;

   page = pos/117;
   slot = pos%117;

   return &dmaIVirt[page]->cb[slot];
}



static void dmaCbPrint(int pos)
{
   rawCbs_t * p;

   p = dmaCB2adr(pos);

   fprintf(
# 5162 "pigpio.c" 3 4
          stderr
# 5162 "pigpio.c"
                , "i=%x s=%x d=%x len=%x s=%x nxt=%x\n",
      p->info, p->src, p->dst, p->length, p->stride, p->next);
}



static unsigned dmaNowAtICB(void)
{
   unsigned cb;
   static unsigned lastPage=0;
   unsigned page;
   uint32_t cbAddr;
   uint32_t startTick, endTick;

   startTick = systReg[1];

   cbAddr = dmaIn[1];

   page = lastPage;



   while (1)
   {


      cb = (cbAddr - ((int)(uintptr_t)dmaIBus[page])) / 32;

      if (cb < 117)
      {
         endTick = systReg[1];

         if (endTick != startTick)
            gpioStats.cbTicks += (endTick - startTick);

         gpioStats.cbCalls++;

         lastPage = page;

         return (page*117) + cb;
      }

      if (page++ >= (53 * bufferBlocks)) page=0;

      if (page == lastPage) break;
   }

   return 0;
}



static int dmaNowAtOCB(void)
{
   unsigned cb;
   unsigned page;
   uint32_t cbAddr;

   cbAddr = dmaOut[1];

   if (!cbAddr) return -9999;

   page = 0;



   while (1)
   {


      cb = (cbAddr - ((int)(uintptr_t)dmaOBus[page])) / 32;

      if (cb < 118) return (page*118) + cb;

      if (page++ >= (53 * 4)) break;
   }



   cbAddr = dmaOut[1];

   if (!cbAddr) return -9999;

   page = 0;



   while (1)
   {


      cb = (cbAddr - ((int)(uintptr_t)dmaOBus[page])) / 32;

      if (cb < 118) return (page*118) + cb;

      if (page++ >= (53 * 4)) break;
   }

   return -9998;
}



unsigned rawWaveCB(void)
{
   unsigned cb;
   static unsigned lastPage=0;
   unsigned page;
   uint32_t cbAddr;

   cbAddr = dmaOut[1];

   if (!cbAddr) return -1;

   page = lastPage;



   while (1)
   {


      cb = (cbAddr - ((int)(uintptr_t)dmaOBus[page])) / 32;

      if (cb < 118)
      {
         lastPage = page;

         return (page*118) + cb;
      }

      if (page++ >= (53 * 4)) page=0;

      if (page == lastPage) break;
   }

   return 0;
}



static unsigned dmaCurrentSlot(unsigned pos)
{
   unsigned cycle=0, slot=0, tmp;

   cycle = (pos/((25*3)+2));
   tmp = (pos%((25*3)+2));

   if (tmp > 2) slot = ((tmp-2)/3);

   return (cycle*25)+slot;
}



static uint32_t dmaPwmDataAdr(int pos)
{


   return (uint32_t)(uintptr_t) &dmaIBus[pos]->periphData;
}



static uint32_t dmaGpioOnAdr(int pos)
{
   int page, slot;

   page = pos/2;
   slot = pos%2;



   return (uint32_t)(uintptr_t) &dmaIBus[page]->gpioOn[slot];
}



static uint32_t dmaGpioOffAdr(int pos)
{
   int page, slot;

   myOffPageSlot(pos, &page, &slot);



   return (uint32_t)(uintptr_t) &dmaIBus[page]->gpioOff[slot];
}



static uint32_t dmaTickAdr(int pos)
{
   int page, slot;

   myTckPageSlot(pos, &page, &slot);



   return (uint32_t)(uintptr_t) &dmaIBus[page]->tick[slot];
}



static uint32_t dmaReadLevelsAdr(int pos)
{
   int page, slot;

   myLvsPageSlot(pos, &page, &slot);



   return (uint32_t)(uintptr_t) &dmaIBus[page]->level[slot];
}



static uint32_t dmaCbAdr(int pos)
{
   int page, slot;

   page = (pos/117);
   slot = (pos%117);



   return (uint32_t)(uintptr_t) &dmaIBus[page]->cb[slot];
}



static void dmaGpioOnCb(int b, int pos)
{
   rawCbs_t * p;

   p = dmaCB2adr(b);

   p->info = ((1<<26) | (1<< 3));
   p->src = dmaGpioOnAdr(pos);
   p->dst = (((pi_peri_phys + 0x00200000) + (7*4)) & 0x00ffffff) | 0x7E000000;
   p->length = 4;
   p->next = dmaCbAdr(b+1);
}



static void dmaTickCb(int b, int pos)
{
   rawCbs_t * p;

   p = dmaCB2adr(b);

   p->info = ((1<<26) | (1<< 3));
   p->src = (((pi_peri_phys + 0x00003000) + (1*4)) & 0x00ffffff) | 0x7E000000;
   p->dst = dmaTickAdr(pos);
   p->length = 4;
   p->next = dmaCbAdr(b+1);
}



static void dmaGpioOffCb(int b, int pos)
{
   rawCbs_t * p;

   p = dmaCB2adr(b);

   p->info = ((1<<26) | (1<< 3));
   p->src = dmaGpioOffAdr(pos);
   p->dst = (((pi_peri_phys + 0x00200000) + (10*4)) & 0x00ffffff) | 0x7E000000;
   p->length = 4;
   p->next = dmaCbAdr(b+1);
}



static void dmaReadLevelsCb(int b, int pos)
{
   rawCbs_t * p;

   p = dmaCB2adr(b);

   p->info = ((1<<26) | (1<< 3));
   p->src = (((pi_peri_phys + 0x00200000) + (13*4)) & 0x00ffffff) | 0x7E000000;
   p->dst = dmaReadLevelsAdr(pos);
   p->length = 4;
   p->next = dmaCbAdr(b+1);
}



static void dmaDelayCb(int b)
{
   rawCbs_t * p;

   p = dmaCB2adr(b);

   if (gpioCfg.clockPeriph == 1)
   {
      p->info = ((1<<26) | (1<< 3)) | ((1<< 6) | ((2)<<16));
      p->dst = ((((pi_peri_phys + 0x00203000) + 1*4) & 0x00ffffff) | 0x7E000000);
   }
   else
   {
      p->info = ((1<<26) | (1<< 3)) | ((1<< 6) | ((5)<<16));
      p->dst = ((((pi_peri_phys + 0x0020C000) + 6*4) & 0x00ffffff) | 0x7E000000);
   }

   p->src = dmaPwmDataAdr(b%(53 * bufferBlocks));
   p->length = 4;
   p->next = dmaCbAdr(b+1);
}



static void dmaInitCbs(void)
{
   int b, pulse, level, cycle;

   rawCbs_t * p;



   { if ((gpioCfg.dbgLevel >= 1) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 5485 "pigpio.c" 3 4
  stderr
# 5485 "pigpio.c"
  , "%s %s: " "" "\n" , myTimeStamp(), __FUNCTION__); };

   gpioStats.dmaInitCbsCount++;

   b = -1;
   level = 0;

   for (cycle=0; cycle<bufferCycles; cycle++)
   {
      b++; dmaGpioOnCb(b, cycle%800);

      b++; dmaTickCb(b, cycle);

      for (pulse=0; pulse<25; pulse++)
      {
         b++; dmaReadLevelsCb(b, level);

         b++; dmaDelayCb(b);

         b++; dmaGpioOffCb(b, (level%20000)+1);

         ++level;
      }
   }



   p = dmaCB2adr(b);

   p->next = dmaCbAdr(0);

   { if ((gpioCfg.dbgLevel >= 1) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 5516 "pigpio.c" 3 4
  stderr
# 5516 "pigpio.c"
  , "%s %s: " "DMA page type count = %zd" "\n" , myTimeStamp(), __FUNCTION__ , sizeof(dmaIPage_t)); };

   { if ((gpioCfg.dbgLevel >= 1) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 5518 "pigpio.c" 3 4
  stderr
# 5518 "pigpio.c"
  , "%s %s: " "%d control blocks (exp=%d)" "\n" , myTimeStamp(), __FUNCTION__ , b+1, (((25*3)+2) * bufferCycles)); };
}




static void sigHandler(int signum)
{
   if ((signum >= 0) && (signum <= 63))
   {
      if (gpioSignal[signum].func)
      {
         if (gpioSignal[signum].ex)
         {
            (gpioSignal[signum].func)(signum, gpioSignal[signum].userdata);
         }
         else
         {
            (gpioSignal[signum].func)(signum);
         }
      }
      else
      {
         switch(signum)
         {
            case 
# 5543 "pigpio.c" 3 4
                10
# 5543 "pigpio.c"
                       :

               if (gpioCfg.dbgLevel > 0) --gpioCfg.dbgLevel;
               else gpioCfg.dbgLevel = 0;
               { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 5547 "pigpio.c" 3 4
              stderr
# 5547 "pigpio.c"
              , "%s %s: " "Debug level %d\n" "\n" , myTimeStamp(), __FUNCTION__ , gpioCfg.dbgLevel); };
               break;

            case 
# 5550 "pigpio.c" 3 4
                12
# 5550 "pigpio.c"
                       :
               if (gpioCfg.dbgLevel < 8) ++gpioCfg.dbgLevel;
               else gpioCfg.dbgLevel = 8;
               { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 5553 "pigpio.c" 3 4
              stderr
# 5553 "pigpio.c"
              , "%s %s: " "Debug level %d\n" "\n" , myTimeStamp(), __FUNCTION__ , gpioCfg.dbgLevel); };
               break;

            case 
# 5556 "pigpio.c" 3 4
                13
# 5556 "pigpio.c"
                       :
            case 
# 5557 "pigpio.c" 3 4
                28
# 5557 "pigpio.c"
                        :
               { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 5558 "pigpio.c" 3 4
              stderr
# 5558 "pigpio.c"
              , "%s %s: " "signal %d ignored" "\n" , myTimeStamp(), __FUNCTION__ , signum); };
               break;

            case 
# 5561 "pigpio.c" 3 4
                17
# 5561 "pigpio.c"
                       :

               break;

            default:
               { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 5566 "pigpio.c" 3 4
              stderr
# 5566 "pigpio.c"
              , "%s %s: " "Unhandled signal %d, terminating\n" "\n" , myTimeStamp(), __FUNCTION__ , signum); };
               gpioTerminate();
               exit(-1);
         }
      }
   }
   else
   {


      { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 5576 "pigpio.c" 3 4
     stderr
# 5576 "pigpio.c"
     , "%s %s: " "Unhandled signal %d, terminating\n" "\n" , myTimeStamp(), __FUNCTION__ , signum); };
      gpioTerminate();
      exit(-1);
   }
}



static void sigSetHandler(void)
{
   int i;
   struct sigaction new;

   for (i=0; i<=63; i++)
   {

      memset(&new, 0, sizeof(new));
      new.
# 5593 "pigpio.c" 3 4
         __sigaction_handler.sa_handler 
# 5593 "pigpio.c"
                    = sigHandler;

      sigaction(i, &new, 
# 5595 "pigpio.c" 3 4
                        ((void *)0)
# 5595 "pigpio.c"
                            );
   }
}
# 5619 "pigpio.c"
unsigned alert_delays[]=
{
   900000, 225000, 240000, 257142, 276923, 300000, 327272, 360000,
   400000, 450000, 514285, 600000, 720000, 900000, 1200000, 1800000
};



static void alertGlitchFilter(gpioSample_t *sample, int numSamples)
{
   int i, j, diff;
   uint32_t steadyUs, changedTick, RBitV, LBitV;
   uint32_t bit, bitV;

   for (i=0; i<=31; i++)
   {
      bit = (1<<i);

      if (monitorBits & bit & gFilterBits)
      {
         steadyUs = gpioAlert[i].gfSteadyUs;
         RBitV = gpioAlert[i].gfRBitV;
         LBitV = gpioAlert[i].gfLBitV;
         changedTick = gpioAlert[i].gfTick;

         for (j=0; j<numSamples; j++)
         {
            bitV = sample[j].level & bit;

            if (bitV != LBitV)
            {



               changedTick = sample[j].tick;
               LBitV = bitV;
            }

            if (bitV != RBitV)
            {


               diff = sample[j].tick - changedTick;

               if (diff >= steadyUs)
               {

                  RBitV = bitV;
               }
               else
               {


                  sample[j].level ^= bit;
               }
            }

         }

         gpioAlert[i].gfRBitV = RBitV;
         gpioAlert[i].gfLBitV = LBitV;
         gpioAlert[i].gfTick = changedTick;
      }
   }
}

static void alertNoiseFilter(gpioSample_t *sample, int numSamples)
{
   int i, j, diff;
   uint32_t LBitV;
   uint32_t bit, bitV;
   uint32_t nowTick;

   for (i=0; i<=31; i++)
   {
      bit = (1<<i);

      if (monitorBits & bit & nFilterBits)
      {
         LBitV = gpioAlert[i].nfLBitV;

         for (j=0; j<numSamples; j++)
         {
            bitV = sample[j].level & bit;
            nowTick = sample[j].tick;

            if (gpioAlert[i].nfActive)
            {
               diff = nowTick - gpioAlert[i].nfTick2;

               if (diff >= 0)
               {


                  gpioAlert[i].nfActive = 0;
                  gpioAlert[i].nfTick1 = nowTick;
               }
            }
            else
            {
               if (bitV != LBitV)
               {
                  diff = nowTick - gpioAlert[i].nfTick1;
                  gpioAlert[i].nfTick1 = nowTick;

                  if (diff >= gpioAlert[i].nfSteadyUs)
                  {


                     gpioAlert[i].nfRBitV = LBitV;
                     gpioAlert[i].nfActive = 1;
                     gpioAlert[i].nfTick2 =
                        nowTick + gpioAlert[i].nfActiveUs;
                  }
               }
            }

            if (!gpioAlert[i].nfActive)
            {
               if (bitV != gpioAlert[i].nfRBitV)
                  sample[j].level ^= bit;
            }

            LBitV = bitV;
         }

         gpioAlert[i].nfLBitV = LBitV;

      }
   }
}

static void alertEmit(
   gpioSample_t *sample, int numSamples, uint32_t changedBits, uint32_t eTick)
{
   uint32_t oldLevel, newLevel;
   int32_t diff;
   int emit, seqno, emitted;
   uint32_t changes, bits, timeoutBits, eventBits;
   int d;
   int b, n, v;
   int err;
   int max_emits;
   char fifo[32];

   gpioReport_t report[250 +31 +1+31 +1];

   if (changedBits)
   {
      if (gpioGetSamples.func)
      {
         if (gpioGetSamples.ex)
         {
            (gpioGetSamples.func)
               (sample, numSamples, gpioGetSamples.userdata);
         }
         else
         {
            (gpioGetSamples.func)(sample, numSamples);
         }
      }
   }

   eventBits = 0;

   if (bscFR != (bscsReg[4]&0xffff))
   {
      bscFR = bscsReg[4]&0xffff;
      eventAlert[31].fired = 1;
   }

   for (b=0; b<=31; b++)
   {
      if (eventAlert[b].fired && (!eventAlert[b].ignore))
      {
         eventBits |= (1<<b);

         if (eventAlert[b].func)
         {
            if (eventAlert[b].ex)
            {
               (eventAlert[b].func)(b, eTick, eventAlert[b].userdata);
            }
            else
            {
               (eventAlert[b].func)(b, eTick);
            }
         }
      }

      eventAlert[b].fired = 0;
   }



   if (changedBits & alertBits)
   {
      oldLevel = (reportedLevel & alertBits);

      for (d=0; d<numSamples; d++)
      {
         newLevel = (sample[d].level & alertBits);

         if (newLevel != oldLevel)
         {
            changes = (newLevel ^ oldLevel);

            for (b=0; b<=31; b++)
            {
               if (changes & (1<<b))
               {
                  if (newLevel & (1<<b)) v = 1; else v = 0;

                  if (gpioAlert[b].func)
                  {
                     if (gpioAlert[b].ex)
                     {
                        (gpioAlert[b].func)
                           (b, v, sample[d].tick,
                            gpioAlert[b].userdata);
                     }
                     else
                     {
                        (gpioAlert[b].func)(b, v, sample[d].tick);
                     }
                  }
               }
            }
            oldLevel = newLevel;
         }
      }
   }



   timeoutBits = 0;

   if (wdogBits)
   {
      for (b=0; b<=31; b++)
      {
         if (gpioAlert[b].wdSteadyUs)
         {
            diff = eTick - gpioAlert[b].wdTick;

            if (diff >= gpioAlert[b].wdSteadyUs)
            {
               timeoutBits |= (1<<b);

               gpioAlert[b].wdTick = eTick;

               if (gpioAlert[b].func)
               {
                  if (gpioAlert[b].ex)
                  {
                     (gpioAlert[b].func)(b, 2, eTick,
                                            gpioAlert[b].userdata);
                  }
                  else
                  {
                     (gpioAlert[b].func)(b, 2, eTick);
                  }
               }
            }
         }
      }
   }

   for (n=0; n<32; n++)
   {
      if (gpioNotify[n].state == 2)
      {
         if (gpioNotify[n].pipe)
         {
            { if ((gpioCfg.dbgLevel >= 5) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 5893 "pigpio.c" 3 4
           stderr
# 5893 "pigpio.c"
           , "%s %s: " "close notify pipe %d" "\n" , myTimeStamp(), __FUNCTION__ , gpioNotify[n].fd); };
            close(gpioNotify[n].fd);

            sprintf(fifo, "/dev/pigpio%d", n);

            unlink(fifo);
         }

         gpioNotify[n].state = 0;
      }
      else if (gpioNotify[n].state >= 3)
      {
         bits = gpioNotify[n].bits;

         emit = 0;

         seqno = gpioNotify[n].seqno;

         if (gpioNotify[n].state == 4)
         {







            if (changedBits & bits)
            {
               oldLevel = reportedLevel & bits;

               for (d=0; d<numSamples; d++)
               {
                  newLevel = sample[d].level & bits;

                  if (newLevel != oldLevel)
                  {
                     report[emit].seqno = seqno;
                     report[emit].flags = 0;
                     report[emit].tick = sample[d].tick;
                     report[emit].level = sample[d].level;

                     oldLevel = newLevel;

                     emit++;
                     seqno++;
                  }
               }
            }
# 5950 "pigpio.c"
            bits = gpioNotify[n].bits;

            if (timeoutBits & bits)
            {




               for (b=0; b<=31; b++)
               {
                  if (timeoutBits & bits & (1<<b))
                  {
                     if (numSamples)
                        newLevel = sample[numSamples-1].level;
                     else
                        newLevel = reportedLevel;

                     report[emit].seqno = seqno;
                     report[emit].flags =
                        (1 <<5) | (((b)<<0)&31);
                     report[emit].tick = eTick;
                     report[emit].level = newLevel;

                     emit++;
                     seqno++;
                  }
               }
            }
         }






         if (eventBits & gpioNotify[n].eventBits)
         {
            for (b=0; b<=31; b++)
            {
               if (eventBits & gpioNotify[n].eventBits & (1<<b))
               {
                  if (numSamples)
                     newLevel = sample[numSamples-1].level;
                  else
                     newLevel = reportedLevel;

                  report[emit].seqno = seqno;
                  report[emit].flags =
                     (1 <<7) | (((b)<<0)&31);
                  report[emit].tick = eTick;
                  report[emit].level = newLevel;

                  emit++;
                  seqno++;
               }
            }
         }

         if (!emit)
         {
            if ((int)(eTick - gpioNotify[n].lastReportTick) > 60000000)
            {
               if (numSamples)
                  newLevel = sample[numSamples-1].level;
               else
                  newLevel = reportedLevel;

               report[emit].seqno = seqno;
               report[emit].flags = (1 <<6);
               report[emit].tick = eTick;
               report[emit].level = newLevel;

               emit++;
               seqno++;
            }
         }

         if (emit)
         {
            { if ((gpioCfg.dbgLevel >= 7) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 6029 "pigpio.c" 3 4
           stderr
# 6029 "pigpio.c"
           , "%s %s: " "notification %d (%d reports, %x-%x)" "\n" , myTimeStamp(), __FUNCTION__ , n, emit, report[0].seqno, report[emit-1].seqno); }
                                                               ;
            gpioNotify[n].lastReportTick = eTick;
            max_emits = gpioNotify[n].max_emits;

            if (emit > gpioStats.maxEmit) gpioStats.maxEmit = emit;

            emitted = 0;

            while (emit > 0)
            {
               if (emit > max_emits)
               {
                  gpioStats.emitFrags++;

                  err = write(gpioNotify[n].fd,
                           report+emitted,
                           max_emits*sizeof(gpioReport_t));

                  if (err != (max_emits*sizeof(gpioReport_t)))
                  {
                     if (err < 0)
                     {
                        if ((
# 6052 "pigpio.c" 3 4
                            (*__errno_location ()) 
# 6052 "pigpio.c"
                                  != 
# 6052 "pigpio.c" 3 4
                                     11
# 6052 "pigpio.c"
                                           ) && (
# 6052 "pigpio.c" 3 4
                                                 (*__errno_location ()) 
# 6052 "pigpio.c"
                                                       != 
# 6052 "pigpio.c" 3 4
                                                          11
# 6052 "pigpio.c"
                                                                     ))
                        {


                           { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 6056 "pigpio.c" 3 4
                          stderr
# 6056 "pigpio.c"
                          , "%s %s: " "fd=%d err=%d errno=%d" "\n" , myTimeStamp(), __FUNCTION__ , gpioNotify[n].fd, err, 
# 6056 "pigpio.c" 3 4
                          (*__errno_location ())
# 6056 "pigpio.c"
                          ); }
                                                           ;

                           { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 6059 "pigpio.c" 3 4
                          stderr
# 6059 "pigpio.c"
                          , "%s %s: " "%s" "\n" , myTimeStamp(), __FUNCTION__ , strerror(
# 6059 "pigpio.c" 3 4
                          (*__errno_location ())
# 6059 "pigpio.c"
                          )); };

                           gpioNotify[n].bits = 0;
                           gpioNotify[n].state = 2;
                           intNotifyBits();
                           break;
                        }
                        else gpioStats.wouldBlockPipeWrite++;
                     }
                     else
                     {
                        gpioStats.shortPipeWrite++;
                        { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 6071 "pigpio.c" 3 4
                       stderr
# 6071 "pigpio.c"
                       , "%s %s: " "emitted %zd, asked for %d" "\n" , myTimeStamp(), __FUNCTION__ , err/sizeof(gpioReport_t), max_emits); }
                                                               ;
                     }
                  }
                  else
                  {
                     gpioStats.goodPipeWrite++;
                  }

                  emitted += max_emits;
                  emit -= max_emits;
               }
               else
               {
                  err = write(gpioNotify[n].fd,
                           report+emitted,
                           emit*sizeof(gpioReport_t));

                  if (err != (emit*sizeof(gpioReport_t)))
                  {
                     if (err < 0)
                     {
                        if ((
# 6093 "pigpio.c" 3 4
                            (*__errno_location ()) 
# 6093 "pigpio.c"
                                  != 
# 6093 "pigpio.c" 3 4
                                     11
# 6093 "pigpio.c"
                                           ) && (
# 6093 "pigpio.c" 3 4
                                                 (*__errno_location ()) 
# 6093 "pigpio.c"
                                                       != 
# 6093 "pigpio.c" 3 4
                                                          11
# 6093 "pigpio.c"
                                                                     ))
                        {
                           { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 6095 "pigpio.c" 3 4
                          stderr
# 6095 "pigpio.c"
                          , "%s %s: " "fd=%d err=%d errno=%d" "\n" , myTimeStamp(), __FUNCTION__ , gpioNotify[n].fd, err, 
# 6095 "pigpio.c" 3 4
                          (*__errno_location ())
# 6095 "pigpio.c"
                          ); }
                                                           ;

                           { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 6098 "pigpio.c" 3 4
                          stderr
# 6098 "pigpio.c"
                          , "%s %s: " "%s" "\n" , myTimeStamp(), __FUNCTION__ , strerror(
# 6098 "pigpio.c" 3 4
                          (*__errno_location ())
# 6098 "pigpio.c"
                          )); };


                           gpioNotify[n].bits = 0;
                           gpioNotify[n].state = 2;
                           intNotifyBits();
                           break;
                        }
                        else gpioStats.wouldBlockPipeWrite++;
                     }
                     else
                     {
                        gpioStats.shortPipeWrite++;
                        { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 6111 "pigpio.c" 3 4
                       stderr
# 6111 "pigpio.c"
                       , "%s %s: " "emitted %zd, asked for %d" "\n" , myTimeStamp(), __FUNCTION__ , err/sizeof(gpioReport_t), emit); }
                                                          ;
                     }
                  }
                  else
                  {
                     gpioStats.goodPipeWrite++;
                  }

                  emitted += emit;
                  emit = 0;
               }
            }

            gpioNotify[n].seqno = seqno;
         }
      }
   }

   if (changedBits & scriptBits)
   {
      for (n=0; n<32; n++)
      {
         if ((gpioScript[n].state == 2) &&
             (gpioScript[n].run_state == 3) &&
             (gpioScript[n].waitBits & changedBits))
         {
            pthread_mutex_lock(&gpioScript[n].pthMutex);

            if (gpioScript[n].run_state == 3)
            {
               gpioScript[n].changedBits =
                  gpioScript[n].waitBits & changedBits;
               pthread_cond_signal(&gpioScript[n].pthCond);
            }

            pthread_mutex_unlock(&gpioScript[n].pthMutex);
         }
      }
   }

   if (eventBits & scriptEventBits)
   {
      for (n=0; n<32; n++)
      {
         if ((gpioScript[n].state == 2) &&
             (gpioScript[n].run_state == 3) &&
             (gpioScript[n].eventBits & eventBits))
         {
            pthread_mutex_lock(&gpioScript[n].pthMutex);

            if (gpioScript[n].run_state == 3)
            {
               gpioScript[n].changedBits =
                  gpioScript[n].eventBits & eventBits;
               pthread_cond_signal(&gpioScript[n].pthCond);
            }

            pthread_mutex_unlock(&gpioScript[n].pthMutex);
         }
      }
   }

   if (numSamples) reportedLevel = sample[numSamples-1].level;
}

static void alertWdogCheck(gpioSample_t *sample, int numSamples)
{




   int i, j;
   uint32_t LBitV;
   uint32_t bit;

   for (i=0; i<=31; i++)
   {
      bit = (1<<i);

      if (monitorBits & bit & wdogBits)
      {
         LBitV = gpioAlert[i].wdLBitV;

         for (j=0; j<numSamples; j++)
         {
            if ((sample[j].level & bit) != LBitV)
            {
               LBitV = sample[j].level & bit;
               gpioAlert[i].wdTick = sample[j].tick;
            }
         }

         gpioAlert[i].wdLBitV = LBitV;
      }
   }
}

static void * pthAlertThread(void *x)
{
   struct timespec req, rem;
   uint32_t oldLevel, newLevel, level;
   uint32_t oldSlot, newSlot;
   uint32_t expected, ft, sTick;
   uint32_t changedBits;
   int32_t diff, minDiff, stickInited;
   int cycle, pulse;
   int numSamples, ticks, i;
   int rp, reports, totalSamples;
   int stopped;
   int moreToDo;
   gpioSample_t sample[4000];

   req.tv_sec = 0;



   spinWhileStarting();

   reportedLevel = gpioReg[13];

   oldLevel = reportedLevel;

   oldSlot = dmaCurrentSlot(dmaNowAtICB());

   oldSlot = (oldSlot / 25) * 25;

   cycle = (oldSlot/25);

   pulse = 0;

   stopped = 0;

   moreToDo = 0;

   stickInited = 0;

   sTick = 0;

   minDiff = gpioCfg.clockMicros / 2;

   while (1)
   {


      if (dmaIn[1])
      {
         if (stopped)
         {
            { if ((gpioCfg.dbgLevel >= 1) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 6260 "pigpio.c" 3 4
           stderr
# 6260 "pigpio.c"
           , "%s %s: " "****** GOING ******" "\n" , myTimeStamp(), __FUNCTION__); };
            stopped = 0;
         }
      }
      else
      {
         stopped = 1;

         myGpioDelay(5000);

         if (runState == 1)
         {


            gpioCfg.internals |= (1<<9);

            dmaInitCbs();
            flushMemory();


            initDMAgo((uint32_t *)dmaIn, (uint32_t)(uintptr_t)dmaIBus[0]);
            myGpioDelay(5000);
            oldSlot = dmaCurrentSlot(dmaNowAtICB());
            gpioStats.DMARestarts++;
         }
      }

      newSlot = dmaCurrentSlot(dmaNowAtICB());

      newSlot = (newSlot / 25) * 25;

      numSamples = 0;





      while ((oldSlot != newSlot) && (numSamples < 4000))
      {
         level = myGetLevel(oldSlot++);

         sample[numSamples].tick = sTick;
         sample[numSamples].level = level;

         numSamples++;

         sTick += gpioCfg.clockMicros;

         if (++pulse >= 25)
         {
            pulse = 0;

            if (++cycle >= bufferCycles)
            {
               cycle = 0;
               oldSlot = 0;
            }

            expected = sTick;

            sTick = myGetTick(cycle);

            if (stickInited)
            {
               diff = sTick - expected;

               if (abs(diff) > minDiff)
               {
                  ft = sample[numSamples-25].tick;

                  ticks = sTick - ft;

                  for (i=1; i<25; i++)
                  {
                     sample[numSamples-25 +i].tick =
                        ((i*ticks)/25) + ft;
                  }
               }

               diff += (50/2);

               if (diff < 0)
               {
                  gpioStats.diffTick[0]++;
               }

               else if (diff >= 50)
               {
                  gpioStats.diffTick[50 -1]++;
               }

               else gpioStats.diffTick[diff]++;
            }
            else
            {
               stickInited = 1;
               numSamples = 0;
               if (!(gpioCfg.ifFlags & 8))
               {
                  pthAlertRunning = 2;
               }
            }
         }
      }

      if (oldSlot == newSlot) moreToDo = 0; else moreToDo = 1;



      if (numSamples && gFilterBits) alertGlitchFilter(sample, numSamples);



      if (numSamples && nFilterBits) alertNoiseFilter(sample, numSamples);



      changedBits = 0;
      oldLevel &= monitorBits;
      reports = 0;
      totalSamples = 0;

      for (rp=0; rp<numSamples; rp++)
      {
         newLevel = (sample[rp].level & monitorBits);

         if (newLevel != oldLevel)
         {
            sample[reports].tick = sample[rp].tick;
            sample[reports].level = sample[rp].level;
            changedBits |= (newLevel ^ oldLevel);
            oldLevel = newLevel;

            reports++;

            if (reports >= 250)
            {
               totalSamples += reports;


               if (wdogBits) alertWdogCheck(sample, reports);

               gpioStats.numSamples += reports;

               alertEmit(sample, reports, changedBits, sample[rp].tick);

               changedBits = 0;
               reports = 0;
            }
         }
      }

      if (reports)
      {
         totalSamples += reports;


         if (wdogBits) alertWdogCheck(sample, reports);

         gpioStats.numSamples += reports;
      }

      alertEmit(sample, reports, changedBits, sTick);
      reportedLevel = sample[numSamples -1].level;

      if (totalSamples > gpioStats.maxSamples)
         gpioStats.maxSamples = numSamples;

      req.tv_sec = 0;
      req.tv_nsec = alert_delays[(gpioCfg.internals>>4)&15];

      if (moreToDo)
      {
         gpioStats.moreToDo++;
      }
      else
      {
         gpioStats.alertTicks++;

         while (nanosleep(&req, &rem))
         {
            req.tv_sec = rem.tv_sec;
            req.tv_nsec = rem.tv_nsec;
         }
      }
   }

   return 0;
}



static int scrPop(gpioScript_t *s, int *SP, int *S)
{
   if ((*SP) > 0)
   {
      return S[--(*SP)];
   }
   else
   {
      s->run_state = 4;
      { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 6461 "pigpio.c" 3 4
     stderr
# 6461 "pigpio.c"
     , "%s %s: " "script %d too many pops" "\n" , myTimeStamp(), __FUNCTION__ , s->id); };
      return 0;
   }
}



static void scrPush(gpioScript_t *s, int *SP, int *S, int val)
{
   if ((*SP) < 256)
   {
      S[(*SP)++] = val;
   }
   else
   {
      s->run_state = 4;
      { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 6477 "pigpio.c" 3 4
     stderr
# 6477 "pigpio.c"
     , "%s %s: " "script %d too many pushes" "\n" , myTimeStamp(), __FUNCTION__ , s->id); };
   }
}



static void scrSwap(int *v1, int *v2)
{
   int t;

   t=*v1; *v1=*v2; *v2= t;
}



static int scrEvtWait(gpioScript_t *s, uint32_t bits)
{
   pthread_mutex_lock(&s->pthMutex);

   if (s->request == 1)
   {
      s->run_state = 3;
      s->eventBits = bits;
      intScriptEventBits();

      pthread_cond_wait(&s->pthCond, &s->pthMutex);

      s->waitBits = 0;
      intScriptEventBits();
      s->run_state = 2;
   }

   pthread_mutex_unlock(&s->pthMutex);

   return s->changedBits;
}



static int scrWait(gpioScript_t *s, uint32_t bits)
{
   pthread_mutex_lock(&s->pthMutex);

   if (s->request == 1)
   {
      s->run_state = 3;
      s->waitBits = bits;
      intScriptBits();

      pthread_cond_wait(&s->pthCond, &s->pthMutex);

      s->waitBits = 0;
      intScriptBits();
      s->run_state = 2;
   }

   pthread_mutex_unlock(&s->pthMutex);

   return s->changedBits;
}



static int scrSys(char *cmd, uint32_t p1, uint32_t p2)
{
   char buf[1024];
   int status;

   if (!myScriptNameValid(cmd))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 6546 "pigpio.c" 3 4
     stderr
# 6546 "pigpio.c"
     , "%s %s: " "bad script name (%s)" "\n" , myTimeStamp(), __FUNCTION__ , cmd); }; return -140; } while (0);

   snprintf(buf, sizeof(buf), "/opt/pigpio/cgi/%s %u %u", cmd, p1, p2);

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 6550 "pigpio.c" 3 4
  stderr
# 6550 "pigpio.c"
  , "%s %s: " "%s" "\n" , myTimeStamp(), __FUNCTION__ , buf); };

   status = system(buf);

   if (status < 0) status = -139;

   return status;
}



static void *pthScript(void *x)
{
   gpioScript_t *s;
   cmdInstr_t instr;
   int p1, p2, p1o, p2o, p3o, *t1, *t2;
   int PC, A, F, SP;
   int S[256];
   char buf[(1<<16)];


   S[0] = 0;

   s = x;

   while ((volatile int)s->request != 2)
   {
      pthread_mutex_lock(&s->pthMutex);
      s->run_state = 1;
      pthread_cond_wait(&s->pthCond, &s->pthMutex);
      pthread_mutex_unlock(&s->pthMutex);

      s->run_state = 2;

      A = 0;
      F = 0;
      PC = 0;
      SP = 0;

      while (((volatile int)s->request == 1 ) &&
                           (s->run_state == 2))
      {
         instr = s->script.instr[PC];

         p1o = instr.p[1];
         p2o = instr.p[2];

         if (instr.opt[1] == 2) instr.p[1] = s->script.var[p1o];
         else if (instr.opt[1] == 3) instr.p[1] = s->script.par[p1o];

         if (instr.opt[2] == 2) instr.p[2] = s->script.var[p2o];
         else if (instr.opt[2] == 3) instr.p[2] = s->script.par[p2o];





         if (instr.p[0] < 800)
         {
            if (instr.p[3])
            {
               if ((instr.p[3] == sizeof(int)) && ((instr.opt[3] == 2) || (instr.opt[3] == 3)))
               {

                  memcpy((char*)&p3o, (char *)instr.p[4], sizeof(int));
                  if (instr.opt[3] == 2) memcpy(buf, (char *)&(s->script.var[p3o]), sizeof(int));
                  else memcpy(buf, (char *)&(s->script.par[p3o]), sizeof(int));
               }
               else
               {
                  memcpy(buf, (char *)instr.p[4], instr.p[3]);
               }
            }

            A = myDoCommand(instr.p, sizeof(buf)-1, buf);

            F = A;

            PC++;
         }
         else
         {
            p1 = instr.p[1];
            p2 = instr.p[2];

            switch (instr.p[0])
            {
               case 800: A+=p1; F=A; PC++; break;

               case 801: A&=p1; F=A; PC++; break;

               case 802: scrPush(s, &SP, S, PC+1); PC = p1; break;

               case 805: F=A-p1; PC++; break;

               case 806:
                  if (instr.opt[1] == 3)
                     {--s->script.par[p1o]; F=s->script.par[p1o];}
                  else
                     {--s->script.var[p1o]; F=s->script.var[p1o];}
                  PC++;
                  break;

               case 807: --A; F=A; PC++; break;

               case 808: A/=p1; F=A; PC++; break;

               case 809: s->run_state = 1; break;

               case 842: A=scrEvtWait(s, p1); F=A; PC++; break;

               case 810:
                  if (instr.opt[1] == 3)
                     {++s->script.par[p1o]; F=s->script.par[p1o];}
                  else
                     {++s->script.var[p1o]; F=s->script.var[p1o];}
                  PC++;
                  break;

               case 811: ++A; F=A; PC++; break;

               case 812: if (F<0) PC=p1; else PC++; break;

               case 813: PC=p1; break;

               case 814: if (F) PC=p1; else PC++; break;

               case 815: if (F>=0) PC=p1; else PC++; break;

               case 816: if (!F) PC=p1; else PC++; break;

               case 818:
                  if (instr.opt[1] == 3) s->script.par[p1o]=p2;
                  else s->script.var[p1o]=p2;
                  PC++;
                  break;

               case 819: A=p1; PC++; break;

               case 820:
                  if ((p1 >= 0) && (p1 < sizeof(buf))) A = buf[p1];
                  PC++;
                  break;

               case 821: A*=p1; F=A; PC++; break;

               case 822: A%=p1; F=A; PC++; break;

               case 824: A|=p1; F=A; PC++; break;

               case 825:
                  if (instr.opt[1] == 3)
                     s->script.par[p1o]=scrPop(s, &SP, S);
                  else
                     s->script.var[p1o]=scrPop(s, &SP, S);
                  PC++;
                  break;

               case 826: A=scrPop(s, &SP, S); PC++; break;

               case 827:
                  if (instr.opt[1] == 3)
                     scrPush(s, &SP, S, s->script.par[p1o]);
                  else
                     scrPush(s, &SP, S, s->script.var[p1o]);
                  PC++;
                  break;

               case 828: scrPush(s, &SP, S, A); PC++; break;

               case 829: PC=scrPop(s, &SP, S); break;

               case 830:
                  if (instr.opt[1] == 3)
                     {s->script.par[p1o]<<=p2; F=s->script.par[p1o];}
                  else
                     {s->script.var[p1o]<<=p2; F=s->script.var[p1o];}
                  PC++;
                  break;

               case 831: A<<=p1; F=A; PC++; break;

               case 832:
                  if (instr.opt[1] == 3)
                     {s->script.par[p1o]>>=p2; F=s->script.par[p1o];}
                  else
                     {s->script.var[p1o]>>=p2; F=s->script.var[p1o];}
                  PC++;
                  break;

               case 833: A>>=p1; F=A; PC++; break;

               case 834:
                  if (instr.opt[1] == 3) s->script.par[p1o]=A;
                  else s->script.var[p1o]=A;
                  PC++;
                  break;

               case 835:
                  if ((p1 >= 0) && (p1 < sizeof(buf))) buf[p1] = A;
                  PC++;
                  break;

               case 836: A-=p1; F=A; PC++; break;

               case 837:
                  A=scrSys((char*)instr.p[4], A, *(gpioReg + 13));
                  F=A;
                  PC++;
                  break;

               case 838: A=scrWait(s, p1); F=A; PC++; break;

               case 839:
                  if (instr.opt[1] == 3) t1 = &s->script.par[p1o];
                  else t1 = &s->script.var[p1o];

                  if (instr.opt[2] == 3) t2 = &s->script.par[p2o];
                  else t2 = &s->script.var[p2o];

                  scrSwap(t1, t2);
                  PC++;
                  break;

               case 840:
                  if (instr.opt[1] == 3)
                     scrSwap(&s->script.par[p1o], &A);
                  else
                     scrSwap(&s->script.var[p1o], &A);
                  PC++;
                  break;

               case 841: A^=p1; F=A; PC++; break;

            }
         }

         if (PC >= s->script.instrs) s->run_state = 1;

      }

      if ((volatile int)s->request == 0)
         s->run_state = 1;

   }

   return 0;
}



static void * pthTimerTick(void *x)
{
   gpioTimer_t *tp;
   struct timespec req, rem;

   tp = x;

   while (1)
   {
      req.tv_sec = tp->millis / 1000;
      req.tv_nsec = (tp->millis % 1000) * 1000 * 1000;

      while (nanosleep(&req, &rem))
      {
         req.tv_sec = rem.tv_sec;
         req.tv_nsec = rem.tv_nsec;
      }

      if (tp->ex) (tp->func)(tp->userdata);
      else (tp->func)();
   }

   return 0;
}




static void * pthFifoThread(void *x)
{
   char buf[(1<<16)];
   int idx, flags, len, res, i;
   uintptr_t p[10];
   cmdCtlParse_t ctl;
   uint32_t *param;
   char v[(1<<16)];

   myCreatePipe("/dev/pigpio", 0662);

   if ((inpFifo = fopen("/dev/pigpio", "r+")) == 
# 6840 "pigpio.c" 3 4
                                             ((void *)0)
# 6840 "pigpio.c"
                                                 )
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 6841 "pigpio.c" 3 4
     stderr
# 6841 "pigpio.c"
     , "%s %s: " "fopen %s failed(%m)" "\n" , myTimeStamp(), __FUNCTION__ , "/dev/pigpio"); }; return (void*)-1; } while (0);

   myCreatePipe("/dev/pigout", 0664);

   if ((outFifo = fopen("/dev/pigout", "w+")) == 
# 6845 "pigpio.c" 3 4
                                             ((void *)0)
# 6845 "pigpio.c"
                                                 )
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 6846 "pigpio.c" 3 4
     stderr
# 6846 "pigpio.c"
     , "%s %s: " "fopen %s failed (%m)" "\n" , myTimeStamp(), __FUNCTION__ , "/dev/pigout"); }; return (void*)-1; } while (0);



   flags = fcntl(fileno(outFifo), 
# 6850 "pigpio.c" 3 4
                                 3
# 6850 "pigpio.c"
                                        , 0);
   fcntl(fileno(outFifo), 
# 6851 "pigpio.c" 3 4
                         4
# 6851 "pigpio.c"
                                , flags | 
# 6851 "pigpio.c" 3 4
                                          04000
# 6851 "pigpio.c"
                                                    );



   spinWhileStarting();

   while (1)
   {
      if (fgets(buf, sizeof(buf), inpFifo) == 
# 6859 "pigpio.c" 3 4
                                             ((void *)0)
# 6859 "pigpio.c"
                                                 )
         do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 6860 "pigpio.c" 3 4
        stderr
# 6860 "pigpio.c"
        , "%s %s: " "fifo fgets failed (%m)" "\n" , myTimeStamp(), __FUNCTION__); }; return (void*)-1; } while (0);

      len = strlen(buf);

      if (len)
      {
        --len;
        buf[len] = 0;
      }

      ctl.eaten = 0;
      idx = 0;

      while (((ctl.eaten)<len) && (idx >= 0))
      {
         if ((idx=cmdParse(buf, p, (1<<16), v, &ctl)) >= 0)
         {


            v[p[3]] = 0;

            res = myDoCommand(p, sizeof(v)-1, v);

            switch (cmdInfo[idx].rv)
            {
               case 0:
                  fprintf(outFifo, "%d\n", res);
                  break;

               case 1:
                  fprintf(outFifo, "%d\n", res);
                  break;

               case 2:
                  fprintf(outFifo, "%d\n", res);
                  break;

               case 3:
                  fprintf(outFifo, "%08X\n", res);
                  break;

               case 4:
                  fprintf(outFifo, "%u\n", res);
                  break;

               case 5:
                  fprintf(outFifo, "%s", cmdUsage);
                  break;

               case 6:
                  fprintf(outFifo, "%d", res);
                  if (res > 0)
                  {
                     for (i=0; i<res; i++)
                     {
                        fprintf(outFifo, " %d", v[i]);
                     }
                  }
                  fprintf(outFifo, "\n");
                  break;

               case 7:
                  if (res < 0) fprintf(outFifo, "%d\n", res);
                  else
                  {
                     fprintf(outFifo, "%d", res);
                     param = (uint32_t *)v;
                     for (i=0; i<10; i++)
                     {
                        fprintf(outFifo, " %d", param[i]);
                     }
                     fprintf(outFifo, "\n");
                  }
                  break;
            }
         }
         else fprintf(outFifo, "%d\n", -29);
      }

      fflush(outFifo);
   }

   return 0;
}



static void *pthSocketThreadHandler(void *fdC)
{
   int sock = *(int*)fdC;
   uintptr_t p[10];
   uint32_t tmp, response[4];
   int i;
   int opt;
   char buf[(1<<16)];

   free(fdC);


   opt = 1;
   setsockopt(sock, 
# 6960 "pigpio.c" 3 4
                   IPPROTO_TCP
# 6960 "pigpio.c"
                              , 
# 6960 "pigpio.c" 3 4
                                1
# 6960 "pigpio.c"
                                           , (char*)&opt, sizeof(int));

   while (1)
   {
      if (sizeof(uintptr_t) == 8)
      {
         if (recv(sock, &tmp, 4, 
# 6966 "pigpio.c" 3 4
                                MSG_WAITALL
# 6966 "pigpio.c"
                                           ) != 4) break;
         p[0] = (uintptr_t)tmp;
         if (recv(sock, &tmp, 4, 
# 6968 "pigpio.c" 3 4
                                MSG_WAITALL
# 6968 "pigpio.c"
                                           ) != 4) break;
         p[1] = (uintptr_t)tmp;
         if (recv(sock, &tmp, 4, 
# 6970 "pigpio.c" 3 4
                                MSG_WAITALL
# 6970 "pigpio.c"
                                           ) != 4) break;
         p[2] = (uintptr_t)tmp;
         if (recv(sock, &tmp, 4, 
# 6972 "pigpio.c" 3 4
                                MSG_WAITALL
# 6972 "pigpio.c"
                                           ) != 4) break;
         p[3] = (uintptr_t)tmp;
      }
      else
      {
         if (recv(sock, p, 16, 
# 6977 "pigpio.c" 3 4
                              MSG_WAITALL
# 6977 "pigpio.c"
                                         ) != 16) break;
      }

      if (p[3])
      {
         if (p[3] < sizeof(buf))
         {

            if (recv(sock, buf, p[3], 
# 6985 "pigpio.c" 3 4
                                     MSG_WAITALL
# 6985 "pigpio.c"
                                                ) != p[3])
            {

               { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 6988 "pigpio.c" 3 4
              stderr
# 6988 "pigpio.c"
              , "%s %s: " "recv failed for %"
# 6988 "pigpio.c" 3 4
              "l" "d"
# 6988 "pigpio.c"
              " bytes, sock=%d" "\n" , myTimeStamp(), __FUNCTION__ , p[3], sock); }
                                                                          ;

               closeOrphanedNotifications(-1, sock);

               close(sock);

               return 0;
            }
         }
         else
         {

            { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7001 "pigpio.c" 3 4
           stderr
# 7001 "pigpio.c"
           , "%s %s: " "ext too large %"
# 7001 "pigpio.c" 3 4
           "l" "d"
# 7001 "pigpio.c"
           "(%zd), sock=%d" "\n" , myTimeStamp(), __FUNCTION__ , p[3], sizeof(buf), sock); }
                                       ;

            closeOrphanedNotifications(-1, sock);

            close(sock);

            return 0;
         }
      }



      buf[p[3]] = 0;

      switch (p[0])
      {
         case 99:

            p[3] = gpioNotifyOpenInBand(sock);


            opt = 0;
            setsockopt(
               sock, 
# 7025 "pigpio.c" 3 4
                    IPPROTO_TCP
# 7025 "pigpio.c"
                               , 
# 7025 "pigpio.c" 3 4
                                 1
# 7025 "pigpio.c"
                                            , (char*)&opt, sizeof(int));

            break;

         case 45:
            p[3] = myDoCommand(p, sizeof(buf)-1, buf+sizeof(int));
            if (((int)p[3]) >= 0)
            {
               memcpy(buf, &p[3], 4);
               p[3] = 4 + (4*10);
            }
            break;

         default:
            p[3] = myDoCommand(p, sizeof(buf)-1, buf);
      }

      if (sizeof(uintptr_t) == 8)
      {
         for (i = 0; i < 4; i++)
            response[i] = (uint32_t)p[i];
         if (write(sock, response, 16) == -1) { }
      }
      else
      {
         if (write(sock, p, 16) == -1) { }
      }

      switch (p[0])
      {


         case 91:
         case 114:
         case 88:
         case 109:
         case 106:
         case 70:
         case 56:
         case 67:
         case 65:
         case 92:
         case 45:
         case 80:
         case 43:
         case 75:
         case 73:
         case 113:

            if (((int)p[3]) > 0)
            {
               if (write(sock, buf, p[3]) == 1) { }
            }
            break;

         default:
           break;
      }
   }

   closeOrphanedNotifications(-1, sock);

   close(sock);

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7089 "pigpio.c" 3 4
  stderr
# 7089 "pigpio.c"
  , "%s %s: " "Socket %d closed" "\n" , myTimeStamp(), __FUNCTION__ , sock); };

   return 0;
}

static int addrAllowed(struct sockaddr *saddr)
{
   int i;
   uint32_t addr;

   if (!numSockNetAddr) return 1;


   if (saddr->sa_family != 
# 7102 "pigpio.c" 3 4
                          2
# 7102 "pigpio.c"
                                 ) return 0;

   addr = ((struct sockaddr_in *) saddr)->sin_addr.s_addr;

   for (i=0; i<numSockNetAddr; i++)
   {
      if (addr == sockNetAddr[i]) return 1;
   }
   return 0;
}



static void * pthSocketThread(void *x)
{
   int fdC=0, c, *sock;
   struct sockaddr_storage client;
   pthread_attr_t attr;

   if (pthread_attr_init(&attr))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7122 "pigpio.c" 3 4
     stderr
# 7122 "pigpio.c"
     , "%s %s: " "pthread_attr_init failed (%m)" "\n" , myTimeStamp(), __FUNCTION__); }; return (void*)-1; } while (0)
                                         ;

   if (pthread_attr_setstacksize(&attr, (256*1024)))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7126 "pigpio.c" 3 4
     stderr
# 7126 "pigpio.c"
     , "%s %s: " "pthread_attr_setstacksize failed (%m)" "\n" , myTimeStamp(), __FUNCTION__); }; return (void*)-1; } while (0)
                                                 ;

   if (pthread_attr_setdetachstate(&attr, 
# 7129 "pigpio.c" 3 4
                                         PTHREAD_CREATE_DETACHED
# 7129 "pigpio.c"
                                                                ))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7130 "pigpio.c" 3 4
     stderr
# 7130 "pigpio.c"
     , "%s %s: " "pthread_attr_setdetachstate failed (%m)" "\n" , myTimeStamp(), __FUNCTION__); }; return (void*)-1; } while (0)
                                                   ;




   listen(fdSock, 100);

   c = sizeof(client);



   spinWhileStarting();

   while (fdC >= 0)
   {
      pthread_t thr;

      fdC = accept(fdSock, (struct sockaddr *)&client, (socklen_t*)&c);

      closeOrphanedNotifications(-1, fdC);

      if (addrAllowed((struct sockaddr *)&client))
      {
         { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7154 "pigpio.c" 3 4
        stderr
# 7154 "pigpio.c"
        , "%s %s: " "Connection accepted on socket %d" "\n" , myTimeStamp(), __FUNCTION__ , fdC); };

         sock = malloc(sizeof(int));

         *sock = fdC;


         int optval = 1;
         socklen_t optlen = sizeof(optval);

         if (setsockopt(fdC, 
# 7164 "pigpio.c" 3 4
                            1
# 7164 "pigpio.c"
                                      , 
# 7164 "pigpio.c" 3 4
                                        9
# 7164 "pigpio.c"
                                                    , &optval, optlen) < 0)
         {
           { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7166 "pigpio.c" 3 4
          stderr
# 7166 "pigpio.c"
          , "%s %s: " "setsockopt() fail, closing socket %d" "\n" , myTimeStamp(), __FUNCTION__ , fdC); };
           close(fdC);
         }

         { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7170 "pigpio.c" 3 4
        stderr
# 7170 "pigpio.c"
        , "%s %s: " "SO_KEEPALIVE enabled on socket %d\n" "\n" , myTimeStamp(), __FUNCTION__ , fdC); };

         if (pthread_create
            (&thr, &attr, pthSocketThreadHandler, (void*) sock) < 0)
            do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7174 "pigpio.c" 3 4
           stderr
# 7174 "pigpio.c"
           , "%s %s: " "socket pthread_create failed (%m)" "\n" , myTimeStamp(), __FUNCTION__); }; return (void*)-1; } while (0)
                                                   ;
      }
      else
      {
         { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7179 "pigpio.c" 3 4
        stderr
# 7179 "pigpio.c"
        , "%s %s: " "Connection rejected, closing" "\n" , myTimeStamp(), __FUNCTION__); };
         close(fdC);
      }
   }

   if (fdC < 0)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7185 "pigpio.c" 3 4
     stderr
# 7185 "pigpio.c"
     , "%s %s: " "accept failed (%m)" "\n" , myTimeStamp(), __FUNCTION__); }; return (void*)-1; } while (0);

   return 0;
}



static void initCheckLockFile(void)
{
   int fd;
   int count;
   int pid;
   int err;
   int delete;
   char str[20];

   fd = open("/var/run/pigpio.pid", 
# 7201 "pigpio.c" 3 4
                         00
# 7201 "pigpio.c"
                                 );

   if (fd != -1)
   {
      { if ((gpioCfg.dbgLevel >= 1) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7205 "pigpio.c" 3 4
     stderr
# 7205 "pigpio.c"
     , "%s %s: " "lock file exists" "\n" , myTimeStamp(), __FUNCTION__); };
      delete = 1;

      count = read(fd, str, sizeof(str)-1);

      if (count)
      {
         pid = atoi(str);
         err = kill(pid, 0);
         if (!err) delete = 0;
         { if ((gpioCfg.dbgLevel >= 1) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7215 "pigpio.c" 3 4
        stderr
# 7215 "pigpio.c"
        , "%s %s: " "lock file pid=%d err=%d" "\n" , myTimeStamp(), __FUNCTION__ , pid, err); };
      }

      close(fd);
      { if ((gpioCfg.dbgLevel >= 1) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7219 "pigpio.c" 3 4
     stderr
# 7219 "pigpio.c"
     , "%s %s: " "lock file delete=%d" "\n" , myTimeStamp(), __FUNCTION__ , delete); };

      if (delete) unlink("/var/run/pigpio.pid");
   }
}

static int initGrabLockFile(void)
{
   int fd;
   int lockResult;
   char pidStr[20];

   initCheckLockFile();



   fd = open("/var/run/pigpio.pid", 
# 7235 "pigpio.c" 3 4
                         01
# 7235 "pigpio.c"
                                 |
# 7235 "pigpio.c" 3 4
                                  0100
# 7235 "pigpio.c"
                                         |
# 7235 "pigpio.c" 3 4
                                          0200
# 7235 "pigpio.c"
                                                |
# 7235 "pigpio.c" 3 4
                                                 01000
# 7235 "pigpio.c"
                                                        , 0644);

   if (fd != -1)
   {
      lockResult = flock(fd, 
# 7239 "pigpio.c" 3 4
                            2
# 7239 "pigpio.c"
                                   |
# 7239 "pigpio.c" 3 4
                                    4
# 7239 "pigpio.c"
                                           );

      if(lockResult == 0)
      {
         sprintf(pidStr, "%d\n", (int)getpid());

         if (write(fd, pidStr, strlen(pidStr)) == -1)
         {

         }
      }
      else
      {
         close(fd);
         return -1;
      }
   }

   return fd;
}



static uint32_t * initMapMem(int fd, uint32_t addr, uint32_t len)
{
    return (uint32_t *) mmap(0, len,
       
# 7265 "pigpio.c" 3 4
      0x1
# 7265 "pigpio.c"
               |
# 7265 "pigpio.c" 3 4
                0x2
# 7265 "pigpio.c"
                          |
# 7265 "pigpio.c" 3 4
                           0x4
# 7265 "pigpio.c"
                                    ,
       
# 7266 "pigpio.c" 3 4
      0x01
# 7266 "pigpio.c"
                |
# 7266 "pigpio.c" 3 4
                 0x02000
# 7266 "pigpio.c"
                           ,
       fd, addr);
}



static int initCheckPermitted(void)
{
   { if ((gpioCfg.dbgLevel >= 1) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7274 "pigpio.c" 3 4
  stderr
# 7274 "pigpio.c"
  , "%s %s: " "" "\n" , myTimeStamp(), __FUNCTION__); };

   if (!pi_ispi)
   {
      { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7278 "pigpio.c" 3 4
     stderr
# 7278 "pigpio.c"
     , "%s %s: " "\n" "+---------------------------------------------------------+\n" "|Sorry, this system does not appear to be a raspberry pi. |\n" "|aborting.                                                |\n" "+---------------------------------------------------------+\n\n" "\n" , myTimeStamp(), __FUNCTION__); }




                                                                           ;
      return -1;
   }

   if ((fdMem = open("/dev/mem", 
# 7287 "pigpio.c" 3 4
                                02 
# 7287 "pigpio.c"
                                       | 
# 7287 "pigpio.c" 3 4
                                         04010000
# 7287 "pigpio.c"
                                               ) ) < 0)
   {
      { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7289 "pigpio.c" 3 4
     stderr
# 7289 "pigpio.c"
     , "%s %s: " "\n" "+---------------------------------------------------------+\n" "|Sorry, you don't have permission to run this program.    |\n" "|Try running as root, e.g. precede the command with sudo. |\n" "+---------------------------------------------------------+\n\n" "\n" , myTimeStamp(), __FUNCTION__); }




                                                                           ;
      return -1;
   }
   return 0;
}



static int initPeripherals(void)
{
   { if ((gpioCfg.dbgLevel >= 1) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7304 "pigpio.c" 3 4
  stderr
# 7304 "pigpio.c"
  , "%s %s: " "" "\n" , myTimeStamp(), __FUNCTION__); };

   gpioReg = initMapMem(fdMem, (pi_peri_phys + 0x00200000), 0xF4);

   if (gpioReg == 
# 7308 "pigpio.c" 3 4
                 ((void *) -1)
# 7308 "pigpio.c"
                           )
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7309 "pigpio.c" 3 4
     stderr
# 7309 "pigpio.c"
     , "%s %s: " "mmap gpio failed (%m)" "\n" , myTimeStamp(), __FUNCTION__); }; return -1; } while (0);

   dmaReg = initMapMem(fdMem, (pi_peri_phys + 0x00007000), 0x1000);

   if (dmaReg == 
# 7313 "pigpio.c" 3 4
                ((void *) -1)
# 7313 "pigpio.c"
                          )
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7314 "pigpio.c" 3 4
     stderr
# 7314 "pigpio.c"
     , "%s %s: " "mmap dma failed (%m)" "\n" , myTimeStamp(), __FUNCTION__); }; return -1; } while (0);



   if (gpioCfg.DMAprimaryChannel == 15)
   {
      if (pi_is_2711)
         gpioCfg.DMAprimaryChannel = 7;
      else
         gpioCfg.DMAprimaryChannel = 14;
   }

   if (gpioCfg.DMAsecondaryChannel == 15)
   {
      if (pi_is_2711)
         gpioCfg.DMAsecondaryChannel = 6;
      else
         gpioCfg.DMAsecondaryChannel = 6;
   }

   dmaIn = dmaReg + (gpioCfg.DMAprimaryChannel * 0x40);
   dmaOut = dmaReg + (gpioCfg.DMAsecondaryChannel * 0x40);

   { if ((gpioCfg.dbgLevel >= 1) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7337 "pigpio.c" 3 4
  stderr
# 7337 "pigpio.c"
  , "%s %s: " "DMA #%d @ %08"
# 7337 "pigpio.c" 3 4
  "l" "X" 
# 7337 "pigpio.c"
  "\n" , myTimeStamp(), __FUNCTION__ , gpioCfg.DMAprimaryChannel, (uintptr_t)dmaIn); }
                                                  ;

   { if ((gpioCfg.dbgLevel >= 1) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7340 "pigpio.c" 3 4
  stderr
# 7340 "pigpio.c"
  , "%s %s: " "debug reg is %08X" "\n" , myTimeStamp(), __FUNCTION__ , dmaIn[8]); };

   clkReg = initMapMem(fdMem, (pi_peri_phys + 0x00101000), 0xA8);

   if (clkReg == 
# 7344 "pigpio.c" 3 4
                ((void *) -1)
# 7344 "pigpio.c"
                          )
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7345 "pigpio.c" 3 4
     stderr
# 7345 "pigpio.c"
     , "%s %s: " "mmap clk failed (%m)" "\n" , myTimeStamp(), __FUNCTION__); }; return -1; } while (0);

   systReg = initMapMem(fdMem, (pi_peri_phys + 0x00003000), 0x1C);

   if (systReg == 
# 7349 "pigpio.c" 3 4
                 ((void *) -1)
# 7349 "pigpio.c"
                           )
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7350 "pigpio.c" 3 4
     stderr
# 7350 "pigpio.c"
     , "%s %s: " "mmap syst failed (%m)" "\n" , myTimeStamp(), __FUNCTION__); }; return -1; } while (0);

   spiReg = initMapMem(fdMem, (pi_peri_phys + 0x00204000), 0x18);

   if (spiReg == 
# 7354 "pigpio.c" 3 4
                ((void *) -1)
# 7354 "pigpio.c"
                          )
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7355 "pigpio.c" 3 4
     stderr
# 7355 "pigpio.c"
     , "%s %s: " "mmap spi failed (%m)" "\n" , myTimeStamp(), __FUNCTION__); }; return -1; } while (0);

   pwmReg = initMapMem(fdMem, (pi_peri_phys + 0x0020C000), 0x28);

   if (pwmReg == 
# 7359 "pigpio.c" 3 4
                ((void *) -1)
# 7359 "pigpio.c"
                          )
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7360 "pigpio.c" 3 4
     stderr
# 7360 "pigpio.c"
     , "%s %s: " "mmap pwm failed (%m)" "\n" , myTimeStamp(), __FUNCTION__); }; return -1; } while (0);

   pcmReg = initMapMem(fdMem, (pi_peri_phys + 0x00203000), 0x24);

   if (pcmReg == 
# 7364 "pigpio.c" 3 4
                ((void *) -1)
# 7364 "pigpio.c"
                          )
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7365 "pigpio.c" 3 4
     stderr
# 7365 "pigpio.c"
     , "%s %s: " "mmap pcm failed (%m)" "\n" , myTimeStamp(), __FUNCTION__); }; return -1; } while (0);

   auxReg = initMapMem(fdMem, (pi_peri_phys + 0x00215000), 0xD8);

   if (auxReg == 
# 7369 "pigpio.c" 3 4
                ((void *) -1)
# 7369 "pigpio.c"
                          )
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7370 "pigpio.c" 3 4
     stderr
# 7370 "pigpio.c"
     , "%s %s: " "mmap aux failed (%m)" "\n" , myTimeStamp(), __FUNCTION__); }; return -1; } while (0);

   padsReg = initMapMem(fdMem, (pi_peri_phys + 0x00100000), 0x38);

   if (padsReg == 
# 7374 "pigpio.c" 3 4
                 ((void *) -1)
# 7374 "pigpio.c"
                           )
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7375 "pigpio.c" 3 4
     stderr
# 7375 "pigpio.c"
     , "%s %s: " "mmap pads failed (%m)" "\n" , myTimeStamp(), __FUNCTION__); }; return -1; } while (0);

   bscsReg = initMapMem(fdMem, (pi_peri_phys + 0x00214000), 0x40);

   if (bscsReg == 
# 7379 "pigpio.c" 3 4
                 ((void *) -1)
# 7379 "pigpio.c"
                           )
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7380 "pigpio.c" 3 4
     stderr
# 7380 "pigpio.c"
     , "%s %s: " "mmap bscs failed (%m)" "\n" , myTimeStamp(), __FUNCTION__); }; return -1; } while (0);

   return 0;
}



static int initZaps
   (int pmapFd, void *virtualBase, int basePage, int pages)
{
   int n;
   uintptr_t index;
   off_t offset;
   ssize_t t;
   uint32_t physical;
   int status;
   uintptr_t pageAdr;
   unsigned long long pa;

   { if ((gpioCfg.dbgLevel >= 1) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7399 "pigpio.c" 3 4
  stderr
# 7399 "pigpio.c"
  , "%s %s: " "" "\n" , myTimeStamp(), __FUNCTION__); };

   status = 0;

   pageAdr = (uintptr_t) dmaVirt[basePage];

   index = ((uintptr_t)virtualBase / 4096) * 8;

   offset = lseek(pmapFd, index, 
# 7407 "pigpio.c" 3 4
                                0
# 7407 "pigpio.c"
                                        );

   if (offset != index)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7410 "pigpio.c" 3 4
     stderr
# 7410 "pigpio.c"
     , "%s %s: " "lseek pagemap failed (%m)" "\n" , myTimeStamp(), __FUNCTION__); }; return -1; } while (0);

   for (n=0; n<pages; n++)
   {
      t = read(pmapFd, &pa, sizeof(pa));

      if (t != sizeof(pa))
         do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7417 "pigpio.c" 3 4
        stderr
# 7417 "pigpio.c"
        , "%s %s: " "read pagemap failed (%m)" "\n" , myTimeStamp(), __FUNCTION__); }; return -1; } while (0);

      { if ((gpioCfg.dbgLevel >= 1) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7419 "pigpio.c" 3 4
     stderr
# 7419 "pigpio.c"
     , "%s %s: " "pf%d=%016llX" "\n" , myTimeStamp(), __FUNCTION__ , n, pa); };

      physical = 0x3FFFFFFF & (4096 * (pa & 0xFFFFFFFF));

      if (physical)
      {


         dmaBus[basePage+n] = (dmaPage_t *)(uintptr_t) (physical | pi_dram_bus);

         dmaVirt[basePage+n] = mmap
         (
            (void *)pageAdr,
            4096,
            
# 7433 "pigpio.c" 3 4
           0x1
# 7433 "pigpio.c"
                    |
# 7433 "pigpio.c" 3 4
                     0x2
# 7433 "pigpio.c"
                               ,
            
# 7434 "pigpio.c" 3 4
           0x01
# 7434 "pigpio.c"
                     |
# 7434 "pigpio.c" 3 4
                      0x10
# 7434 "pigpio.c"
                               |
# 7434 "pigpio.c" 3 4
                                0x02000
# 7434 "pigpio.c"
                                          |
# 7434 "pigpio.c" 3 4
                                           0x04000
# 7434 "pigpio.c"
                                                        ,
            fdMem,
            physical
         );
      }
      else status = 1;

      pageAdr += 4096;
   }

   return status;
}



static int initPagemapBlock(int block)
{
   int trys, ok;
   unsigned pageNum;

   { if ((gpioCfg.dbgLevel >= 1) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7454 "pigpio.c" 3 4
  stderr
# 7454 "pigpio.c"
  , "%s %s: " "block=%d" "\n" , myTimeStamp(), __FUNCTION__ , block); };

   dmaPMapBlk[block] = mmap(
       0, (53*4096),
       
# 7458 "pigpio.c" 3 4
      0x1
# 7458 "pigpio.c"
               |
# 7458 "pigpio.c" 3 4
                0x2
# 7458 "pigpio.c"
                          ,
       
# 7459 "pigpio.c" 3 4
      0x01
# 7459 "pigpio.c"
                |
# 7459 "pigpio.c" 3 4
                 0x20
# 7459 "pigpio.c"
                              |
# 7459 "pigpio.c" 3 4
                               0x04000
# 7459 "pigpio.c"
                                            |
# 7459 "pigpio.c" 3 4
                                             0x02000
# 7459 "pigpio.c"
                                                       ,
       -1, 0);

   if (dmaPMapBlk[block] == 
# 7462 "pigpio.c" 3 4
                           ((void *) -1)
# 7462 "pigpio.c"
                                     )
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7463 "pigpio.c" 3 4
     stderr
# 7463 "pigpio.c"
     , "%s %s: " "mmap dma block %d failed (%m)" "\n" , myTimeStamp(), __FUNCTION__ , block); }; return -1; } while (0);



   memset((void *)dmaPMapBlk[block], 0xAA, (53*4096));

   memset((void *)dmaPMapBlk[block], 0xFF, (53*4096));

   memset((void *)dmaPMapBlk[block], 0, (53*4096));

   pageNum = block * 53;

   dmaVirt[pageNum] = mmap(
       0, (53*4096),
       
# 7477 "pigpio.c" 3 4
      0x1
# 7477 "pigpio.c"
               |
# 7477 "pigpio.c" 3 4
                0x2
# 7477 "pigpio.c"
                          ,
       
# 7478 "pigpio.c" 3 4
      0x01
# 7478 "pigpio.c"
                |
# 7478 "pigpio.c" 3 4
                 0x20
# 7478 "pigpio.c"
                              |
# 7478 "pigpio.c" 3 4
                               0x04000
# 7478 "pigpio.c"
                                            |
# 7478 "pigpio.c" 3 4
                                             0x02000
# 7478 "pigpio.c"
                                                       ,
       -1, 0);

   if (dmaVirt[pageNum] == 
# 7481 "pigpio.c" 3 4
                          ((void *) -1)
# 7481 "pigpio.c"
                                    )
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7482 "pigpio.c" 3 4
     stderr
# 7482 "pigpio.c"
     , "%s %s: " "mmap dma block %d failed (%m)" "\n" , myTimeStamp(), __FUNCTION__ , block); }; return -1; } while (0);

   munmap(dmaVirt[pageNum], 53*4096);

   trys = 0;
   ok = 0;

   while ((trys < 10) && !ok)
   {
      if (initZaps(fdPmap,
                    dmaPMapBlk[block],
                    pageNum,
                    53) == 0) ok = 1;
      else myGpioDelay(50000);

      ++trys;
   }

   if (!ok) do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7500 "pigpio.c" 3 4
           stderr
# 7500 "pigpio.c"
           , "%s %s: " "initZaps failed" "\n" , myTimeStamp(), __FUNCTION__); }; return -1; } while (0);

   return 0;
}

static int initMboxBlock(int block)
{
   int n, ok;
   unsigned page;
   uintptr_t virtualAdr;
   uintptr_t busAdr;

   { if ((gpioCfg.dbgLevel >= 1) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7512 "pigpio.c" 3 4
  stderr
# 7512 "pigpio.c"
  , "%s %s: " "block=%d" "\n" , myTimeStamp(), __FUNCTION__ , block); };

   ok = mbDMAAlloc
      (&dmaMboxBlk[block], 53 * 4096, pi_mem_flag);

   if (!ok) do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7517 "pigpio.c" 3 4
           stderr
# 7517 "pigpio.c"
           , "%s %s: " "init mbox zaps failed" "\n" , myTimeStamp(), __FUNCTION__); }; return -1; } while (0);

   page = block * 53;

   virtualAdr = (uintptr_t) dmaMboxBlk[block].virtual_addr;
   busAdr = dmaMboxBlk[block].bus_addr;

   for (n=0; n<53; n++)
   {
      dmaVirt[page+n] = (dmaPage_t *) virtualAdr;
      dmaBus[page+n] = (dmaPage_t *) busAdr;
      virtualAdr += 4096;
      busAdr += 4096;
   }

   return 0;
}



static int initAllocDMAMem(void)
{
   int i, servoCycles, superCycles;
   int status;

   { if ((gpioCfg.dbgLevel >= 1) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7542 "pigpio.c" 3 4
  stderr
# 7542 "pigpio.c"
  , "%s %s: " "" "\n" , myTimeStamp(), __FUNCTION__); };





   servoCycles = gpioCfg.bufferMilliseconds / 20;
   if (gpioCfg.bufferMilliseconds % 20) servoCycles++;

   bufferCycles = (800 * servoCycles) / gpioCfg.clockMicros;

   superCycles = bufferCycles / 800;
   if (bufferCycles % 800) superCycles++;

   bufferCycles = 800 * superCycles;

   bufferBlocks = bufferCycles / 80;

   { if ((gpioCfg.dbgLevel >= 1) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7560 "pigpio.c" 3 4
  stderr
# 7560 "pigpio.c"
  , "%s %s: " "bmillis=%d mics=%d bblk=%d bcyc=%d" "\n" , myTimeStamp(), __FUNCTION__ , gpioCfg.bufferMilliseconds, gpioCfg.clockMicros, bufferBlocks, bufferCycles); }

                                 ;



   dmaVirt = mmap(
       0, 53*(bufferBlocks+4)*sizeof(dmaPage_t *),
       
# 7568 "pigpio.c" 3 4
      0x1
# 7568 "pigpio.c"
               |
# 7568 "pigpio.c" 3 4
                0x2
# 7568 "pigpio.c"
                          ,
       
# 7569 "pigpio.c" 3 4
      0x02
# 7569 "pigpio.c"
                 |
# 7569 "pigpio.c" 3 4
                  0x20
# 7569 "pigpio.c"
                               |
# 7569 "pigpio.c" 3 4
                                0x02000
# 7569 "pigpio.c"
                                          ,
       -1, 0);

   if (dmaVirt == 
# 7572 "pigpio.c" 3 4
                 ((void *) -1)
# 7572 "pigpio.c"
                           )
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7573 "pigpio.c" 3 4
     stderr
# 7573 "pigpio.c"
     , "%s %s: " "mmap dma virtual failed (%m)" "\n" , myTimeStamp(), __FUNCTION__); }; return -1; } while (0);

   dmaBus = mmap(
       0, 53*(bufferBlocks+4)*sizeof(dmaPage_t *),
       
# 7577 "pigpio.c" 3 4
      0x1
# 7577 "pigpio.c"
               |
# 7577 "pigpio.c" 3 4
                0x2
# 7577 "pigpio.c"
                          ,
       
# 7578 "pigpio.c" 3 4
      0x02
# 7578 "pigpio.c"
                 |
# 7578 "pigpio.c" 3 4
                  0x20
# 7578 "pigpio.c"
                               |
# 7578 "pigpio.c" 3 4
                                0x02000
# 7578 "pigpio.c"
                                          ,
       -1, 0);

   if (dmaBus == 
# 7581 "pigpio.c" 3 4
                ((void *) -1)
# 7581 "pigpio.c"
                          )
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7582 "pigpio.c" 3 4
     stderr
# 7582 "pigpio.c"
     , "%s %s: " "mmap dma bus failed (%m)" "\n" , myTimeStamp(), __FUNCTION__); }; return -1; } while (0);

   dmaIVirt = (dmaIPage_t **) dmaVirt;
   dmaIBus = (dmaIPage_t **) dmaBus;

   dmaOVirt = (dmaOPage_t **)(dmaVirt + (53*bufferBlocks));
   dmaOBus = (dmaOPage_t **)(dmaBus + (53*bufferBlocks));

   if ((gpioCfg.memAllocMode == 1) ||
       ((gpioCfg.memAllocMode == 0) &&
        (gpioCfg.bufferMilliseconds > 120)))
   {


      dmaPMapBlk = mmap(
          0, (bufferBlocks+4)*sizeof(dmaPage_t *),
          
# 7598 "pigpio.c" 3 4
         0x1
# 7598 "pigpio.c"
                  |
# 7598 "pigpio.c" 3 4
                   0x2
# 7598 "pigpio.c"
                             ,
          
# 7599 "pigpio.c" 3 4
         0x02
# 7599 "pigpio.c"
                    |
# 7599 "pigpio.c" 3 4
                     0x20
# 7599 "pigpio.c"
                                  |
# 7599 "pigpio.c" 3 4
                                   0x02000
# 7599 "pigpio.c"
                                             ,
          -1, 0);

      if (dmaPMapBlk == 
# 7602 "pigpio.c" 3 4
                       ((void *) -1)
# 7602 "pigpio.c"
                                 )
         do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7603 "pigpio.c" 3 4
        stderr
# 7603 "pigpio.c"
        , "%s %s: " "pagemap mmap block failed (%m)" "\n" , myTimeStamp(), __FUNCTION__); }; return -1; } while (0);

      fdPmap = open("/proc/self/pagemap", 
# 7605 "pigpio.c" 3 4
                                         00
# 7605 "pigpio.c"
                                                 );

      if (fdPmap < 0)
         do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7608 "pigpio.c" 3 4
        stderr
# 7608 "pigpio.c"
        , "%s %s: " "pagemap open failed(%m)" "\n" , myTimeStamp(), __FUNCTION__); }; return -1; } while (0);

      for (i=0; i<(bufferBlocks+4); i++)
      {
         status = initPagemapBlock(i);
         if (status < 0)
         {
            close(fdPmap);
            return status;
         }
      }

      close(fdPmap);

      { if ((gpioCfg.dbgLevel >= 1) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7622 "pigpio.c" 3 4
     stderr
# 7622 "pigpio.c"
     , "%s %s: " "dmaPMapBlk=%08"
# 7622 "pigpio.c" 3 4
     "l" "X"
# 7622 "pigpio.c"
     " dmaIn=%08"
# 7622 "pigpio.c" 3 4
     "l" "X" 
# 7622 "pigpio.c"
     "\n" , myTimeStamp(), __FUNCTION__ , (uintptr_t)dmaPMapBlk, (uintptr_t)dmaIn); }
                                                 ;
   }
   else
   {


      dmaMboxBlk = mmap(
          0, (bufferBlocks+4)*sizeof(DMAMem_t),
          
# 7631 "pigpio.c" 3 4
         0x1
# 7631 "pigpio.c"
                  |
# 7631 "pigpio.c" 3 4
                   0x2
# 7631 "pigpio.c"
                             ,
          
# 7632 "pigpio.c" 3 4
         0x02
# 7632 "pigpio.c"
                    |
# 7632 "pigpio.c" 3 4
                     0x20
# 7632 "pigpio.c"
                                  |
# 7632 "pigpio.c" 3 4
                                   0x02000
# 7632 "pigpio.c"
                                             ,
          -1, 0);

      if (dmaMboxBlk == 
# 7635 "pigpio.c" 3 4
                       ((void *) -1)
# 7635 "pigpio.c"
                                 )
         do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7636 "pigpio.c" 3 4
        stderr
# 7636 "pigpio.c"
        , "%s %s: " "mmap mbox block failed (%m)" "\n" , myTimeStamp(), __FUNCTION__); }; return -1; } while (0);

      fdMbox = mbOpen();

      if (fdMbox < 0)
         do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7641 "pigpio.c" 3 4
        stderr
# 7641 "pigpio.c"
        , "%s %s: " "mbox open failed(%m)" "\n" , myTimeStamp(), __FUNCTION__); }; return -1; } while (0);

      for (i=0; i<(bufferBlocks+4); i++)
      {
         status = initMboxBlock(i);
         if (status < 0)
         {
            mbClose(fdMbox);
            return status;
         }
      }

      mbClose(fdMbox);

      { if ((gpioCfg.dbgLevel >= 1) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7655 "pigpio.c" 3 4
     stderr
# 7655 "pigpio.c"
     , "%s %s: " "dmaMboxBlk=%08"
# 7655 "pigpio.c" 3 4
     "l" "X"
# 7655 "pigpio.c"
     " dmaIn=%08"
# 7655 "pigpio.c" 3 4
     "l" "X" 
# 7655 "pigpio.c"
     "\n" , myTimeStamp(), __FUNCTION__ , (uintptr_t)dmaMboxBlk, (uintptr_t)dmaIn); }
                                                 ;
   }

   { if ((gpioCfg.dbgLevel >= 1) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7659 "pigpio.c" 3 4
  stderr
# 7659 "pigpio.c"
  , "%s %s: " "gpioReg=%08"
# 7659 "pigpio.c" 3 4
  "l" "X"
# 7659 "pigpio.c"
  " pwmReg=%08"
# 7659 "pigpio.c" 3 4
  "l" "X"
# 7659 "pigpio.c"
  " pcmReg=%08"
# 7659 "pigpio.c" 3 4
  "l" "X"
# 7659 "pigpio.c"
  " clkReg=%08"
# 7659 "pigpio.c" 3 4
  "l" "X"
# 7659 "pigpio.c"
  " auxReg=%08"
# 7659 "pigpio.c" 3 4
  "l" "X" 
# 7659 "pigpio.c"
  "\n" , myTimeStamp(), __FUNCTION__ , (uintptr_t)gpioReg, (uintptr_t)pwmReg, (uintptr_t)pcmReg, (uintptr_t)clkReg, (uintptr_t)auxReg); }


                                                               ;

   for (i=0; i<(53 * bufferBlocks); i++)
      { if ((gpioCfg.dbgLevel >= 1) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7665 "pigpio.c" 3 4
     stderr
# 7665 "pigpio.c"
     , "%s %s: " "dmaIBus[%d]=%08"
# 7665 "pigpio.c" 3 4
     "l" "X" 
# 7665 "pigpio.c"
     "\n" , myTimeStamp(), __FUNCTION__ , i, (uintptr_t)dmaIBus[i]); };

   if (gpioCfg.dbgLevel >= 2)
   {
      fprintf(
# 7669 "pigpio.c" 3 4
             stderr
# 7669 "pigpio.c"
                   , "*** INPUT DMA CONTROL BLOCKS ***\n");
      for (i=0; i<(((25*3)+2) * bufferCycles); i++) dmaCbPrint(i);
   }

   return 0;
}



static void initPWM(unsigned bits)
{
   { if ((gpioCfg.dbgLevel >= 1) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7680 "pigpio.c" 3 4
  stderr
# 7680 "pigpio.c"
  , "%s %s: " "bits=%d" "\n" , myTimeStamp(), __FUNCTION__ , bits); };



   pwmReg[0] = 0;

   myGpioDelay(10);

   pwmReg[1] = -1;

   myGpioDelay(10);



   pwmReg[4] = bits;

   myGpioDelay(10);

   dmaIVirt[0]->periphData = 1;



   pwmReg[2] = (1 <<31) |
                      ((15)<< 8) |
                      (15);

   myGpioDelay(10);



   pwmReg[0] = (1<<6);

   myGpioDelay(10);



   pwmReg[0] = (1<<5) | (1<<1) | (1<<0);
}



static void initPCM(unsigned bits)
{
   { if ((gpioCfg.dbgLevel >= 1) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7723 "pigpio.c" 3 4
  stderr
# 7723 "pigpio.c"
  , "%s %s: " "bits=%d" "\n" , myTimeStamp(), __FUNCTION__ , bits); };



   pcmReg[0] = 0;

   myGpioDelay(1000);

   pcmReg[1] = 0;
   pcmReg[2] = 0;
   pcmReg[3] = 0;
   pcmReg[4] = 0;
   pcmReg[5] = 0;
   pcmReg[6] = 0;
   pcmReg[7] = 0;
   pcmReg[8] = 0;

   myGpioDelay(1000);

   pcmReg[2] = ((bits-1)<<10);



   pcmReg[4] = (1 <<30) | ((bits-8)<<16);

   pcmReg[0] |= (1 <<25);

   myGpioDelay(1000);

   pcmReg[0] |= (1 <<3);

   pcmReg[0] |= (1 <<9);

   pcmReg[5] = ((16)<<24) | ((30)<< 8);

   pcmReg[7] = 15;



   pcmReg[0] |= (1 <<0);



   pcmReg[0] |= (1 <<2);

   dmaIVirt[0]->periphData = 0x0F;
}



static void initHWClk
   (int clkCtl, int clkDiv, int clkSrc, int divI, int divF, int MASH)
{
   { if ((gpioCfg.dbgLevel >= 5) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7776 "pigpio.c" 3 4
  stderr
# 7776 "pigpio.c"
  , "%s %s: " "ctl=%d div=%d src=%d /I=%d /f=%d M=%d" "\n" , myTimeStamp(), __FUNCTION__ , clkCtl, clkDiv, clkSrc, divI, divF, MASH); }
                                               ;



   if (clkReg[clkCtl] & (1 <<7))
   {
      do
      {
         clkReg[clkCtl] = (0x5A<<24) | (1 <<5);
      }
      while (clkReg[clkCtl] & (1 <<7));
   }

   clkReg[clkDiv] = ((0x5A<<24) | ((divI)<<12) | ((divF)<< 0));

   usleep(10);

   clkReg[clkCtl] = ((0x5A<<24) | ((MASH)<<9) | ((clkSrc)<<0));

   usleep(10);

   clkReg[clkCtl] |= ((0x5A<<24) | (1 <<4));
}

static void initClock(int mainClock)
{
   const unsigned BITS=10;
   int clockPWM;
   unsigned clkCtl, clkDiv, clkSrc, clkDivI, clkDivF, clkMash, clkBits;
   char *per;
   unsigned micros;

   { if ((gpioCfg.dbgLevel >= 1) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7809 "pigpio.c" 3 4
  stderr
# 7809 "pigpio.c"
  , "%s %s: " "mainClock=%d" "\n" , myTimeStamp(), __FUNCTION__ , mainClock); };

   if (mainClock) micros = gpioCfg.clockMicros;
   else micros = 1;

   clockPWM = mainClock ^ (gpioCfg.clockPeriph == 1);

   if (clockPWM)
   {
      clkCtl = 40;
      clkDiv = 41;
      per = "PWM";
   }
   else
   {
      clkCtl = 38;
      clkDiv = 39;
      per = "PCM";
   }

   clkSrc = 6;
   clkDivI = clk_plld_freq / (10000000 / micros);
   clkBits = BITS;
   clkDivF = 0;
   clkMash = 0;

   { if ((gpioCfg.dbgLevel >= 1) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7835 "pigpio.c" 3 4
  stderr
# 7835 "pigpio.c"
  , "%s %s: " "%s PLLD divi=%d divf=%d mash=%d bits=%d" "\n" , myTimeStamp(), __FUNCTION__ , per, clkDivI, clkDivF, clkMash, clkBits); }
                                              ;

   initHWClk(clkCtl, clkDiv, clkSrc, clkDivI, clkDivF, clkMash);

   if (clockPWM) initPWM(BITS);
   else initPCM(BITS);

   myGpioDelay(2000);
}

static void initKillDMA(volatile uint32_t *dmaAddr)
{
   dmaAddr[0] = (1<<30);
   dmaAddr[0] = 0;
   dmaAddr[0] = (1<<31);

   dmaAddr[1] = 0;
}



static void initDMAgo(volatile uint32_t *dmaAddr, uint32_t cbAddr)
{
   { if ((gpioCfg.dbgLevel >= 1) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7859 "pigpio.c" 3 4
  stderr
# 7859 "pigpio.c"
  , "%s %s: " "" "\n" , myTimeStamp(), __FUNCTION__); };

   initKillDMA(dmaAddr);

   dmaAddr[0] = (1<< 2) | (1<< 1);

   dmaAddr[1] = cbAddr;



   dmaAddr[8] = (1<<2) |
                        (1<<1) |
                        (1<<0);


   dmaAddr[0] = (1<<28) |
                     ((8)<<20) |
                     ((8)<<16) |
                     (1<< 0);
}



static void initClearGlobals(void)
{
   int i;

   { if ((gpioCfg.dbgLevel >= 1) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7886 "pigpio.c" 3 4
  stderr
# 7886 "pigpio.c"
  , "%s %s: " "" "\n" , myTimeStamp(), __FUNCTION__); };

   alertBits = 0;
   monitorBits = 0;
   notifyBits = 0;
   scriptBits = 0;
   gFilterBits = 0;
   nFilterBits = 0;
   wdogBits = 0;

   pthAlertRunning = 0;
   pthFifoRunning = 0;
   pthSocketRunning = 0;

   wfc[0] = 0;
   wfc[1] = 0;
   wfc[2] = 0;

   wfcur=0;

   wfStats.micros = 0;
   wfStats.highMicros = 0;
   wfStats.maxMicros = (30 * 60 * 1000000);

   wfStats.pulses = 0;
   wfStats.highPulses = 0;
   wfStats.maxPulses = (4 * 3000);

   wfStats.cbs = 0;
   wfStats.highCbs = 0;
   wfStats.maxCbs = (4 * 53 * 118);

   gpioGetSamples.func = 
# 7918 "pigpio.c" 3 4
                            ((void *)0)
# 7918 "pigpio.c"
                                ;
   gpioGetSamples.ex = 0;
   gpioGetSamples.userdata = 
# 7920 "pigpio.c" 3 4
                            ((void *)0)
# 7920 "pigpio.c"
                                ;
   gpioGetSamples.bits = 0;

   for (i=0; i<=31; i++)
   {
      wfRx[i].mode = 0;
      pthread_mutex_init(&wfRx[i].mutex, 
# 7926 "pigpio.c" 3 4
                                        ((void *)0)
# 7926 "pigpio.c"
                                            );
      gpioAlert[i].func = 
# 7927 "pigpio.c" 3 4
                         ((void *)0)
# 7927 "pigpio.c"
                             ;
   }

   for (i=0; i<=53; i++)
   {
      gpioInfo [i].is = 0;
      gpioInfo [i].width = 0;
      gpioInfo [i].range = 255;
      gpioInfo [i].freqIdx = 5;
   }

   for (i=0; i<32; i++)
   {
      gpioNotify[i].seqno = 0;
      gpioNotify[i].state = 0;
   }

   for (i=0; i<=63; i++)
   {
      gpioSignal[i].func = 
# 7946 "pigpio.c" 3 4
                              ((void *)0)
# 7946 "pigpio.c"
                                  ;
      gpioSignal[i].ex = 0;
      gpioSignal[i].userdata = 
# 7948 "pigpio.c" 3 4
                              ((void *)0)
# 7948 "pigpio.c"
                                  ;
   }

   for (i=0; i<=9; i++)
   {
      gpioTimer[i].running = 0;
      gpioTimer[i].func = 
# 7954 "pigpio.c" 3 4
                            ((void *)0)
# 7954 "pigpio.c"
                                ;
   }

   for (i=0; i<=31; i++)
   {
      eventAlert[i].func = 
# 7959 "pigpio.c" 3 4
                               ((void *)0)
# 7959 "pigpio.c"
                                   ;
      eventAlert[i].ignore = 0;
      eventAlert[i].fired = 0;
   }



   for (i=0; i<18; i++)
   {
      pwmFreq[i]=
         (1000000.0/
            ((float)25*gpioCfg.clockMicros*pwmCycles[i]))+0.5;

      { if ((gpioCfg.dbgLevel >= 1) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 7972 "pigpio.c" 3 4
     stderr
# 7972 "pigpio.c"
     , "%s %s: " "f%d is %d" "\n" , myTimeStamp(), __FUNCTION__ , i, pwmFreq[i]); };
   }

   inpFifo = 
# 7975 "pigpio.c" 3 4
            ((void *)0)
# 7975 "pigpio.c"
                ;
   outFifo = 
# 7976 "pigpio.c" 3 4
            ((void *)0)
# 7976 "pigpio.c"
                ;

   fdLock = -1;
   fdMem = -1;
   fdSock = -1;

   dmaMboxBlk = 
# 7982 "pigpio.c" 3 4
               ((void *) -1)
# 7982 "pigpio.c"
                         ;
   dmaPMapBlk = 
# 7983 "pigpio.c" 3 4
               ((void *) -1)
# 7983 "pigpio.c"
                         ;
   dmaVirt = 
# 7984 "pigpio.c" 3 4
            ((void *) -1)
# 7984 "pigpio.c"
                      ;
   dmaBus = 
# 7985 "pigpio.c" 3 4
            ((void *) -1)
# 7985 "pigpio.c"
                      ;

   auxReg = 
# 7987 "pigpio.c" 3 4
            ((void *) -1)
# 7987 "pigpio.c"
                      ;
   clkReg = 
# 7988 "pigpio.c" 3 4
            ((void *) -1)
# 7988 "pigpio.c"
                      ;
   dmaReg = 
# 7989 "pigpio.c" 3 4
            ((void *) -1)
# 7989 "pigpio.c"
                      ;
   gpioReg = 
# 7990 "pigpio.c" 3 4
            ((void *) -1)
# 7990 "pigpio.c"
                      ;
   pcmReg = 
# 7991 "pigpio.c" 3 4
            ((void *) -1)
# 7991 "pigpio.c"
                      ;
   pwmReg = 
# 7992 "pigpio.c" 3 4
            ((void *) -1)
# 7992 "pigpio.c"
                      ;
   systReg = 
# 7993 "pigpio.c" 3 4
            ((void *) -1)
# 7993 "pigpio.c"
                      ;
   spiReg = 
# 7994 "pigpio.c" 3 4
            ((void *) -1)
# 7994 "pigpio.c"
                      ;
}



static void initReleaseResources(void)
{
   int i;

   { if ((gpioCfg.dbgLevel >= 1) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8003 "pigpio.c" 3 4
  stderr
# 8003 "pigpio.c"
  , "%s %s: " "" "\n" , myTimeStamp(), __FUNCTION__); };



   for (i=0; i<=53; i++)
   {
      if (gpioISR[i].pth)
      {


         gpioSetISRFunc(i, 0, 0, 
# 8013 "pigpio.c" 3 4
                                ((void *)0)
# 8013 "pigpio.c"
                                    );
      }
   }

   for (i=0; i<=9; i++)
   {
      if (gpioTimer[i].running)
      {


         pthread_cancel(gpioTimer[i].pthId);
         pthread_join(gpioTimer[i].pthId, 
# 8024 "pigpio.c" 3 4
                                         ((void *)0)
# 8024 "pigpio.c"
                                             );
         gpioTimer[i].running = 0;
      }
   }

   if (pthAlertRunning != 0)
   {
      pthread_cancel(pthAlert);
      pthread_join(pthAlert, 
# 8032 "pigpio.c" 3 4
                            ((void *)0)
# 8032 "pigpio.c"
                                );
      pthAlertRunning = 0;
   }

   if (pthFifoRunning != 0)
   {
      pthread_cancel(pthFifo);
      pthread_join(pthFifo, 
# 8039 "pigpio.c" 3 4
                           ((void *)0)
# 8039 "pigpio.c"
                               );
      pthFifoRunning = 0;
   }

   if (pthSocketRunning != 0)
   {
      pthread_cancel(pthSocket);
      pthread_join(pthSocket, 
# 8046 "pigpio.c" 3 4
                             ((void *)0)
# 8046 "pigpio.c"
                                 );
      pthSocketRunning = 0;
   }



   if (auxReg != 
# 8052 "pigpio.c" 3 4
                 ((void *) -1)
# 8052 "pigpio.c"
                           ) munmap((void *)auxReg, 0xD8);
   if (bscsReg != 
# 8053 "pigpio.c" 3 4
                 ((void *) -1)
# 8053 "pigpio.c"
                           ) munmap((void *)bscsReg, 0x40);
   if (clkReg != 
# 8054 "pigpio.c" 3 4
                 ((void *) -1)
# 8054 "pigpio.c"
                           ) munmap((void *)clkReg, 0xA8);
   if (dmaReg != 
# 8055 "pigpio.c" 3 4
                 ((void *) -1)
# 8055 "pigpio.c"
                           ) munmap((void *)dmaReg, 0x1000);
   if (gpioReg != 
# 8056 "pigpio.c" 3 4
                 ((void *) -1)
# 8056 "pigpio.c"
                           ) munmap((void *)gpioReg, 0xF4);
   if (pcmReg != 
# 8057 "pigpio.c" 3 4
                 ((void *) -1)
# 8057 "pigpio.c"
                           ) munmap((void *)pcmReg, 0x24);
   if (pwmReg != 
# 8058 "pigpio.c" 3 4
                 ((void *) -1)
# 8058 "pigpio.c"
                           ) munmap((void *)pwmReg, 0x28);
   if (systReg != 
# 8059 "pigpio.c" 3 4
                 ((void *) -1)
# 8059 "pigpio.c"
                           ) munmap((void *)systReg, 0x1C);
   if (spiReg != 
# 8060 "pigpio.c" 3 4
                 ((void *) -1)
# 8060 "pigpio.c"
                           ) munmap((void *)spiReg, 0x18);

   auxReg = 
# 8062 "pigpio.c" 3 4
            ((void *) -1)
# 8062 "pigpio.c"
                      ;
   bscsReg = 
# 8063 "pigpio.c" 3 4
            ((void *) -1)
# 8063 "pigpio.c"
                      ;
   clkReg = 
# 8064 "pigpio.c" 3 4
            ((void *) -1)
# 8064 "pigpio.c"
                      ;
   dmaReg = 
# 8065 "pigpio.c" 3 4
            ((void *) -1)
# 8065 "pigpio.c"
                      ;
   gpioReg = 
# 8066 "pigpio.c" 3 4
            ((void *) -1)
# 8066 "pigpio.c"
                      ;
   pcmReg = 
# 8067 "pigpio.c" 3 4
            ((void *) -1)
# 8067 "pigpio.c"
                      ;
   pwmReg = 
# 8068 "pigpio.c" 3 4
            ((void *) -1)
# 8068 "pigpio.c"
                      ;
   systReg = 
# 8069 "pigpio.c" 3 4
            ((void *) -1)
# 8069 "pigpio.c"
                      ;
   spiReg = 
# 8070 "pigpio.c" 3 4
            ((void *) -1)
# 8070 "pigpio.c"
                      ;

   if (dmaBus != 
# 8072 "pigpio.c" 3 4
                ((void *) -1)
# 8072 "pigpio.c"
                          )
   {
      munmap(dmaBus,
         53*(bufferBlocks+4)*sizeof(dmaPage_t *));
   }

   dmaBus = 
# 8078 "pigpio.c" 3 4
           ((void *) -1)
# 8078 "pigpio.c"
                     ;

   if (dmaVirt != 
# 8080 "pigpio.c" 3 4
                 ((void *) -1)
# 8080 "pigpio.c"
                           )
   {
      for (i=0; i<53*(bufferBlocks+4); i++)
      {
         munmap(dmaVirt[i], 4096);
      }

      munmap(dmaVirt,
         53*(bufferBlocks+4)*sizeof(dmaPage_t *));
   }

   dmaVirt = 
# 8091 "pigpio.c" 3 4
            ((void *) -1)
# 8091 "pigpio.c"
                      ;

   if (dmaPMapBlk != 
# 8093 "pigpio.c" 3 4
                    ((void *) -1)
# 8093 "pigpio.c"
                              )
   {
      for (i=0; i<(bufferBlocks+4); i++)
      {
         munmap(dmaPMapBlk[i], 53*4096);
      }

      munmap(dmaPMapBlk, (bufferBlocks+4)*sizeof(dmaPage_t *));
   }

   dmaPMapBlk = 
# 8103 "pigpio.c" 3 4
               ((void *) -1)
# 8103 "pigpio.c"
                         ;

   if (dmaMboxBlk != 
# 8105 "pigpio.c" 3 4
                    ((void *) -1)
# 8105 "pigpio.c"
                              )
   {
      fdMbox = mbOpen();

      for (i=0; i<(bufferBlocks+4); i++)
      {
         mbDMAFree(&dmaMboxBlk[bufferBlocks+4 -i-1]);
      }

      mbClose(fdMbox);

      munmap(dmaMboxBlk, (bufferBlocks+4)*sizeof(DMAMem_t));
   }

   dmaMboxBlk = 
# 8119 "pigpio.c" 3 4
               ((void *) -1)
# 8119 "pigpio.c"
                         ;

   if (inpFifo != 
# 8121 "pigpio.c" 3 4
                 ((void *)0)
# 8121 "pigpio.c"
                     )
   {
      fclose(inpFifo);
      unlink("/dev/pigpio");
      inpFifo = 
# 8125 "pigpio.c" 3 4
               ((void *)0)
# 8125 "pigpio.c"
                   ;
   }

   if (outFifo != 
# 8128 "pigpio.c" 3 4
                 ((void *)0)
# 8128 "pigpio.c"
                     )
   {
      fclose(outFifo);
      unlink("/dev/pigout");
      outFifo = 
# 8132 "pigpio.c" 3 4
               ((void *)0)
# 8132 "pigpio.c"
                   ;
   }

   if (fdMem != -1)
   {
      close(fdMem);
      fdMem = -1;
   }

   if (fdLock != -1)
   {
      close(fdLock);
      unlink("/var/run/pigpio.pid");
      fdLock = -1;
   }

   if (fdSock != -1)
   {
      close(fdSock);
      fdSock = -1;
   }

   if (fdPmap != -1)
   {
      close(fdPmap);
      fdPmap = -1;
   }

   if (fdMbox != -1)
   {
      close(fdMbox);
      fdMbox = -1;
   }

   gpioStats.DMARestarts = 0;
   gpioStats.dmaInitCbsCount = 0;

   numSockNetAddr = 0;
}

int initInitialise(void)
{
   int i;
   unsigned rev, model;
   struct sockaddr_in server;
   struct sockaddr_in6 server6;
   char * portStr;
   unsigned port;
   struct sched_param param;
   pthread_attr_t pthAttr;

   { if ((gpioCfg.dbgLevel >= 1) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8183 "pigpio.c" 3 4
  stderr
# 8183 "pigpio.c"
  , "%s %s: " "" "\n" , myTimeStamp(), __FUNCTION__); };

   waveClockInited = 0;
   PWMClockInited = 0;

   clock_gettime(
# 8188 "pigpio.c" 3 4
                0
# 8188 "pigpio.c"
                              , &libStarted);

   rev = gpioHardwareRevision();

   initClearGlobals();

   if (initCheckPermitted() < 0) return -1;

   fdLock = initGrabLockFile();

   if (fdLock < 0)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8199 "pigpio.c" 3 4
     stderr
# 8199 "pigpio.c"
     , "%s %s: " "Can't lock %s" "\n" , myTimeStamp(), __FUNCTION__ , "/var/run/pigpio.pid"); }; return -1; } while (0);

   if (!gpioMaskSet)
   {
      if (rev == 0) gpioMask = 0x0000000FFFFFFCLL;
      else if (rev < 4) gpioMask = 0x03E7CF93;
      else if (rev < 16) gpioMask = 0xFBC7CF9C;
      else if (rev == 17) gpioMask = 0x00FFFFFFFFFFFFLL;
      else if (rev < 20) gpioMask = 0x0080480FFFFFFCLL;
      else if (rev == 20) gpioMask = 0x00FFFFFFFFFFFFLL;
      else if (rev == 21) gpioMask = 0x0080480FFFFFFCLL;
      else
      {
         model = (rev >> 4) & 0xFF;
# 8228 "pigpio.c"
         if (model < 2) gpioMask = 0xFBC7CF9C;
         else if (model < 4) gpioMask = 0x0080480FFFFFFCLL;
         else if (model == 4) gpioMask = 0x0080480FFFFFFCLL;

         else if (model == 6
               || model ==10
               || model ==16) gpioMask = 0x00FFFFFFFFFFFFLL;

         else if (model == 8
               || model ==13
               || model ==14) gpioMask = 0x0000000FFFFFFCLL;

         else if (model == 9
               || model ==12) gpioMask = 0x0080000FFFFFFCLL;

         else if (model ==17) gpioMask = 0x0000000FFFFFFCLL;
         else gpioMask = 0x0000000FFFFFFCLL;
      }

      gpioMaskSet = 1;
   }


   if (!(gpioCfg.internals & (1<<10)))
      sigSetHandler();


   if (initPeripherals() < 0) return -1;

   if (initAllocDMAMem() < 0) return -1;



   if (fdMem != -1)
   {
      close(fdMem);
      fdMem = -1;
   }

   param.
# 8267 "pigpio.c" 3 4
        sched_priority 
# 8267 "pigpio.c"
                       = sched_get_priority_max(
# 8267 "pigpio.c" 3 4
                                                1
# 8267 "pigpio.c"
                                                          );

   if (gpioCfg.internals & (1<<8))
      sched_setscheduler(0, 
# 8270 "pigpio.c" 3 4
                           1
# 8270 "pigpio.c"
                                     , &param);

   initClock(1);

   atexit(gpioTerminate);

   if (pthread_attr_init(&pthAttr))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8277 "pigpio.c" 3 4
     stderr
# 8277 "pigpio.c"
     , "%s %s: " "pthread_attr_init failed (%m)" "\n" , myTimeStamp(), __FUNCTION__); }; return -1; } while (0);

   if (pthread_attr_setstacksize(&pthAttr, (256*1024)))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8280 "pigpio.c" 3 4
     stderr
# 8280 "pigpio.c"
     , "%s %s: " "pthread_attr_setstacksize failed (%m)" "\n" , myTimeStamp(), __FUNCTION__); }; return -1; } while (0);

   if (!(gpioCfg.ifFlags & 8))
   {
      if (pthread_create(&pthAlert, &pthAttr, pthAlertThread, &i))
         do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8285 "pigpio.c" 3 4
        stderr
# 8285 "pigpio.c"
        , "%s %s: " "pthread_create alert failed (%m)" "\n" , myTimeStamp(), __FUNCTION__); }; return -1; } while (0);

      pthAlertRunning = 1;
   }

   if (!(gpioCfg.ifFlags & 1))
   {
      if (pthread_create(&pthFifo, &pthAttr, pthFifoThread, &i))
         do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8293 "pigpio.c" 3 4
        stderr
# 8293 "pigpio.c"
        , "%s %s: " "pthread_create fifo failed (%m)" "\n" , myTimeStamp(), __FUNCTION__); }; return -1; } while (0);

      pthFifoRunning = 1;
   }

   if (!(gpioCfg.ifFlags & 2))
   {
      portStr = getenv("PIGPIO_PORT");
      if (portStr) port = atoi(portStr); else port = gpioCfg.socketPort;


      if (!numSockNetAddr)
      {
         fdSock = socket(
# 8306 "pigpio.c" 3 4
                        10
# 8306 "pigpio.c"
                                , 
# 8306 "pigpio.c" 3 4
                                  SOCK_STREAM 
# 8306 "pigpio.c"
                                              , 0);

         if (fdSock != -1)
         {
            bzero((char *)&server6, sizeof(server6));
            server6.sin6_family = 
# 8311 "pigpio.c" 3 4
                                 10
# 8311 "pigpio.c"
                                         ;
            if (gpioCfg.ifFlags & 4)
            {
               server6.sin6_addr = in6addr_loopback;
            }
            else
            {
               server6.sin6_addr = in6addr_any;
            }
            server6.sin6_port = 
# 8320 "pigpio.c" 3 4
                               __bswap_16 (
# 8320 "pigpio.c"
                               port
# 8320 "pigpio.c" 3 4
                               )
# 8320 "pigpio.c"
                                          ;

            int opt = 1;
            setsockopt(fdSock, 
# 8323 "pigpio.c" 3 4
                              1
# 8323 "pigpio.c"
                                        , 
# 8323 "pigpio.c" 3 4
                                          2
# 8323 "pigpio.c"
                                                      , &opt, sizeof(opt));
            if (bind(fdSock,(struct sockaddr *)&server6, sizeof(server6)) < 0)
               do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8325 "pigpio.c" 3 4
              stderr
# 8325 "pigpio.c"
              , "%s %s: " "bind to port %d failed (%m)" "\n" , myTimeStamp(), __FUNCTION__ , port); }; return -1; } while (0);
         }
      }

      if (numSockNetAddr || fdSock == -1)
      {
         fdSock = socket(
# 8331 "pigpio.c" 3 4
                        2 
# 8331 "pigpio.c"
                                , 
# 8331 "pigpio.c" 3 4
                                  SOCK_STREAM 
# 8331 "pigpio.c"
                                              , 0);

         if (fdSock == -1)
            do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8334 "pigpio.c" 3 4
           stderr
# 8334 "pigpio.c"
           , "%s %s: " "socket failed (%m)" "\n" , myTimeStamp(), __FUNCTION__); }; return -1; } while (0);
         else
         {
           int opt = 1;
           setsockopt(fdSock, 
# 8338 "pigpio.c" 3 4
                             1
# 8338 "pigpio.c"
                                       , 
# 8338 "pigpio.c" 3 4
                                         2
# 8338 "pigpio.c"
                                                     , &opt, sizeof(opt));
         }
         server.sin_family = 
# 8340 "pigpio.c" 3 4
                            2
# 8340 "pigpio.c"
                                   ;
         if (gpioCfg.ifFlags & 4)
         {
            server.sin_addr.s_addr = 
# 8343 "pigpio.c" 3 4
                                    __bswap_32 (((in_addr_t) 0x7f000001))
# 8343 "pigpio.c"
                                                          ;
         }
         else
         {
            server.sin_addr.s_addr = 
# 8347 "pigpio.c" 3 4
                                    __bswap_32 (((in_addr_t) 0x00000000))
# 8347 "pigpio.c"
                                                     ;
         }
         server.sin_port = 
# 8349 "pigpio.c" 3 4
                          __bswap_16 (
# 8349 "pigpio.c"
                          port
# 8349 "pigpio.c" 3 4
                          )
# 8349 "pigpio.c"
                                     ;

         if (bind(fdSock,(struct sockaddr *)&server , sizeof(server)) < 0)
            do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8352 "pigpio.c" 3 4
           stderr
# 8352 "pigpio.c"
           , "%s %s: " "bind to port %d failed (%m)" "\n" , myTimeStamp(), __FUNCTION__ , port); }; return -1; } while (0);
      }

      if (pthread_create(&pthSocket, &pthAttr, pthSocketThread, &i))
         do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8356 "pigpio.c" 3 4
        stderr
# 8356 "pigpio.c"
        , "%s %s: " "pthread_create socket failed (%m)" "\n" , myTimeStamp(), __FUNCTION__); }; return -1; } while (0);

      pthSocketRunning = 1;
   }

   myGpioDelay(1000);

   dmaInitCbs();

   flushMemory();




   initDMAgo((uint32_t *)dmaIn, (uint32_t)(uintptr_t)dmaIBus[0]);

   return 7401;
}




int getBitInBytes(int bitPos, char *buf, int numBits)
{
   int bitp, bufp;

   if (bitPos < numBits)
   {
      bufp = bitPos / 8;
      bitp = 7 - (bitPos % 8);
      if (buf[bufp] & (1<<bitp)) return 1;
   }

   return 0;
}



void putBitInBytes(int bitPos, char *buf, int bit)
{
   int bitp, bufp;

   bufp = bitPos / 8;
   bitp = 7 - (bitPos % 8);

   if (bit) buf[bufp] |= (1<<bitp);
   else buf[bufp] &= (~(1<<bitp));
}



uint32_t rawWaveGetOOL(int pos)
{
   int page, slot;

   if ((pos >= 0) && (pos < ((53 * 4) * 79)))
   {
      waveOOLPageSlot(pos, &page, &slot);
      return (dmaOVirt[page]->OOL[slot]);
   }

   return -1;
}



void rawWaveSetOOL(int pos, uint32_t value)
{
   int page, slot;

   if ((pos >= 0) && (pos < ((53 * 4) * 79)))
   {
      waveOOLPageSlot(pos, &page, &slot);
      dmaOVirt[page]->OOL[slot] = value;
   }
}




uint32_t rawWaveGetOut(int pos)
{
   int page, slot;

   if ((pos >= 0) && (pos < ((53 * 4) * 79)))
   {
      waveOOLPageSlot(pos, &page, &slot);
      return (dmaOVirt[page]->OOL[slot]);
   }

   return -1;
}



void rawWaveSetOut(int pos, uint32_t value)
{
   int page, slot;

   if ((pos >= 0) && (pos < ((53 * 4) * 79)))
   {
      waveOOLPageSlot(pos, &page, &slot);
      dmaOVirt[page]->OOL[slot] = value;
   }
}




uint32_t rawWaveGetIn(int pos)
{
   int page, slot;

   if ((pos >= 0) && (pos < ((53 * 4) * 79)))
   {
      waveOOLPageSlot((((53 * 4) * 79)-1)-pos, &page, &slot);
      return (dmaOVirt[page]->OOL[slot]);
   }

   return -1;
}



void rawWaveSetIn(int pos, uint32_t value)
{
   int page, slot;

   if ((pos >= 0) && (pos < ((53 * 4) * 79)))
   {
      waveOOLPageSlot((((53 * 4) * 79)-1)-pos, &page, &slot);
      dmaOVirt[page]->OOL[slot] = value;
   }
}



rawWaveInfo_t rawWaveInfo(int wave_id)
{
   rawWaveInfo_t dummy = {0, 0, 0, 0, 0, 0, 0, 0};

   if ((wave_id >=0) && (wave_id < 250)) return waveInfo[wave_id];
   else return dummy;
}



double time_time(void)
{
   struct timeval tv;
   double t;

   gettimeofday(&tv, 0);

   t = (double)tv.tv_sec + ((double)tv.tv_usec / 1E6);

   return t;
}



void time_sleep(double seconds)
{
   struct timespec ts, rem;

   if (seconds > 0.0)
   {
      ts.tv_sec = seconds;
      ts.tv_nsec = (seconds-(double)ts.tv_sec) * 1E9;

      while (clock_nanosleep(
# 8526 "pigpio.c" 3 4
                            0
# 8526 "pigpio.c"
                                          , 0, &ts, &rem))
      {

         ts.tv_sec = rem.tv_sec;
         ts.tv_nsec = rem.tv_nsec;
      }
   }
}



void rawDumpWave(void)
{
   int i;

   unsigned numWaves, t;

   rawWave_t *waves;

   numWaves = wfc[wfcur];
   waves = wf [wfcur];

   t = 0;

   for (i=0; i<numWaves; i++)
   {
      fprintf(
# 8552 "pigpio.c" 3 4
             stderr
# 8552 "pigpio.c"
                   , "%10u %08X %08X %08X %10u\n",
         t, waves[i].gpioOn, waves[i].gpioOff,
         waves[i].flags, waves[i].usDelay);
      t += waves[i].usDelay;
   }
}



void rawDumpScript(unsigned script_id)
{
   int i;

   if (script_id >= 32) return;

   if (gpioScript[script_id].state == 2)
   {

      for (i=0; i<10; i++)
      {
         fprintf(
# 8572 "pigpio.c" 3 4
                stderr
# 8572 "pigpio.c"
                      , "p%d=%d ", i, gpioScript[script_id].script.par[i]);
      }

      fprintf(
# 8575 "pigpio.c" 3 4
             stderr
# 8575 "pigpio.c"
                   , "\n");

      for (i=0; i<150; i++)
      {
         fprintf(
# 8579 "pigpio.c" 3 4
                stderr
# 8579 "pigpio.c"
                      , "v%d=%d ", i, gpioScript[script_id].script.var[i]);
      }

      fprintf(
# 8582 "pigpio.c" 3 4
             stderr
# 8582 "pigpio.c"
                   , "\n");

      for (i=0; i<gpioScript[script_id].script.instrs; i++)
      {
         fprintf(
# 8586 "pigpio.c" 3 4
                stderr
# 8586 "pigpio.c"
                      ,
            "c%d=[%"
# 8587 "pigpio.c" 3 4
                   "l" "d"
# 8587 "pigpio.c"
                          ", %"
# 8587 "pigpio.c" 3 4
                               "l" "d"
# 8587 "pigpio.c"
                                      "(%d), %"
# 8587 "pigpio.c" 3 4
                                               "l" "d"
# 8587 "pigpio.c"
                                                      "(%d), %"
# 8587 "pigpio.c" 3 4
                                                               "l" "d"
# 8587 "pigpio.c"
                                                                      ", %"
# 8587 "pigpio.c" 3 4
                                                                           "l" "d"
# 8587 "pigpio.c"
                                                                                  "]\n",
            i,
            gpioScript[script_id].script.instr[i].p[0],
            gpioScript[script_id].script.instr[i].p[1],
            gpioScript[script_id].script.instr[i].opt[1],
            gpioScript[script_id].script.instr[i].p[2],
            gpioScript[script_id].script.instr[i].opt[2],
            gpioScript[script_id].script.instr[i].p[3],
            gpioScript[script_id].script.instr[i].p[4]);
      }
   }
}



int gpioInitialise(void)
{
   int status;

   if (libInitialised) return 7401;

   { if ((gpioCfg.dbgLevel >= 1) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8608 "pigpio.c" 3 4
  stderr
# 8608 "pigpio.c"
  , "%s %s: " "not initialised, initialising" "\n" , myTimeStamp(), __FUNCTION__); };

   runState = 0;

   status = initInitialise();

   if (status < 0)
   {
      runState = 2;
      initReleaseResources();
   }
   else
   {
      libInitialised = 1;

      runState = 1;

      if (!(gpioCfg.ifFlags & 8))
      {
         while (pthAlertRunning != 2) myGpioDelay(1000);
      }

   }

   return status;
}




void gpioTerminate(void)
{
   int i;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8642 "pigpio.c" 3 4
  stderr
# 8642 "pigpio.c"
  , "%s %s: " "" "\n" , myTimeStamp(), __FUNCTION__); };

   if (!libInitialised) return;

   { if ((gpioCfg.dbgLevel >= 1) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8646 "pigpio.c" 3 4
  stderr
# 8646 "pigpio.c"
  , "%s %s: " "initialised, terminating" "\n" , myTimeStamp(), __FUNCTION__); };

   runState = 2;

   gpioMaskSet = 0;



   if (dmaReg != 
# 8654 "pigpio.c" 3 4
                ((void *) -1)
# 8654 "pigpio.c"
                          )
   {
      initKillDMA(dmaIn);
      initKillDMA(dmaOut);
   }


   if ((gpioCfg.internals & (1<<9)) &&
       (!(gpioCfg.internals & (1<<10))))
   {
      fprintf(
# 8664 "pigpio.c" 3 4
             stderr
# 8664 "pigpio.c"
                   ,
         "\n#####################################################\n");
      fprintf(
# 8666 "pigpio.c" 3 4
             stderr
# 8666 "pigpio.c"
                   , "pigpio version=%d internals=%X\n",
         7401, gpioCfg.internals);

      fprintf(
# 8669 "pigpio.c" 3 4
             stderr
# 8669 "pigpio.c"
                   ,
         "micros=%d allocMode=%d dmaInitCbs=%d DMARestarts=%d\n",
         gpioCfg.clockMicros, gpioCfg.memAllocMode,
         gpioStats.dmaInitCbsCount, gpioStats.DMARestarts);

      fprintf(
# 8674 "pigpio.c" 3 4
             stderr
# 8674 "pigpio.c"
                   ,
         "samples %u maxSamples %u maxEmit %u emitFrags %u\n",
         gpioStats.numSamples, gpioStats.maxSamples,
         gpioStats.maxEmit, gpioStats.emitFrags);

      fprintf(
# 8679 "pigpio.c" 3 4
             stderr
# 8679 "pigpio.c"
                   , "cbTicks %d, cbCalls %u\n",
         gpioStats.cbTicks, gpioStats.cbCalls);

      fprintf(
# 8682 "pigpio.c" 3 4
             stderr
# 8682 "pigpio.c"
                   , "pipe: good %u, short %u, would block %u\n",
         gpioStats.goodPipeWrite, gpioStats.shortPipeWrite,
         gpioStats.wouldBlockPipeWrite);

      fprintf(
# 8686 "pigpio.c" 3 4
             stderr
# 8686 "pigpio.c"
                   , "alertTicks %u, lateTicks %u, moreToDo %u\n",
         gpioStats.alertTicks, gpioStats.lateTicks, gpioStats.moreToDo);

      for (i=0; i< 50; i++)
         fprintf(
# 8690 "pigpio.c" 3 4
                stderr
# 8690 "pigpio.c"
                      , "%9u ", gpioStats.diffTick[i]);

      fprintf(
# 8692 "pigpio.c" 3 4
             stderr
# 8692 "pigpio.c"
                   ,
         "\n#####################################################\n\n\n");
   }


   initReleaseResources();

   fflush(
# 8699 "pigpio.c" 3 4
         ((void *)0)
# 8699 "pigpio.c"
             );

   libInitialised = 0;
}

static void switchFunctionOff(unsigned gpio)
{
   switch (gpioInfo[gpio].is)
   {
      case 3:

         myGpioSetServo(gpio, gpioInfo[gpio].width, 0);
         gpioInfo[gpio].width = 0;
         break;

      case 2:

         myGpioSetPwm(gpio, gpioInfo[gpio].width, 0);
         gpioInfo[gpio].width = 0;
         break;

      case 4:

         gpioInfo[gpio].width = 0;
         break;

      case 5:

         gpioInfo[gpio].width = 0;
         break;
   }
}

static void stopHardwarePWM(void)
{
   unsigned i, pwm;

   for (i=0; i<= 53; i++)
   {
      if (gpioInfo[i].is == 5)
      {
         pwm = (PWMDef[i] >> 4) & 3;

         if (pwm == 0) pwmReg[0] &= (~(1<<0));
         else pwmReg[0] &= (~(1<<8));

         gpioInfo[i].width = 0;
         gpioInfo[i].is = 0;
      }
   }
}



int gpioSetMode(unsigned gpio, unsigned mode)
{
   int reg, shift, old_mode;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8757 "pigpio.c" 3 4
  stderr
# 8757 "pigpio.c"
  , "%s %s: " "gpio=%d mode=%d" "\n" , myTimeStamp(), __FUNCTION__ , gpio, mode); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8759 "pigpio.c" 3 4
  stderr
# 8759 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (gpio > 53)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8762 "pigpio.c" 3 4
     stderr
# 8762 "pigpio.c"
     , "%s %s: " "bad gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio); }; return -3; } while (0);

   if (mode > 7)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8765 "pigpio.c" 3 4
     stderr
# 8765 "pigpio.c"
     , "%s %s: " "gpio %d, bad mode (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio, mode); }; return -4; } while (0);

   reg = gpio/10;
   shift = (gpio%10) * 3;

   old_mode = (gpioReg[reg] >> shift) & 7;

   if (mode != old_mode)
   {
      switchFunctionOff(gpio);

      gpioInfo[gpio].is = 0;
   }

   gpioReg[reg] = (gpioReg[reg] & ~(7<<shift)) | (mode<<shift);

   return 0;
}




int gpioGetMode(unsigned gpio)
{
   int reg, shift;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8791 "pigpio.c" 3 4
  stderr
# 8791 "pigpio.c"
  , "%s %s: " "gpio=%d" "\n" , myTimeStamp(), __FUNCTION__ , gpio); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8793 "pigpio.c" 3 4
  stderr
# 8793 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (gpio > 53)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8796 "pigpio.c" 3 4
     stderr
# 8796 "pigpio.c"
     , "%s %s: " "bad gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio); }; return -3; } while (0);

   reg = gpio/10;
   shift = (gpio%10) * 3;

   return (gpioReg[reg] >> shift) & 7;
}




int gpioSetPullUpDown(unsigned gpio, unsigned pud)
{
   int shift = (gpio & 0xf) << 1;
   uint32_t bits;
   uint32_t pull;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8813 "pigpio.c" 3 4
  stderr
# 8813 "pigpio.c"
  , "%s %s: " "gpio=%d pud=%d" "\n" , myTimeStamp(), __FUNCTION__ , gpio, pud); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8815 "pigpio.c" 3 4
  stderr
# 8815 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (gpio > 53)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8818 "pigpio.c" 3 4
     stderr
# 8818 "pigpio.c"
     , "%s %s: " "bad gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio); }; return -3; } while (0);

   if (pud > 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8821 "pigpio.c" 3 4
     stderr
# 8821 "pigpio.c"
     , "%s %s: " "gpio %d, bad pud (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio, pud); }; return -6; } while (0);

   if (pi_is_2711)
   {
      switch (pud)
      {
         case 0: pull = 0; break;
         case 2: pull = 1; break;
         case 1: pull = 2; break;
      }

      bits = *(gpioReg + 57 + (gpio>>4));
      bits &= ~(3 << shift);
      bits |= (pull << shift);
      *(gpioReg + 57 + (gpio>>4)) = bits;
   }
   else
   {
      *(gpioReg + 37) = pud;

      myGpioDelay(1);

      *(gpioReg + 38 + (gpio>>5)) = (1<<(gpio&0x1F));

      myGpioDelay(1);

      *(gpioReg + 37) = 0;

      *(gpioReg + 38 + (gpio>>5)) = 0;
   }

   return 0;
}




int gpioRead(unsigned gpio)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8860 "pigpio.c" 3 4
  stderr
# 8860 "pigpio.c"
  , "%s %s: " "gpio=%d" "\n" , myTimeStamp(), __FUNCTION__ , gpio); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8862 "pigpio.c" 3 4
  stderr
# 8862 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (gpio > 53)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8865 "pigpio.c" 3 4
     stderr
# 8865 "pigpio.c"
     , "%s %s: " "bad gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio); }; return -3; } while (0);

   if ((*(gpioReg + 13 + (gpio>>5)) & (1<<(gpio&0x1F))) != 0) return 1;
   else return 0;
}




int gpioWrite(unsigned gpio, unsigned level)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8876 "pigpio.c" 3 4
  stderr
# 8876 "pigpio.c"
  , "%s %s: " "gpio=%d level=%d" "\n" , myTimeStamp(), __FUNCTION__ , gpio, level); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8878 "pigpio.c" 3 4
  stderr
# 8878 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (gpio > 53)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8881 "pigpio.c" 3 4
     stderr
# 8881 "pigpio.c"
     , "%s %s: " "bad gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio); }; return -3; } while (0);

   if (level > 1)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8884 "pigpio.c" 3 4
     stderr
# 8884 "pigpio.c"
     , "%s %s: " "gpio %d, bad level (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio, level); }; return -5; } while (0);

   if (gpio <= 53)
   {
      if (gpioInfo[gpio].is != 1)
      {

         if (level == 0) *(gpioReg + 10 + (gpio>>5)) = (1<<(gpio&0x1F));
         else *(gpioReg + 7 + (gpio>>5)) = (1<<(gpio&0x1F));

         switchFunctionOff(gpio);

         gpioInfo[gpio].is = 1;
      }
   }

   myGpioSetMode(gpio, 1);

   if (level == 0) *(gpioReg + 10 + (gpio>>5)) = (1<<(gpio&0x1F));
   else *(gpioReg + 7 + (gpio>>5)) = (1<<(gpio&0x1F));

   return 0;
}




int gpioPWM(unsigned gpio, unsigned val)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8913 "pigpio.c" 3 4
  stderr
# 8913 "pigpio.c"
  , "%s %s: " "gpio=%d dutycycle=%d" "\n" , myTimeStamp(), __FUNCTION__ , gpio, val); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8915 "pigpio.c" 3 4
  stderr
# 8915 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (gpio > 31)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8918 "pigpio.c" 3 4
     stderr
# 8918 "pigpio.c"
     , "%s %s: " "bad gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio); }; return -2; } while (0);

   if (val > gpioInfo[gpio].range)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8921 "pigpio.c" 3 4
     stderr
# 8921 "pigpio.c"
     , "%s %s: " "gpio %d, bad dutycycle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio, val); }; return -8; } while (0);

   if (gpioInfo[gpio].is != 2)
   {
      switchFunctionOff(gpio);

      gpioInfo[gpio].is = 2;

      if (!val) myGpioWrite(gpio, 0);
   }

   myGpioSetMode(gpio, 1);

   myGpioSetPwm(gpio, gpioInfo[gpio].width, val);

   gpioInfo[gpio].width=val;

   return 0;
}



int gpioGetPWMdutycycle(unsigned gpio)
{
   unsigned pwm;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8947 "pigpio.c" 3 4
  stderr
# 8947 "pigpio.c"
  , "%s %s: " "gpio=%d" "\n" , myTimeStamp(), __FUNCTION__ , gpio); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8949 "pigpio.c" 3 4
  stderr
# 8949 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (gpio > 31)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8952 "pigpio.c" 3 4
     stderr
# 8952 "pigpio.c"
     , "%s %s: " "bad gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio); }; return -2; } while (0);

   switch (gpioInfo[gpio].is)
   {
      case 2:
         return gpioInfo[gpio].width;

      case 5:
         pwm = (PWMDef[gpio] >> 4) & 3;
         return hw_pwm_duty[pwm];

      case 4:
         return 1000000/2;

      default:
         do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8967 "pigpio.c" 3 4
        stderr
# 8967 "pigpio.c"
        , "%s %s: " "not a PWM gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio); }; return -92; } while (0);
   }
}




int gpioSetPWMrange(unsigned gpio, unsigned range)
{
   int oldWidth, newWidth;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8978 "pigpio.c" 3 4
  stderr
# 8978 "pigpio.c"
  , "%s %s: " "gpio=%d range=%d" "\n" , myTimeStamp(), __FUNCTION__ , gpio, range); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8980 "pigpio.c" 3 4
  stderr
# 8980 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (gpio > 31)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8983 "pigpio.c" 3 4
     stderr
# 8983 "pigpio.c"
     , "%s %s: " "bad gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio); }; return -2; } while (0);

   if ((range < 25) || (range > 40000))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 8986 "pigpio.c" 3 4
     stderr
# 8986 "pigpio.c"
     , "%s %s: " "gpio %d, bad range (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio, range); }; return -21; } while (0);

   oldWidth = gpioInfo[gpio].width;

   if (oldWidth)
   {
      if (gpioInfo[gpio].is == 2)
      {
         newWidth = (range * oldWidth) / gpioInfo[gpio].range;

         myGpioSetPwm(gpio, oldWidth, 0);
         gpioInfo[gpio].range = range;
         gpioInfo[gpio].width = newWidth;
         myGpioSetPwm(gpio, 0, newWidth);
      }
   }

   gpioInfo[gpio].range = range;



   return pwmRealRange[gpioInfo[gpio].freqIdx];
}




int gpioGetPWMrange(unsigned gpio)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9015 "pigpio.c" 3 4
  stderr
# 9015 "pigpio.c"
  , "%s %s: " "gpio=%d" "\n" , myTimeStamp(), __FUNCTION__ , gpio); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9017 "pigpio.c" 3 4
  stderr
# 9017 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (gpio > 31)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9020 "pigpio.c" 3 4
     stderr
# 9020 "pigpio.c"
     , "%s %s: " "bad gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio); }; return -2; } while (0);

   switch (gpioInfo[gpio].is)
   {
      case 5:
      case 4:
         return 1000000;

      default:
         return gpioInfo[gpio].range;
   }
}




int gpioGetPWMrealRange(unsigned gpio)
{
   unsigned pwm;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9040 "pigpio.c" 3 4
  stderr
# 9040 "pigpio.c"
  , "%s %s: " "gpio=%d" "\n" , myTimeStamp(), __FUNCTION__ , gpio); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9042 "pigpio.c" 3 4
  stderr
# 9042 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (gpio > 31)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9045 "pigpio.c" 3 4
     stderr
# 9045 "pigpio.c"
     , "%s %s: " "bad gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio); }; return -2; } while (0);

   switch (gpioInfo[gpio].is)
   {
      case 5:
         pwm = (PWMDef[gpio] >> 4) & 3;
         return hw_pwm_real_range[pwm];

      case 4:
         return 1000000;

      default:
         return pwmRealRange[gpioInfo[gpio].freqIdx];
   }
}




int gpioSetPWMfrequency(unsigned gpio, unsigned frequency)
{
   int i, width;
   unsigned diff, best, idx;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9069 "pigpio.c" 3 4
  stderr
# 9069 "pigpio.c"
  , "%s %s: " "gpio=%d frequency=%d" "\n" , myTimeStamp(), __FUNCTION__ , gpio, frequency); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9071 "pigpio.c" 3 4
  stderr
# 9071 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (gpio > 31)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9074 "pigpio.c" 3 4
     stderr
# 9074 "pigpio.c"
     , "%s %s: " "bad gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio); }; return -2; } while (0);

   if (frequency > pwmFreq[0]) idx = 0;
   else if (frequency < pwmFreq[18 -1]) idx = 18 -1;
   else
   {
      best = 100000;
      idx = 0;

      for (i=0; i<18; i++)
      {
         if (frequency > pwmFreq[i]) diff = frequency - pwmFreq[i];
         else diff = pwmFreq[i] - frequency;

         if (diff < best)
         {
            best = diff;
            idx = i;
         }
      }
   }

   width = gpioInfo[gpio].width;

   if (width)
   {
      if (gpioInfo[gpio].is == 2)
      {
         myGpioSetPwm(gpio, width, 0);
         gpioInfo[gpio].freqIdx = idx;
         myGpioSetPwm(gpio, 0, width);
      }
   }

   gpioInfo[gpio].freqIdx = idx;

   return pwmFreq[idx];
}




int gpioGetPWMfrequency(unsigned gpio)
{
   unsigned pwm, clock;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9120 "pigpio.c" 3 4
  stderr
# 9120 "pigpio.c"
  , "%s %s: " "gpio=%d" "\n" , myTimeStamp(), __FUNCTION__ , gpio); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9122 "pigpio.c" 3 4
  stderr
# 9122 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (gpio > 31)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9125 "pigpio.c" 3 4
     stderr
# 9125 "pigpio.c"
     , "%s %s: " "bad gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio); }; return -2; } while (0);

   switch (gpioInfo[gpio].is)
   {
      case 5:
         pwm = (PWMDef[gpio] >> 4) & 3;
         return hw_pwm_freq[pwm];

      case 4:
         clock = (clkDef[gpio] >> 4) & 3;
         return hw_clk_freq[clock];

      default:
         return pwmFreq[gpioInfo[gpio].freqIdx];
   }
}




int gpioServo(unsigned gpio, unsigned val)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9147 "pigpio.c" 3 4
  stderr
# 9147 "pigpio.c"
  , "%s %s: " "gpio=%d pulsewidth=%d" "\n" , myTimeStamp(), __FUNCTION__ , gpio, val); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9149 "pigpio.c" 3 4
  stderr
# 9149 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (gpio > 31)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9152 "pigpio.c" 3 4
     stderr
# 9152 "pigpio.c"
     , "%s %s: " "bad gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio); }; return -2; } while (0);

   if ((val!=0) && (val<500))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9155 "pigpio.c" 3 4
     stderr
# 9155 "pigpio.c"
     , "%s %s: " "gpio %d, bad pulsewidth (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio, val); }; return -7; } while (0)
                                                   ;

   if (val>2500)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9159 "pigpio.c" 3 4
     stderr
# 9159 "pigpio.c"
     , "%s %s: " "gpio %d, bad pulsewidth (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio, val); }; return -7; } while (0)
                                                   ;

   if (gpioInfo[gpio].is != 3)
   {
      switchFunctionOff(gpio);

      gpioInfo[gpio].is = 3;

      if (!val) myGpioWrite(gpio, 0);
   }

   myGpioSetMode(gpio, 1);

   myGpioSetServo(gpio, gpioInfo[gpio].width, val);

   gpioInfo[gpio].width=val;

   return 0;
}




int gpioGetServoPulsewidth(unsigned gpio)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9185 "pigpio.c" 3 4
  stderr
# 9185 "pigpio.c"
  , "%s %s: " "gpio=%d" "\n" , myTimeStamp(), __FUNCTION__ , gpio); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9187 "pigpio.c" 3 4
  stderr
# 9187 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (gpio > 31)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9190 "pigpio.c" 3 4
     stderr
# 9190 "pigpio.c"
     , "%s %s: " "bad gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio); }; return -2; } while (0);

   if (gpioInfo[gpio].is != 3)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9193 "pigpio.c" 3 4
     stderr
# 9193 "pigpio.c"
     , "%s %s: " "not a servo gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio); }; return -93; } while (0);

   return gpioInfo[gpio].width;
}




int gpioWaveClear(void)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9203 "pigpio.c" 3 4
  stderr
# 9203 "pigpio.c"
  , "%s %s: " "" "\n" , myTimeStamp(), __FUNCTION__); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9205 "pigpio.c" 3 4
  stderr
# 9205 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   wfc[0] = 0;
   wfc[1] = 0;
   wfc[2] = 0;

   wfcur = 0;

   wfStats.micros = 0;
   wfStats.pulses = 0;
   wfStats.cbs = 0;

   waveOutBotCB = 10*118;
   waveOutBotOOL = 10*79;
   waveOutTopOOL = ((53 * 4) * 79);

   waveOutCount = 0;

   waveEndPtr = 
# 9223 "pigpio.c" 3 4
               ((void *)0)
# 9223 "pigpio.c"
                   ;

   return 0;
}



int gpioWaveAddNew(void)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9232 "pigpio.c" 3 4
  stderr
# 9232 "pigpio.c"
  , "%s %s: " "" "\n" , myTimeStamp(), __FUNCTION__); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9234 "pigpio.c" 3 4
  stderr
# 9234 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   wfc[0] = 0;
   wfc[1] = 0;
   wfc[2] = 0;

   wfcur = 0;

   wfStats.micros = 0;
   wfStats.pulses = 0;
   wfStats.cbs = 0;

   return 0;
}



int gpioWaveAddGeneric(unsigned numPulses, gpioPulse_t *pulses)
{
   int p;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9255 "pigpio.c" 3 4
  stderr
# 9255 "pigpio.c"
  , "%s %s: " "numPulses=%u pulses=%08"
# 9255 "pigpio.c" 3 4
  "l" "X" 
# 9255 "pigpio.c"
  "\n" , myTimeStamp(), __FUNCTION__ , numPulses, (uintptr_t)pulses); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9257 "pigpio.c" 3 4
  stderr
# 9257 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (numPulses > (4 * 3000))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9260 "pigpio.c" 3 4
     stderr
# 9260 "pigpio.c"
     , "%s %s: " "bad number of pulses (%d)" "\n" , myTimeStamp(), __FUNCTION__ , numPulses); }; return -36; } while (0);

   if (!pulses) do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9262 "pigpio.c" 3 4
               stderr
# 9262 "pigpio.c"
               , "%s %s: " "bad (NULL) pulses pointer" "\n" , myTimeStamp(), __FUNCTION__); }; return -90; } while (0);

   for (p=0; p<numPulses; p++)
   {
      wf[2][p].gpioOff = pulses[p].gpioOff;
      wf[2][p].gpioOn = pulses[p].gpioOn;
      wf[2][p].usDelay = pulses[p].usDelay;
      wf[2][p].flags = 0;
   }

   return rawWaveAddGeneric(numPulses, wf[2]);
}



int gpioWaveAddSerial
   (unsigned gpio,
    unsigned baud,
    unsigned data_bits,
    unsigned stop_bits,
    unsigned offset,
    unsigned numBytes,
    char *bstr)
{
   int i, b, p, lev, c, v;

   uint16_t *wstr = (uint16_t *)bstr;
   uint32_t *lstr = (uint32_t *)bstr;

   unsigned bitDelay[32];

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9293 "pigpio.c" 3 4
  stderr
# 9293 "pigpio.c"
  , "%s %s: " "gpio=%d baud=%d bits=%d stops=%d offset=%d numBytes=%d str=[%s]" "\n" , myTimeStamp(), __FUNCTION__ , gpio, baud, data_bits, stop_bits, offset, numBytes, myBuf2Str(numBytes, (char *)bstr)); }


                                                  ;

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9298 "pigpio.c" 3 4
  stderr
# 9298 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (gpio > 31)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9301 "pigpio.c" 3 4
     stderr
# 9301 "pigpio.c"
     , "%s %s: " "bad gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio); }; return -2; } while (0);

   if ((baud < 50) || (baud > 1000000))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9304 "pigpio.c" 3 4
     stderr
# 9304 "pigpio.c"
     , "%s %s: " "bad baud rate (%d)" "\n" , myTimeStamp(), __FUNCTION__ , baud); }; return -35; } while (0);

   if ((data_bits < 1) ||
       (data_bits > 32))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9308 "pigpio.c" 3 4
     stderr
# 9308 "pigpio.c"
     , "%s %s: " "bad number of databits (%d)" "\n" , myTimeStamp(), __FUNCTION__ , data_bits); }; return -101; } while (0);

   if ((stop_bits < 2) ||
       (stop_bits > 8))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9312 "pigpio.c" 3 4
     stderr
# 9312 "pigpio.c"
     , "%s %s: " "bad number of (half) stop bits (%d)" "\n" , myTimeStamp(), __FUNCTION__ , stop_bits); }; return -102; } while (0)
                                                          ;

   if (gpio > 31)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9316 "pigpio.c" 3 4
     stderr
# 9316 "pigpio.c"
     , "%s %s: " "bad gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio); }; return -2; } while (0);

   if (numBytes > (4 * 300))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9319 "pigpio.c" 3 4
     stderr
# 9319 "pigpio.c"
     , "%s %s: " "too many chars (%d)" "\n" , myTimeStamp(), __FUNCTION__ , numBytes); }; return -37; } while (0);

   if (offset > (30 * 60 * 1000000))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9322 "pigpio.c" 3 4
     stderr
# 9322 "pigpio.c"
     , "%s %s: " "offset too large (%d)" "\n" , myTimeStamp(), __FUNCTION__ , offset); }; return -49; } while (0);

   if (data_bits > 8) numBytes /= 2;
   if (data_bits > 16) numBytes /= 2;

   if (!numBytes) return 0;

   waveBitDelay(baud, data_bits, stop_bits, bitDelay);

   p = 0;

   wf[2][p].gpioOn = (1<<gpio);
   wf[2][p].gpioOff = 0;
   wf[2][p].flags = 0;

   if (offset > bitDelay[0]) wf[2][p].usDelay = offset;
   else wf[2][p].usDelay = bitDelay[0];

   for (i=0; i<numBytes; i++)
   {
      p++;



      wf[2][p].gpioOn = 0;
      wf[2][p].gpioOff = (1<<gpio);
      wf[2][p].usDelay = bitDelay[0];
      wf[2][p].flags = 0;

      lev = 0;

      if (data_bits < 9) c = bstr[i];
      else if (data_bits < 17) c = wstr[i];
      else c = lstr[i];

      for (b=0; b<data_bits; b++)
      {
         if (c & (1<<b)) v=1; else v=0;

         if (v == lev) wf[2][p].usDelay += bitDelay[b+1];
         else
         {
            p++;

            lev = v;

            if (lev)
            {
               wf[2][p].gpioOn = (1<<gpio);
               wf[2][p].gpioOff = 0;
               wf[2][p].flags = 0;
            }
            else
            {
               wf[2][p].gpioOn = 0;
               wf[2][p].gpioOff = (1<<gpio);
               wf[2][p].flags = 0;
            }

            wf[2][p].usDelay = bitDelay[b+1];
         }
      }



      if (lev) wf[2][p].usDelay += bitDelay[data_bits+1];
      else
      {
         p++;

         wf[2][p].gpioOn = (1<<gpio);
         wf[2][p].gpioOff = 0;
         wf[2][p].usDelay = bitDelay[data_bits+1];
         wf[2][p].flags = 0;
      }
   }

   p++;

   wf[2][p].gpioOn = (1<<gpio);
   wf[2][p].gpioOff = 0;
   wf[2][p].usDelay = bitDelay[0];
   wf[2][p].flags = 0;

   return rawWaveAddGeneric(p, wf[2]);
}



int rawWaveAddSPI(
   rawSPI_t *spi,
   unsigned offset,
   unsigned spiSS,
   char *buf,
   unsigned spiTxBits,
   unsigned spiBitFirst,
   unsigned spiBitLast,
   unsigned spiBits)
{
   int p, bit, dbv, halfbit;
   int rising_edge[2], read_cycle[2];
   uint32_t on_bits, off_bits;
   int tx_bit_pos;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9426 "pigpio.c" 3 4
  stderr
# 9426 "pigpio.c"
  , "%s %s: " "spi=%08"
# 9426 "pigpio.c" 3 4
  "l" "X"
# 9426 "pigpio.c"
  " off=%d spiSS=%d tx=%08"
# 9426 "pigpio.c" 3 4
  "l" "X"
# 9426 "pigpio.c"
  ", num=%d fb=%d lb=%d spiBits=%d" "\n" , myTimeStamp(), __FUNCTION__ , (uintptr_t)spi, offset, spiSS, (uintptr_t)buf, spiTxBits, spiBitFirst, spiBitLast, spiBits); }


                                       ;

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9431 "pigpio.c" 3 4
  stderr
# 9431 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (spiSS > 31)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9434 "pigpio.c" 3 4
     stderr
# 9434 "pigpio.c"
     , "%s %s: " "bad gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , spiSS); }; return -2; } while (0);
# 9444 "pigpio.c"
   if (spi->clk_pol) {rising_edge[0] = 0; rising_edge[1] = 1;}
   else {rising_edge[0] = 1; rising_edge[1] = 0;}

   if (spi->clk_pha) {read_cycle[0] = 0; read_cycle[1] = 1;}
   else {read_cycle[0] = 1; read_cycle[1] = 0;}

   p = 0;

   if (offset)
   {
      wf[2][p].gpioOn = 0;
      wf[2][p].gpioOff = 0;
      wf[2][p].flags = 0;
      wf[2][p].usDelay = offset;
      p++;
   }

   on_bits = 0;
   off_bits = 0;

   tx_bit_pos = 0;



   if (getBitInBytes(tx_bit_pos, buf, spiTxBits))
   {
      on_bits |= (1<<(spi->mosi));
      dbv = 1;
   }
   else
   {
      off_bits |= (1<<(spi->mosi));
      dbv = 0;
   }

   if (!spi->clk_pha) tx_bit_pos ++;

   if (spi->ss_pol) off_bits |= (1<<spiSS);
   else on_bits |= (1<<spiSS);

   if (spi->clk_pol) on_bits |= (1<<(spi->clk));
   else off_bits |= (1<<(spi->clk));

   wf[2][p].gpioOn = on_bits;
   wf[2][p].gpioOff = off_bits;
   wf[2][p].flags = 0;

   if (spi->clk_us > spi->ss_us) wf[2][p].usDelay = spi->clk_us;
   else wf[2][p].usDelay = spi->ss_us;

   p++;

   for (bit=1; bit<=spiBits; bit++)
   {
      for (halfbit=0; halfbit<2; halfbit++)
      {
         wf[2][p].usDelay = spi->clk_us;
         wf[2][p].flags = 0;

         on_bits = 0;
         off_bits = 0;

         if (read_cycle[halfbit])
         {
            if ((bit>=spiBitFirst) && (bit<=spiBitLast))
               wf[2][p].flags = 1;
         }
         else
         {
            if (getBitInBytes(tx_bit_pos, buf, spiTxBits))
            {
               if (!dbv) on_bits |= (1<<(spi->mosi));
               dbv = 1;
            }
            else
            {
               if (dbv) off_bits |= (1<<(spi->mosi));
               dbv = 0;
            }

            ++tx_bit_pos;
         }

         if (rising_edge[halfbit]) on_bits |= (1<<(spi->clk));
         else off_bits |= (1<<(spi->clk));

         wf[2][p].gpioOn = on_bits;
         wf[2][p].gpioOff = off_bits;

         p++;
      }
   }

   on_bits = 0;
   off_bits = 0;

   if (spi->ss_pol) on_bits |= (1<<spiSS);
   else off_bits |= (1<<spiSS);

   wf[2][p].gpioOn = on_bits;
   wf[2][p].gpioOff = off_bits;
   wf[2][p].flags = 0;
   wf[2][p].usDelay = 0;

   p++;

   return rawWaveAddGeneric(p, wf[2]);
}



int gpioWaveCreate(void)
{
   int i, wid;
   int numCB, numBOOL, numTOOL;
   int CB, BOOL, TOOL;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9561 "pigpio.c" 3 4
  stderr
# 9561 "pigpio.c"
  , "%s %s: " "" "\n" , myTimeStamp(), __FUNCTION__); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9563 "pigpio.c" 3 4
  stderr
# 9563 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (wfc[wfcur] == 0) return -69;



   waveCBsOOLs(&numCB, &numBOOL, &numTOOL);

   wid = -1;



   for (i=0; i<waveOutCount; i++)
   {
      if (waveInfo[i].deleted &&
         (waveInfo[i].numCB == numCB) &&
         (waveInfo[i].numBOOL == numBOOL) &&
         (waveInfo[i].numTOOL == numTOOL))
      {

         wid = i;
         break;
      }
   }

   if (wid == -1)
   {


      if ((numCB+waveOutBotCB) >= ((53 * 4) * 118))
         return -67;

      if ((numBOOL+waveOutBotOOL) >= (waveOutTopOOL-numTOOL))
         return -68;

      if (wid >= 250)
         return -70;

      wid = waveOutCount++;

      waveInfo[wid].botCB = waveOutBotCB;
      waveInfo[wid].topCB = waveOutBotCB + numCB -1;
      waveInfo[wid].botOOL = waveOutBotOOL;
      waveInfo[wid].topOOL = waveOutTopOOL;
      waveInfo[wid].numCB = numCB;
      waveInfo[wid].numBOOL = numBOOL;
      waveInfo[wid].numTOOL = numTOOL;

      waveOutBotCB += numCB;
      waveOutBotOOL += numBOOL;
      waveOutTopOOL -= numTOOL;
   }



   CB = waveInfo[wid].botCB;
   BOOL = waveInfo[wid].botOOL;
   TOOL = waveInfo[wid].topOOL;

   wave2Cbs(0, &CB, &BOOL, &TOOL);



   if ( (numCB != (CB-waveInfo[wid].botCB)) ||
        (numBOOL != (BOOL-waveInfo[wid].botOOL)) ||
        (numTOOL != (waveInfo[wid].topOOL-TOOL)) )
   {
      { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9630 "pigpio.c" 3 4
     stderr
# 9630 "pigpio.c"
     , "%s %s: " "ERROR wid=%d CBs %d=%d BOOL %d=%d TOOL %d=%d" "\n" , myTimeStamp(), __FUNCTION__ , wid, numCB, CB-waveInfo[wid].botCB, numBOOL, BOOL-waveInfo[wid].botOOL, numTOOL, waveInfo[wid].topOOL-TOOL); }


                                            ;
   }

   waveInfo[wid].deleted = 0;



   wfc[0] = 0;
   wfc[1] = 0;
   wfc[2] = 0;

   wfcur = 0;

   return wid;
}



int gpioWaveDelete(unsigned wave_id)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9653 "pigpio.c" 3 4
  stderr
# 9653 "pigpio.c"
  , "%s %s: " "wave id=%d" "\n" , myTimeStamp(), __FUNCTION__ , wave_id); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9655 "pigpio.c" 3 4
  stderr
# 9655 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if ((wave_id >= waveOutCount) || waveInfo[wave_id].deleted)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9658 "pigpio.c" 3 4
     stderr
# 9658 "pigpio.c"
     , "%s %s: " "bad wave id (%d)" "\n" , myTimeStamp(), __FUNCTION__ , wave_id); }; return -66; } while (0);

   waveInfo[wave_id].deleted = 1;

   if (wave_id == (waveOutCount-1))
   {


      while ((wave_id > 0) && (waveInfo[wave_id-1].deleted)) --wave_id;

      waveOutBotCB = waveInfo[wave_id].botCB;
      waveOutBotOOL = waveInfo[wave_id].botOOL;
      waveOutTopOOL = waveInfo[wave_id].topOOL;

      waveOutCount = wave_id;
   }

   return 0;
}



int gpioWaveTxStart(unsigned wave_mode)
{


   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9684 "pigpio.c" 3 4
  stderr
# 9684 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9686 "pigpio.c" 3 4
  stderr
# 9686 "pigpio.c"
  , "%s %s: " "deprected function removed" "\n" , myTimeStamp(), __FUNCTION__); }; return -120; } while (0);
}



int gpioWaveTxSend(unsigned wave_id, unsigned wave_mode)
{
   rawCbs_t *p=
# 9693 "pigpio.c" 3 4
              ((void *)0)
# 9693 "pigpio.c"
                  ;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9695 "pigpio.c" 3 4
  stderr
# 9695 "pigpio.c"
  , "%s %s: " "wave_id=%d wave_mode=%d" "\n" , myTimeStamp(), __FUNCTION__ , wave_id, wave_mode); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9697 "pigpio.c" 3 4
  stderr
# 9697 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if ((wave_id >= waveOutCount) || waveInfo[wave_id].deleted)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9700 "pigpio.c" 3 4
     stderr
# 9700 "pigpio.c"
     , "%s %s: " "bad wave id (%d)" "\n" , myTimeStamp(), __FUNCTION__ , wave_id); }; return -66; } while (0);

   if (wave_mode > 3)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9703 "pigpio.c" 3 4
     stderr
# 9703 "pigpio.c"
     , "%s %s: " "bad wave mode (%d)" "\n" , myTimeStamp(), __FUNCTION__ , wave_mode); }; return -33; } while (0);

   if (!waveClockInited)
   {
      stopHardwarePWM();
      initClock(0);
      waveClockInited = 1;
      PWMClockInited = 0;
   }

   if (wave_mode < 2) initKillDMA(dmaOut);

   p = rawWaveCBAdr(waveInfo[wave_id].topCB);

   if ((wave_mode & 1) == 0)
      p->next = 0;
   else
      p->next = waveCbPOadr(waveInfo[wave_id].botCB+1);

   if (waveEndPtr && (wave_mode > 1))
   {
      *waveEndPtr = waveCbPOadr(waveInfo[wave_id].botCB+1);

      if (!dmaOut[1])
      {
         initDMAgo((uint32_t *)dmaOut, waveCbPOadr(waveInfo[wave_id].botCB));
      }
   }
   else
   {
      initDMAgo((uint32_t *)dmaOut, waveCbPOadr(waveInfo[wave_id].botCB));
   }

   waveEndPtr = &p->next;




   return (waveInfo[wave_id].topCB - waveInfo[wave_id].botCB) + 1;
}




static int chainGetCB(int n)
{
   int block, index;

   if (n < (60 * 10))
   {
      block = n / 60;
      index = n % 60;
      return (block*118) + (2 * 13) + index;
   }
   return -1;
}

static void chainSetVal(int n, uint32_t val)
{
   int block, index;
   uint32_t *p;

   if (n < (60 * 10))
   {
      block = n / 60;
      index = n % 60;
      p = (uint32_t *) dmaOVirt[block] + ((2 * 13)+60) * 8;
      p[index] = val;
   }
}

static uint32_t chainGetValPadr(int n)
{
   int block, index;
   uint32_t *p;

   if (n < (60 * 10))
   {
      block = n / 60;
      index = n % 60;
      p = (uint32_t *) dmaOBus[block] + ((2 * 13)+60) * 8;


      return (uint32_t)(uintptr_t) (p + index);
   }
   return 0;
}

static uint32_t chainGetCntVal(int counter, int slot)
{
   uint32_t *p;
   int page, offset;
   page = counter / 2;
   offset = (counter % 2 ? (2 * 68) : 0);
   p = (uint32_t *) dmaOVirt[page] + ((2 * 13)+60) * 8;
   return p[60 + offset + slot];
}

static void chainSetCntVal(int counter, int slot, uint32_t value)
{
   uint32_t *p;
   int page, offset;
   page = counter / 2;
   offset = (counter % 2 ? (2 * 68) : 0);
   p = (uint32_t *) dmaOVirt[page] + ((2 * 13)+60) * 8;
   p[60 + offset + slot] = value;
}

static uint32_t chainGetCntValPadr(int counter, int slot)
{
   uint32_t *p;
   int page, offset;
   page = counter / 2;
   offset = (counter % 2 ? (2 * 68) : 0);
   p = (uint32_t *) dmaOBus[page] + ((2 * 13)+60) * 8;


   return (uint32_t)(uintptr_t)(p + 60 + offset + slot);
}

static int chainGetCntCB(int counter)
{
   int page, offset;
   page = counter / 2;
   offset = (counter % 2 ? 13 : 0);
   return ((page * 118) + offset);
}

static void chainMakeCounter(
   unsigned counter,
   unsigned blklen,
   unsigned blocks,
   unsigned count,
   uint32_t repeat,
   uint32_t next)
{
   rawCbs_t *p=
# 9839 "pigpio.c" 3 4
              ((void *)0)
# 9839 "pigpio.c"
                  ;

   int b, baseCB, dig;
   uint32_t nxt;

   int botCB;

   botCB = chainGetCntCB(counter);

   baseCB = botCB;


   for (b=0; b < (blocks*(blklen+1)); b++) chainSetCntVal(counter, b, repeat);

   for (b=0; b<blocks; b++)
      chainSetCntVal(counter,
         ((b*(blklen+1))+blklen),
         waveCbPOadr(baseCB+((b*3)+3)));

   for (b=0; b<blocks; b++)
   {


      p = rawWaveCBAdr(botCB++);

      p->info = ((1<<26) | (1<< 3));

      p->src = chainGetCntValPadr(counter, b*(blklen+1));
      p->dst = (waveCbPOadr(botCB+1) + 20);

      p->length = 4;
      p->next = waveCbPOadr(botCB);



      p = rawWaveCBAdr(botCB++);

      p->info = ((1<<26) | (1<< 3));

      p->src = chainGetCntValPadr(counter, b*(blklen+1));
      p->dst = chainGetCntValPadr(counter, (b*(blklen+1))+blklen);

      p->length = 4;
      p->next = waveCbPOadr(botCB);



      p = rawWaveCBAdr(botCB++);

      p->info = ((1<<26) | (1<< 3))|(1<< 8)|(1<< 4);

      p->src = chainGetCntValPadr(counter, ((b*(blklen+1))+1));
      p->dst = chainGetCntValPadr(counter, ((b*(blklen+1))+0));

      p->length = blklen*4;
      p->next = repeat;
   }



   p = rawWaveCBAdr(botCB);

   p->info = ((1<<26) | (1<< 3))|(1<< 8)|(1<< 4);

   p->src = chainGetCntValPadr(counter, blocks*(blklen+1));
   p->dst = chainGetCntValPadr(counter, 0);

   p->length = blocks*(blklen+1)*4;
   p->next = next;

   b = 0;

   while (count && (b<blocks))
   {
      dig = count % blklen;
      count /= blklen;

      if (count) nxt = chainGetCntVal(counter, (b*(blklen+1))+blklen);
      else nxt = waveCbPOadr(botCB);

      chainSetCntVal(counter, b*(blklen+1)+dig, nxt);

      b++;
   }


   for (b=0; b < (blocks*(blklen+1)); b++)
      chainSetCntVal(
         counter, b+(blocks*(blklen+1)), chainGetCntVal(counter, b));
}


int gpioWaveChain(char *buf, unsigned bufSize)
{
   unsigned blklen=16, blocks=4;
   int cb, chaincb;
   rawCbs_t *p;
   int i, wid, cmd, loop, counters;
   unsigned cycles, delayCBs, dcb, delayLeft;
   uint32_t repeat, next, *endPtr;
   int stk_pos[10], stk_lev=0;

   cb = 0;
   loop = -1;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9944 "pigpio.c" 3 4
  stderr
# 9944 "pigpio.c"
  , "%s %s: " "bufSize=%d [%s]" "\n" , myTimeStamp(), __FUNCTION__ , bufSize, myBuf2Str(bufSize, buf)); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9946 "pigpio.c" 3 4
  stderr
# 9946 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (!waveClockInited)
   {
      stopHardwarePWM();
      initClock(0);
      waveClockInited = 1;
      PWMClockInited = 0;
   }

   initKillDMA(dmaOut);

   waveEndPtr = 
# 9958 "pigpio.c" 3 4
               ((void *)0)
# 9958 "pigpio.c"
                   ;
   endPtr = 
# 9959 "pigpio.c" 3 4
           ((void *)0)
# 9959 "pigpio.c"
               ;



   p = rawWaveCBAdr(chainGetCB(cb++));



   if (gpioCfg.clockPeriph != 1)
   {
      p->info = ((1<<26) | (1<< 3)) | ((1<< 6) | ((2)<<16));
      p->dst = ((((pi_peri_phys + 0x00203000) + 1*4) & 0x00ffffff) | 0x7E000000);
   }
   else
   {
      p->info = ((1<<26) | (1<< 3)) | ((1<< 6) | ((5)<<16));
      p->dst = ((((pi_peri_phys + 0x0020C000) + 6*4) & 0x00ffffff) | 0x7E000000);
   }



   p->src = (uint32_t)(uintptr_t) (&dmaOBus[0]->periphData);
   p->length = 4 * 20 / 1;
   p->next = waveCbPOadr(chainGetCB(cb));

   counters = 0;
   wid = -1;

   i = 0;

   while (i<bufSize)
   {
      wid = (unsigned)buf[i];

      if (wid == 255)
      {
         if ((i+2) > bufSize)
            do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 9996 "pigpio.c" 3 4
           stderr
# 9996 "pigpio.c"
           , "%s %s: " "incomplete chain command (at %d)" "\n" , myTimeStamp(), __FUNCTION__ , i); }; return -116; } while (0)
                                                     ;

         cmd = buf[i+1];

         if (cmd == 0)
         {
            if (stk_lev >= (sizeof(stk_pos)/sizeof(int)))
               do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10004 "pigpio.c" 3 4
              stderr
# 10004 "pigpio.c"
              , "%s %s: " "chain counters nested too deep (at %d)" "\n" , myTimeStamp(), __FUNCTION__ , i); }; return -118; } while (0)
                                                              ;

            stk_pos[stk_lev++] = cb;

            i += 2;
         }
         else if (cmd == 1)
         {
            if (counters >= (2 * 10))
               do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10014 "pigpio.c" 3 4
              stderr
# 10014 "pigpio.c"
              , "%s %s: " "too many chain counters (at %d)" "\n" , myTimeStamp(), __FUNCTION__ , i); }; return -115; } while (0)
                                                       ;

            if ((i+4) > bufSize)
               do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10018 "pigpio.c" 3 4
              stderr
# 10018 "pigpio.c"
              , "%s %s: " "incomplete chain command (at %d)" "\n" , myTimeStamp(), __FUNCTION__ , i); }; return -116; } while (0)
                                                        ;

            loop = 0;
            if (--stk_lev >= 0) loop = stk_pos[stk_lev];

            if ((loop < 1) || (loop == cb))
               do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10025 "pigpio.c" 3 4
              stderr
# 10025 "pigpio.c"
              , "%s %s: " "empty chain loop (at %d)" "\n" , myTimeStamp(), __FUNCTION__ , i); }; return -114; } while (0)
                                                ;

            cycles = ((unsigned)buf[i+3] << 8) + (unsigned)buf[i+2];

            i += 4;

            if (cycles > 65535)
               do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10033 "pigpio.c" 3 4
              stderr
# 10033 "pigpio.c"
              , "%s %s: " "bad chain loop count (%d)" "\n" , myTimeStamp(), __FUNCTION__ , cycles); }; return -113; } while (0)
                                                      ;

            if (cycles == 0)
            {




               p = rawWaveCBAdr(chainGetCB(loop));
               p->next = waveCbPOadr(chainGetCB(cb));
            }
            else if (cycles == 1)
            {

            }
            else
            {
               chaincb = chainGetCB(cb++);
               if (chaincb < 0)
                  do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10053 "pigpio.c" 3 4
                 stderr
# 10053 "pigpio.c"
                 , "%s %s: " "chain is too long (%d)" "\n" , myTimeStamp(), __FUNCTION__ , cb); }; return -119; } while (0);

               p = rawWaveCBAdr(chaincb);

               repeat = waveCbPOadr(chainGetCB(loop));



               chaincb = chainGetCB(cb);

               if (chaincb < 0)
                  do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10064 "pigpio.c" 3 4
                 stderr
# 10064 "pigpio.c"
                 , "%s %s: " "chain is too long (%d)" "\n" , myTimeStamp(), __FUNCTION__ , cb); }; return -119; } while (0);

               next = waveCbPOadr(chainGetCB(cb));


               p->info = ((1<<26) | (1<< 3));


               p->src = (uint32_t)(uintptr_t) (&dmaOBus[0]->periphData);
               p->dst = (uint32_t)(uintptr_t) (&dmaOBus[0]->periphData);
               p->length = 4;
               p->next = waveCbPOadr(chainGetCntCB(counters));

               chainMakeCounter(counters, blklen, blocks,
                            cycles-1, repeat, next);

               counters++;
            }
         }
         else if (cmd == 2)
         {
            if ((i+4) > bufSize)
               do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10086 "pigpio.c" 3 4
              stderr
# 10086 "pigpio.c"
              , "%s %s: " "incomplete chain command (at %d)" "\n" , myTimeStamp(), __FUNCTION__ , i); }; return -116; } while (0)
                                                        ;

            cycles = ((unsigned)buf[i+3] << 8) + (unsigned)buf[i+2];

            i += 4;

            if (cycles > 65535)
               do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10094 "pigpio.c" 3 4
              stderr
# 10094 "pigpio.c"
              , "%s %s: " "bad chain delay micros (%d)" "\n" , myTimeStamp(), __FUNCTION__ , cycles); }; return -117; } while (0)
                                                        ;

            if (cycles)
            {
               delayLeft = cycles;
               delayCBs = waveDelayCBs(delayLeft);
               for (dcb=0; dcb<delayCBs; dcb++)
               {
                  chaincb = chainGetCB(cb++);

                  if (chaincb < 0)
                     do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10106 "pigpio.c" 3 4
                    stderr
# 10106 "pigpio.c"
                    , "%s %s: " "chain is too long (%d)" "\n" , myTimeStamp(), __FUNCTION__ , cb); }; return -119; } while (0)
                                                                       ;

                  p = rawWaveCBAdr(chaincb);



                  if (gpioCfg.clockPeriph != 1)
                  {
                     p->info = ((1<<26) | (1<< 3)) | ((1<< 6) | ((2)<<16));
                     p->dst = ((((pi_peri_phys + 0x00203000) + 1*4) & 0x00ffffff) | 0x7E000000);
                  }
                  else
                  {
                     p->info = ((1<<26) | (1<< 3)) | ((1<< 6) | ((5)<<16));
                     p->dst = ((((pi_peri_phys + 0x0020C000) + 6*4) & 0x00ffffff) | 0x7E000000);
                  }



                  p->src = (uint32_t)(uintptr_t) (&dmaOBus[0]->periphData);

                  p->length = 4 * delayLeft / 1;

                  if ((gpioCfg.DMAsecondaryChannel >= 7) &&
                      (p->length > 0xfffc))
                  {
                     p->length = 0xfffc;
                  }

                  delayLeft -= (p->length / 4);

                  p->next = waveCbPOadr(chainGetCB(cb));
               }
            }
         }
         else if (cmd == 3)
         {
            i += 2;

            loop = 0;
            if (--stk_lev >= 0) loop = stk_pos[stk_lev];

            if ((loop < 1) || (loop == cb))
               do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10150 "pigpio.c" 3 4
              stderr
# 10150 "pigpio.c"
              , "%s %s: " "empty chain loop (at %d)" "\n" , myTimeStamp(), __FUNCTION__ , i); }; return -114; } while (0)
                                                ;

            chaincb = chainGetCB(cb++);
            if (chaincb < 0)
               do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10155 "pigpio.c" 3 4
              stderr
# 10155 "pigpio.c"
              , "%s %s: " "chain is too long (%d)" "\n" , myTimeStamp(), __FUNCTION__ , cb); }; return -119; } while (0);

            if (i < bufSize)
               do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10158 "pigpio.c" 3 4
              stderr
# 10158 "pigpio.c"
              , "%s %s: " "loop forever must be last command" "\n" , myTimeStamp(), __FUNCTION__); }; return -124; } while (0)
                                                      ;

            p = rawWaveCBAdr(chaincb);


            p->info = ((1<<26) | (1<< 3));


            p->src = (uint32_t)(uintptr_t) (&dmaOBus[0]->periphData);
            p->dst = (uint32_t)(uintptr_t) (&dmaOBus[0]->periphData);
            p->length = 4;
            p->next = waveCbPOadr(chainGetCB(loop));
            endPtr = &p->next;
         }
         else
            do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10174 "pigpio.c" 3 4
           stderr
# 10174 "pigpio.c"
           , "%s %s: " "unknown chain command (255 %d)" "\n" , myTimeStamp(), __FUNCTION__ , cmd); }; return -116; } while (0)
                                                     ;
      }
      else if ((wid >= waveOutCount) || waveInfo[wid].deleted)
         do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10178 "pigpio.c" 3 4
        stderr
# 10178 "pigpio.c"
        , "%s %s: " "undefined wave (%d)" "\n" , myTimeStamp(), __FUNCTION__ , wid); }; return -66; } while (0);
      else
      {
         chaincb = chainGetCB(cb++);

         if (chaincb < 0)
            do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10184 "pigpio.c" 3 4
           stderr
# 10184 "pigpio.c"
           , "%s %s: " "chain is too long (%d)" "\n" , myTimeStamp(), __FUNCTION__ , cb); }; return -119; } while (0);

         p = rawWaveCBAdr(chaincb);

         chaincb = chainGetCB(cb);

         if (chaincb < 0)
            do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10191 "pigpio.c" 3 4
           stderr
# 10191 "pigpio.c"
           , "%s %s: " "chain is too long (%d)" "\n" , myTimeStamp(), __FUNCTION__ , cb); }; return -119; } while (0);

         chainSetVal(cb-1, waveCbPOadr(chaincb));



         p->info = ((1<<26) | (1<< 3));
         p->src = chainGetValPadr(cb-1);
         p->dst = waveCbPOadr(waveInfo[wid].topCB) + 20;
         p->length = 4;
         p->next = waveCbPOadr(waveInfo[wid].botCB+1);

         i += 1;
      }
   }

   chaincb = chainGetCB(cb++);

   if (chaincb < 0)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10210 "pigpio.c" 3 4
     stderr
# 10210 "pigpio.c"
     , "%s %s: " "chain is too long (%d)" "\n" , myTimeStamp(), __FUNCTION__ , cb); }; return -119; } while (0);

   p = rawWaveCBAdr(chaincb);

   p->info = ((1<<26) | (1<< 3));



   p->src = (uint32_t)(uintptr_t) (&dmaOBus[0]->periphData);
   p->dst = (uint32_t)(uintptr_t) (&dmaOBus[0]->periphData);
   p->length = 4;
   p->next = 0;

   if (!endPtr) endPtr = &p->next;

   initDMAgo((uint32_t *)dmaOut, waveCbPOadr(chainGetCB(0)));

   waveEndPtr = endPtr;

   return 0;
}



int gpioWaveTxBusy(void)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10236 "pigpio.c" 3 4
  stderr
# 10236 "pigpio.c"
  , "%s %s: " "" "\n" , myTimeStamp(), __FUNCTION__); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10238 "pigpio.c" 3 4
  stderr
# 10238 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (dmaOut[1])
      return 1;
   else
      return 0;
}



int gpioWaveTxAt(void)
{
   int i, cb;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10252 "pigpio.c" 3 4
  stderr
# 10252 "pigpio.c"
  , "%s %s: " "" "\n" , myTimeStamp(), __FUNCTION__); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10254 "pigpio.c" 3 4
  stderr
# 10254 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   cb = dmaNowAtOCB();

   if (cb < 0) return -cb;

   for (i=0; i<250; i++)
   {
      if ( !waveInfo[i].deleted &&
          (cb >= waveInfo[i].botCB) &&
          (cb <= waveInfo[i].topCB) ) return i;
   }

   return 9998;
}



int gpioWaveTxStop(void)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10274 "pigpio.c" 3 4
  stderr
# 10274 "pigpio.c"
  , "%s %s: " "" "\n" , myTimeStamp(), __FUNCTION__); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10276 "pigpio.c" 3 4
  stderr
# 10276 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   initKillDMA(dmaOut);

   waveEndPtr = 
# 10280 "pigpio.c" 3 4
               ((void *)0)
# 10280 "pigpio.c"
                   ;

   return 0;
}



int gpioWaveGetMicros(void)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10289 "pigpio.c" 3 4
  stderr
# 10289 "pigpio.c"
  , "%s %s: " "" "\n" , myTimeStamp(), __FUNCTION__); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10291 "pigpio.c" 3 4
  stderr
# 10291 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   return wfStats.micros;
}



int gpioWaveGetHighMicros(void)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10300 "pigpio.c" 3 4
  stderr
# 10300 "pigpio.c"
  , "%s %s: " "" "\n" , myTimeStamp(), __FUNCTION__); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10302 "pigpio.c" 3 4
  stderr
# 10302 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   return wfStats.highMicros;
}



int gpioWaveGetMaxMicros(void)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10311 "pigpio.c" 3 4
  stderr
# 10311 "pigpio.c"
  , "%s %s: " "" "\n" , myTimeStamp(), __FUNCTION__); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10313 "pigpio.c" 3 4
  stderr
# 10313 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   return wfStats.maxMicros;
}



int gpioWaveGetPulses(void)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10322 "pigpio.c" 3 4
  stderr
# 10322 "pigpio.c"
  , "%s %s: " "" "\n" , myTimeStamp(), __FUNCTION__); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10324 "pigpio.c" 3 4
  stderr
# 10324 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   return wfStats.pulses;
}



int gpioWaveGetHighPulses(void)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10333 "pigpio.c" 3 4
  stderr
# 10333 "pigpio.c"
  , "%s %s: " "" "\n" , myTimeStamp(), __FUNCTION__); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10335 "pigpio.c" 3 4
  stderr
# 10335 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   return wfStats.highPulses;
}



int gpioWaveGetMaxPulses(void)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10344 "pigpio.c" 3 4
  stderr
# 10344 "pigpio.c"
  , "%s %s: " "" "\n" , myTimeStamp(), __FUNCTION__); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10346 "pigpio.c" 3 4
  stderr
# 10346 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   return wfStats.maxPulses;
}



int gpioWaveGetCbs(void)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10355 "pigpio.c" 3 4
  stderr
# 10355 "pigpio.c"
  , "%s %s: " "" "\n" , myTimeStamp(), __FUNCTION__); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10357 "pigpio.c" 3 4
  stderr
# 10357 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   return wfStats.cbs;
}



int gpioWaveGetHighCbs(void)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10366 "pigpio.c" 3 4
  stderr
# 10366 "pigpio.c"
  , "%s %s: " "" "\n" , myTimeStamp(), __FUNCTION__); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10368 "pigpio.c" 3 4
  stderr
# 10368 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   return wfStats.highCbs;
}



int gpioWaveGetMaxCbs(void)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10377 "pigpio.c" 3 4
  stderr
# 10377 "pigpio.c"
  , "%s %s: " "" "\n" , myTimeStamp(), __FUNCTION__); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10379 "pigpio.c" 3 4
  stderr
# 10379 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   return wfStats.maxCbs;
}



static int read_SDA(wfRx_t *w)
{
   myGpioSetMode(w->I.SDA, 0);
   return myGpioRead(w->I.SDA);
}

static void set_SDA(wfRx_t *w)
{
   myGpioSetMode(w->I.SDA, 0);
}

static void clear_SDA(wfRx_t *w)
{
   myGpioSetMode(w->I.SDA, 1);
   myGpioWrite(w->I.SDA, 0);
}

static void clear_SCL(wfRx_t *w)
{
   myGpioSetMode(w->I.SCL, 1);
   myGpioWrite(w->I.SCL, 0);
}

static void I2C_delay(wfRx_t *w)
{
   myGpioDelay(w->I.delay);
}

static void I2C_clock_stretch(wfRx_t *w)
{
   uint32_t now, max_stretch=100000;

   myGpioSetMode(w->I.SCL, 0);
   now = gpioTick();
   while ((myGpioRead(w->I.SCL) == 0) && ((gpioTick()-now) < max_stretch));
}

static void I2CStart(wfRx_t *w)
{
   if (w->I.started)
   {
      set_SDA(w);
      I2C_delay(w);
      I2C_clock_stretch(w);
      I2C_delay(w);
   }

   clear_SDA(w);
   I2C_delay(w);
   clear_SCL(w);
   I2C_delay(w);

   w->I.started = 1;
}

static void I2CStop(wfRx_t *w)
{
   clear_SDA(w);
   I2C_delay(w);
   I2C_clock_stretch(w);
   I2C_delay(w);
   set_SDA(w);
   I2C_delay(w);

   w->I.started = 0;
}

static void I2CPutBit(wfRx_t *w, int bit)
{
   if (bit) set_SDA(w);
   else clear_SDA(w);

   I2C_delay(w);
   I2C_clock_stretch(w);
   I2C_delay(w);
   clear_SCL(w);
}

static int I2CGetBit(wfRx_t *w)
{
   int bit;

   set_SDA(w);
   I2C_delay(w);
   I2C_clock_stretch(w);
   bit = read_SDA(w);
   I2C_delay(w);
   clear_SCL(w);

   return bit;
}

static int I2CPutByte(wfRx_t *w, int byte)
{
   int bit, nack;

   for(bit=0; bit<8; bit++)
   {
      I2CPutBit(w, byte & 0x80);
      byte <<= 1;
   }

   nack = I2CGetBit(w);

   return nack;
}

static uint8_t I2CGetByte(wfRx_t *w, int nack)
{
   int bit, byte=0;

   for (bit=0; bit<8; bit++)
   {
      byte = (byte << 1) | I2CGetBit(w);
   }

   I2CPutBit(w, nack);

   return byte;
}



int bbI2COpen(unsigned SDA, unsigned SCL, unsigned baud)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10511 "pigpio.c" 3 4
  stderr
# 10511 "pigpio.c"
  , "%s %s: " "SDA=%d SCL=%d baud=%d" "\n" , myTimeStamp(), __FUNCTION__ , SDA, SCL, baud); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10513 "pigpio.c" 3 4
  stderr
# 10513 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (SDA > 31)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10516 "pigpio.c" 3 4
     stderr
# 10516 "pigpio.c"
     , "%s %s: " "bad SDA (%d)" "\n" , myTimeStamp(), __FUNCTION__ , SDA); }; return -2; } while (0);

   if (SCL > 31)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10519 "pigpio.c" 3 4
     stderr
# 10519 "pigpio.c"
     , "%s %s: " "bad SCL (%d)" "\n" , myTimeStamp(), __FUNCTION__ , SCL); }; return -2; } while (0);

   if ((baud < 50) || (baud > 500000))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10522 "pigpio.c" 3 4
     stderr
# 10522 "pigpio.c"
     , "%s %s: " "SDA %d, bad baud rate (%d)" "\n" , myTimeStamp(), __FUNCTION__ , SDA, baud); }; return -112; } while (0)
                                                 ;

   if (wfRx[SDA].mode != 0)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10526 "pigpio.c" 3 4
     stderr
# 10526 "pigpio.c"
     , "%s %s: " "gpio %d is already being used" "\n" , myTimeStamp(), __FUNCTION__ , SDA); }; return -50; } while (0);

   if ((wfRx[SCL].mode != 0) || (SCL == SDA))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10529 "pigpio.c" 3 4
     stderr
# 10529 "pigpio.c"
     , "%s %s: " "gpio %d is already being used" "\n" , myTimeStamp(), __FUNCTION__ , SCL); }; return -50; } while (0);

   wfRx[SDA].gpio = SDA;
   wfRx[SDA].mode = 2;
   wfRx[SDA].baud = baud;

   wfRx[SDA].I.started = 0;
   wfRx[SDA].I.SDA = SDA;
   wfRx[SDA].I.SCL = SCL;
   wfRx[SDA].I.delay = 500000 / baud;
   wfRx[SDA].I.SDAMode = gpioGetMode(SDA);
   wfRx[SDA].I.SCLMode = gpioGetMode(SCL);

   wfRx[SCL].gpio = SCL;
   wfRx[SCL].mode = 3;

   myGpioSetMode(SDA, 0);
   myGpioSetMode(SCL, 0);

   return 0;
}



int bbI2CClose(unsigned SDA)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10555 "pigpio.c" 3 4
  stderr
# 10555 "pigpio.c"
  , "%s %s: " "SDA=%d" "\n" , myTimeStamp(), __FUNCTION__ , SDA); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10557 "pigpio.c" 3 4
  stderr
# 10557 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (SDA > 31)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10560 "pigpio.c" 3 4
     stderr
# 10560 "pigpio.c"
     , "%s %s: " "bad gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , SDA); }; return -2; } while (0);

   switch(wfRx[SDA].mode)
   {
      case 2:

         myGpioSetMode(wfRx[SDA].I.SDA, wfRx[SDA].I.SDAMode);
         myGpioSetMode(wfRx[SDA].I.SCL, wfRx[SDA].I.SCLMode);

         wfRx[wfRx[SDA].I.SDA].mode = 0;
         wfRx[wfRx[SDA].I.SCL].mode = 0;

         break;

      default:

         do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10576 "pigpio.c" 3 4
        stderr
# 10576 "pigpio.c"
        , "%s %s: " "no I2C on gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , SDA); }; return -108; } while (0);

         break;

   }

   return 0;
}



int bbI2CZip(
   unsigned SDA,
   char *inBuf,
   unsigned inLen,
   char *outBuf,
   unsigned outLen)
{
   int i, ack, inPos, outPos, status, bytes;
   int addr, flags, esc, setesc;
   wfRx_t *w;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10598 "pigpio.c" 3 4
  stderr
# 10598 "pigpio.c"
  , "%s %s: " "gpio=%d inBuf=%s outBuf=%08"
# 10598 "pigpio.c" 3 4
  "l" "X"
# 10598 "pigpio.c"
  " len=%d" "\n" , myTimeStamp(), __FUNCTION__ , SDA, myBuf2Str(inLen, (char *)inBuf), (uintptr_t)outBuf, outLen); }
                                                                      ;

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10601 "pigpio.c" 3 4
  stderr
# 10601 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (SDA > 31)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10604 "pigpio.c" 3 4
     stderr
# 10604 "pigpio.c"
     , "%s %s: " "bad gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , SDA); }; return -2; } while (0);

   if (wfRx[SDA].mode != 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10607 "pigpio.c" 3 4
     stderr
# 10607 "pigpio.c"
     , "%s %s: " "no I2C on gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , SDA); }; return -108; } while (0);

   if (!inBuf || !inLen)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10610 "pigpio.c" 3 4
     stderr
# 10610 "pigpio.c"
     , "%s %s: " "input buffer can't be NULL" "\n" , myTimeStamp(), __FUNCTION__); }; return -90; } while (0);

   if (!outBuf && outLen)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10613 "pigpio.c" 3 4
     stderr
# 10613 "pigpio.c"
     , "%s %s: " "output buffer can't be NULL" "\n" , myTimeStamp(), __FUNCTION__); }; return -90; } while (0);

   w = &wfRx[SDA];

   inPos = 0;
   outPos = 0;
   status = 0;

   addr = 0;
   flags = 0;
   esc = 0;
   setesc = 0;

   wfRx_lock(SDA);

   while (!status && (inPos < inLen))
   {
      { if ((gpioCfg.dbgLevel >= 5) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10630 "pigpio.c" 3 4
     stderr
# 10630 "pigpio.c"
     , "%s %s: " "status=%d inpos=%d inlen=%d cmd=%d addr=%d flags=%x" "\n" , myTimeStamp(), __FUNCTION__ , status, inPos, inLen, inBuf[inPos], addr, flags); }
                                                         ;

      switch (inBuf[inPos++])
      {
         case 0:
            status = 1;
            break;

         case 2:
            I2CStart(w);
            break;

         case 3:
            I2CStop(w);
            break;

         case 4:
            addr = myI2CGetPar(inBuf, &inPos, inLen, &esc);
            if (addr < 0) status = -111;
            break;

         case 5:

            esc = 1;
            flags = myI2CGetPar(inBuf, &inPos, inLen, &esc);
            if (flags < 0) status = -111;
            break;

         case 1:
            setesc = 1;
            break;

         case 6:

            bytes = myI2CGetPar(inBuf, &inPos, inLen, &esc);

            if (bytes >= 0) ack = I2CPutByte(w, (addr<<1)|1);

            if (bytes > 0)
            {
               if (!ack)
               {
                  if ((bytes + outPos) <= outLen)
                  {
                     for (i=0; i<(bytes-1); i++)
                     {
                        outBuf[outPos++] = I2CGetByte(w, 0);
                     }
                     outBuf[outPos++] = I2CGetByte(w, 1);
                  }
                  else status = -110;
               }
               else status = -83;
            }
            else status = -111;
            break;

         case 7:

            bytes = myI2CGetPar(inBuf, &inPos, inLen, &esc);

            if (bytes >= 0) ack = I2CPutByte(w, addr<<1);

            if (bytes > 0)
            {
               if (!ack)
               {
                  if ((bytes + inPos) <= inLen)
                  {
                     for (i=0; i<(bytes-1); i++)
                     {
                        ack = I2CPutByte(w, inBuf[inPos++]);
                        if (ack) status = -82;
                     }
                     ack = I2CPutByte(w, inBuf[inPos++]);
                  }
                  else status = -109;
               } else status = -82;
            }
            else status = -111;
            break;

         default:
            status = -111;
      }

      if (setesc) esc = 1; else esc = 0;

      setesc = 0;
   }

   wfRx_unlock(SDA);

   if (status >= 0) status = outPos;

   return status;
}



void bscInit(int mode)
{
   int sda, scl, miso, ce;

   bscsReg[3]=0;
   bscsReg[1]=0;
   bscsReg[2]=0;
   bscsReg[6]=0xf;
   bscsReg[9]=0x0f;

   if (pi_is_2711)
   {
      sda = 10;
      scl = 11;
      miso = 9;
      ce = 8;
   }
   else
   {
      sda = 18;
      scl = 19;
      miso = 20;
      ce = 21;
   }

   gpioSetMode(sda, 7);
   gpioSetMode(scl, 7);

   if (mode > 1)
   {
      gpioSetMode(miso, 7);
      gpioSetMode(ce, 7);
   }
}

void bscTerm(int mode)
{
   int sda, scl, miso, ce;

   bscsReg[3] = 0;
   bscsReg[1]=0;
   bscsReg[2]=0;

   if (pi_is_2711)
   {
      sda = 10;
      scl = 11;
      miso = 9;
      ce = 8;
   }
   else
   {
      sda = 18;
      scl = 19;
      miso = 20;
      ce = 21;
   }

   gpioSetMode(sda, 0);
   gpioSetMode(scl, 0);

   if (mode > 1)
   {
      gpioSetMode(miso, 0);
      gpioSetMode(ce, 0);
   }
}

int bscXfer(bsc_xfer_t *xfer)
{
   static int bscMode = 0;

   int copied=0;
   int active, mode;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10806 "pigpio.c" 3 4
  stderr
# 10806 "pigpio.c"
  , "%s %s: " "control=0x%X (sa=0x%X, cr=0x%X) tx=%d [%s]" "\n" , myTimeStamp(), __FUNCTION__ , xfer->control, ((xfer->control)>>16) & 127, (xfer->control) & 0x3fff, xfer->txCnt, myBuf2Str(xfer->txCnt, (char *)xfer->txBuf)); }




                                                  ;

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 10813 "pigpio.c" 3 4
  stderr
# 10813 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   eventAlert[31].ignore = 1;

   if (xfer->control)
   {




      if (xfer->control & 2) mode = 2;
      else mode = 1;

      if (mode > bscMode)
      {
         bscInit(mode);
         bscMode = mode;
      }
   }
   else
   {
      if (bscMode) bscTerm(bscMode);
      bscMode = 0;
      return 0;
   }

   xfer->rxCnt = 0;

   bscsReg[2] = ((xfer->control)>>16) & 127;
   bscsReg[3] = (xfer->control) & 0x3fff;
   bscsReg[1]=0;

   active = 1;

   while (active)
   {
      active = 0;

      while ((copied < xfer->txCnt) &&
             (!(bscsReg[4] & 4)))
      {
         bscsReg[0] = xfer->txBuf[copied++];
         active = 1;
      }

      while ((xfer->rxCnt < 512) &&
             (!(bscsReg[4] & 2)))
      {
         xfer->rxBuf[xfer->rxCnt++] = bscsReg[0];
         active = 1;
      }

      if (!active)
      {
         active = bscsReg[4] & (32 | 1);
      }

      if (active) myGpioSleep(0, 20);
   }

   bscFR = bscsReg[4] & 0xffff;

   eventAlert[31].ignore = 0;

   return (copied<<16) | bscFR;
}



static void set_CS(wfRx_t *w)
{
   myGpioWrite(w->S.CS, ((w->S.spiFlags)&4));
}

static void clear_CS(wfRx_t *w)
{
   myGpioWrite(w->S.CS, !((w->S.spiFlags)&4));
}

static void set_SCLK(wfRx_t *w)
{
   myGpioWrite(w->S.SCLK, !((w->S.spiFlags)&2));
}

static void clear_SCLK(wfRx_t *w)
{
   myGpioWrite(w->S.SCLK, ((w->S.spiFlags)&2));
}

static void SPI_delay(wfRx_t *w)
{
   myGpioDelay(w->S.delay);
}

static void bbSPIStart(wfRx_t *w)
{
   clear_SCLK(w);

   SPI_delay(w);

   set_CS(w);

   SPI_delay(w);
}

static void bbSPIStop(wfRx_t *w)
{
   SPI_delay(w);

   clear_CS(w);

   SPI_delay(w);

   clear_SCLK(w);
}

static uint8_t bbSPIXferByte(wfRx_t *w, char txByte)
{
   uint8_t bit, rxByte=0;

   if (((w->S.spiFlags)&1))
   {






      for (bit=0; bit<8; bit++)
      {
         set_SCLK(w);

         if ((((w->S.spiFlags)>>14)&1))
         {
            myGpioWrite(w->S.MOSI, txByte & 0x01);
            txByte >>= 1;
         }
         else
         {
            myGpioWrite(w->S.MOSI, txByte & 0x80);
            txByte <<= 1;
         }

         SPI_delay(w);

         clear_SCLK(w);

         if ((((w->S.spiFlags)>>15)&1))
         {
            rxByte = (rxByte >> 1) | myGpioRead(w->S.MISO) << 7;
         }
         else
         {
            rxByte = (rxByte << 1) | myGpioRead(w->S.MISO);
         }

         SPI_delay(w);
      }
   }
   else
   {






      for (bit=0; bit<8; bit++)
      {
         if ((((w->S.spiFlags)>>14)&1))
         {
            myGpioWrite(w->S.MOSI, txByte & 0x01);
            txByte >>= 1;
         }
         else
         {
            myGpioWrite(w->S.MOSI, txByte & 0x80);
            txByte <<= 1;
         }

         SPI_delay(w);

         set_SCLK(w);

         if ((((w->S.spiFlags)>>15)&1))
         {
            rxByte = (rxByte >> 1) | myGpioRead(w->S.MISO) << 7;
         }
         else
         {
            rxByte = (rxByte << 1) | myGpioRead(w->S.MISO);
         }

         SPI_delay(w);

         clear_SCLK(w);
      }
   }

   return rxByte;
}



int bbSPIOpen(
   unsigned CS, unsigned MISO, unsigned MOSI, unsigned SCLK,
   unsigned baud, unsigned spiFlags)
{
   int valid;
   uint32_t bits;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11024 "pigpio.c" 3 4
  stderr
# 11024 "pigpio.c"
  , "%s %s: " "CS=%d MISO=%d MOSI=%d SCLK=%d baud=%d flags=%d" "\n" , myTimeStamp(), __FUNCTION__ , CS, MISO, MOSI, SCLK, baud, spiFlags); }
                                           ;

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11027 "pigpio.c" 3 4
  stderr
# 11027 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (CS > 31)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11030 "pigpio.c" 3 4
     stderr
# 11030 "pigpio.c"
     , "%s %s: " "bad CS (%d)" "\n" , myTimeStamp(), __FUNCTION__ , CS); }; return -2; } while (0);

   if (MISO > 31)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11033 "pigpio.c" 3 4
     stderr
# 11033 "pigpio.c"
     , "%s %s: " "bad MISO (%d)" "\n" , myTimeStamp(), __FUNCTION__ , MISO); }; return -2; } while (0);

   if (MOSI > 31)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11036 "pigpio.c" 3 4
     stderr
# 11036 "pigpio.c"
     , "%s %s: " "bad MOSI (%d)" "\n" , myTimeStamp(), __FUNCTION__ , MOSI); }; return -2; } while (0);

   if (SCLK > 31)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11039 "pigpio.c" 3 4
     stderr
# 11039 "pigpio.c"
     , "%s %s: " "bad SCLK (%d)" "\n" , myTimeStamp(), __FUNCTION__ , SCLK); }; return -2; } while (0);

   if ((baud < 50) || (baud > 250000))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11042 "pigpio.c" 3 4
     stderr
# 11042 "pigpio.c"
     , "%s %s: " "CS %d, bad baud (%d)" "\n" , myTimeStamp(), __FUNCTION__ , CS, baud); }; return -141; } while (0);

   if (wfRx[CS].mode != 0)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11045 "pigpio.c" 3 4
     stderr
# 11045 "pigpio.c"
     , "%s %s: " "CS %d is already being used, mode %d" "\n" , myTimeStamp(), __FUNCTION__ , CS, wfRx[CS].mode); }; return -50; } while (0)
                                                                   ;

   valid = 0;



   bits = (1<<CS) | (1<<MISO) | (1<<MOSI) | (1<<SCLK);

   if (__builtin_popcount(bits) == 4)
   {
      if ((wfRx[MISO].mode == 0) &&
          (wfRx[MOSI].mode == 0) &&
          (wfRx[SCLK].mode == 0))
      {
         valid = 1;
      }
      else
      {
         if ((wfRx[MISO].mode == 5) &&
             (wfRx[MOSI].mode == 6) &&
             (wfRx[SCLK].mode == 4))
         {
            valid = 2;
         }
      }
   }

   if (!valid)
   {
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11075 "pigpio.c" 3 4
     stderr
# 11075 "pigpio.c"
     , "%s %s: " "GPIO already being used (%d=%d %d=%d, %d=%d %d=%d)" "\n" , myTimeStamp(), __FUNCTION__ , CS, wfRx[CS].mode, MISO, wfRx[MISO].mode, MOSI, wfRx[MOSI].mode, SCLK, wfRx[SCLK].mode); }; return -50; } while (0)




                                ;
   }

   wfRx[CS].mode = 7;
   wfRx[CS].baud = baud;

   wfRx[CS].S.CS = CS;
   wfRx[CS].S.SCLK = SCLK;

   wfRx[CS].S.CSMode = gpioGetMode(CS);
   wfRx[CS].S.delay = (500000 / baud) - 1;
   wfRx[CS].S.spiFlags = spiFlags;



   if (((spiFlags)&4))
      gpioWrite(CS, 0);
   else
      gpioWrite(CS, 1);



   if (valid == 1)
   {
      wfRx[SCLK].S.usage = 1;

      wfRx[SCLK].S.SCLKMode = gpioGetMode(SCLK);
      wfRx[SCLK].S.MISOMode = gpioGetMode(MISO);
      wfRx[SCLK].S.MOSIMode = gpioGetMode(MOSI);

      wfRx[SCLK].mode = 4;
      wfRx[MISO].mode = 5;
      wfRx[MOSI].mode = 6;

      wfRx[SCLK].S.SCLK = SCLK;
      wfRx[SCLK].S.MISO = MISO;
      wfRx[SCLK].S.MOSI = MOSI;

      myGpioSetMode(MISO, 0);
      myGpioSetMode(SCLK, 1);
      gpioWrite(MOSI, 0);
   }
   else
   {
      wfRx[SCLK].S.usage++;
   }

   return 0;
}



int bbSPIClose(unsigned CS)
{
   int SCLK;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11136 "pigpio.c" 3 4
  stderr
# 11136 "pigpio.c"
  , "%s %s: " "CS=%d" "\n" , myTimeStamp(), __FUNCTION__ , CS); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11138 "pigpio.c" 3 4
  stderr
# 11138 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (CS > 31)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11141 "pigpio.c" 3 4
     stderr
# 11141 "pigpio.c"
     , "%s %s: " "bad gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , CS); }; return -2; } while (0);

   switch(wfRx[CS].mode)
   {
      case 7:

         myGpioSetMode(wfRx[CS].S.CS, wfRx[CS].S.CSMode);
         wfRx[CS].mode = 0;

         SCLK = wfRx[CS].S.SCLK;

         if (--wfRx[SCLK].S.usage <= 0)
         {
            myGpioSetMode(wfRx[SCLK].S.MISO, wfRx[SCLK].S.MISOMode);
            myGpioSetMode(wfRx[SCLK].S.MOSI, wfRx[SCLK].S.MOSIMode);
            myGpioSetMode(wfRx[SCLK].S.SCLK, wfRx[SCLK].S.SCLKMode);

            wfRx[wfRx[SCLK].S.MISO].mode = 0;
            wfRx[wfRx[SCLK].S.MOSI].mode = 0;
            wfRx[wfRx[SCLK].S.SCLK].mode = 0;
         }

         break;

      default:

         do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11167 "pigpio.c" 3 4
        stderr
# 11167 "pigpio.c"
        , "%s %s: " "no SPI on gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , CS); }; return -142; } while (0);

         break;

   }

   return 0;
}



int bbSPIXfer(
   unsigned CS,
   char *inBuf,
   char *outBuf,
   unsigned count)
{
   int SCLK;
   int pos;
   wfRx_t *w;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11188 "pigpio.c" 3 4
  stderr
# 11188 "pigpio.c"
  , "%s %s: " "CS=%d inBuf=%s outBuf=%08"
# 11188 "pigpio.c" 3 4
  "l" "X"
# 11188 "pigpio.c"
  " count=%d" "\n" , myTimeStamp(), __FUNCTION__ , CS, myBuf2Str(count, (char *)inBuf), (uintptr_t)outBuf, count); }
                                                                    ;

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11191 "pigpio.c" 3 4
  stderr
# 11191 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (CS > 31)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11194 "pigpio.c" 3 4
     stderr
# 11194 "pigpio.c"
     , "%s %s: " "bad gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , CS); }; return -2; } while (0);

   if (wfRx[CS].mode != 7)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11197 "pigpio.c" 3 4
     stderr
# 11197 "pigpio.c"
     , "%s %s: " "no SPI on gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , CS); }; return -142; } while (0);

   if (!inBuf || !count)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11200 "pigpio.c" 3 4
     stderr
# 11200 "pigpio.c"
     , "%s %s: " "input buffer can't be NULL" "\n" , myTimeStamp(), __FUNCTION__); }; return -90; } while (0);

   if (!outBuf && count)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11203 "pigpio.c" 3 4
     stderr
# 11203 "pigpio.c"
     , "%s %s: " "output buffer can't be NULL" "\n" , myTimeStamp(), __FUNCTION__); }; return -90; } while (0);

   SCLK = wfRx[CS].S.SCLK;

   wfRx[SCLK].S.CS = CS;
   wfRx[SCLK].baud = wfRx[CS].baud;
   wfRx[SCLK].S.delay = wfRx[CS].S.delay;
   wfRx[SCLK].S.spiFlags = wfRx[CS].S.spiFlags;

   w = &wfRx[SCLK];

   wfRx_lock(SCLK);

   bbSPIStart(w);

   for (pos=0; pos < count; pos++)
   {
      outBuf[pos] = bbSPIXferByte(w, inBuf[pos]);
   }

   bbSPIStop(w);

   wfRx_unlock(SCLK);

   return count;
}



int gpioSerialReadOpen(unsigned gpio, unsigned baud, unsigned data_bits)
{
   int bitTime, timeout;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11236 "pigpio.c" 3 4
  stderr
# 11236 "pigpio.c"
  , "%s %s: " "gpio=%d baud=%d data_bits=%d" "\n" , myTimeStamp(), __FUNCTION__ , gpio, baud, data_bits); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11238 "pigpio.c" 3 4
  stderr
# 11238 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (gpio > 31)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11241 "pigpio.c" 3 4
     stderr
# 11241 "pigpio.c"
     , "%s %s: " "bad gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio); }; return -2; } while (0);

   if ((baud < 50) || (baud > 250000))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11244 "pigpio.c" 3 4
     stderr
# 11244 "pigpio.c"
     , "%s %s: " "gpio %d, bad baud rate (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio, baud); }; return -35; } while (0)
                                                   ;

   if ((data_bits < 1) ||
       (data_bits > 32))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11249 "pigpio.c" 3 4
     stderr
# 11249 "pigpio.c"
     , "%s %s: " "gpio %d, bad data bits (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio, data_bits); }; return -101; } while (0)
                                                        ;

   if (wfRx[gpio].mode != 0)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11253 "pigpio.c" 3 4
     stderr
# 11253 "pigpio.c"
     , "%s %s: " "gpio %d is already being used" "\n" , myTimeStamp(), __FUNCTION__ , gpio); }; return -50; } while (0);

   bitTime = (1000 * 1000000) / baud;

   timeout = ((data_bits+2) * bitTime)/1000000;

   if (timeout < 1) timeout = 1;

   wfRx[gpio].gpio = gpio;
   wfRx[gpio].mode = 1;
   wfRx[gpio].baud = baud;

   wfRx[gpio].s.buf = malloc(8192);
   wfRx[gpio].s.bufSize = 8192;
   wfRx[gpio].s.timeout = timeout;
   wfRx[gpio].s.fullBit = bitTime;
   wfRx[gpio].s.halfBit = (bitTime/2)+500;
   wfRx[gpio].s.readPos = 0;
   wfRx[gpio].s.writePos = 0;
   wfRx[gpio].s.bit = -1;
   wfRx[gpio].s.dataBits = data_bits;
   wfRx[gpio].s.invert = 0;

   if (data_bits < 9) wfRx[gpio].s.bytes = 1;
   else if (data_bits < 17) wfRx[gpio].s.bytes = 2;
   else wfRx[gpio].s.bytes = 4;

   gpioSetAlertFunc(gpio, waveRxBit);

   return 0;
}



int gpioSerialReadInvert(unsigned gpio, unsigned invert)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11289 "pigpio.c" 3 4
  stderr
# 11289 "pigpio.c"
  , "%s %s: " "gpio=%d invert=%d" "\n" , myTimeStamp(), __FUNCTION__ , gpio, invert); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11291 "pigpio.c" 3 4
  stderr
# 11291 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (gpio > 31)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11294 "pigpio.c" 3 4
     stderr
# 11294 "pigpio.c"
     , "%s %s: " "bad gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio); }; return -2; } while (0);

   if (wfRx[gpio].mode != 1)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11297 "pigpio.c" 3 4
     stderr
# 11297 "pigpio.c"
     , "%s %s: " "no serial read on gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio); }; return -38; } while (0);

   if ((invert < 0) ||
       (invert > 1))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11301 "pigpio.c" 3 4
     stderr
# 11301 "pigpio.c"
     , "%s %s: " "bad invert level for gpio %d (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio, invert); }; return -121; } while (0)
                                                           ;

   wfRx[gpio].s.invert = invert;

   return 0;
}



int gpioSerialRead(unsigned gpio, void *buf, size_t bufSize)
{
   unsigned bytes=0, wpos;
   volatile wfRx_t *w;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11316 "pigpio.c" 3 4
  stderr
# 11316 "pigpio.c"
  , "%s %s: " "gpio=%d buf=%08"
# 11316 "pigpio.c" 3 4
  "l" "X"
# 11316 "pigpio.c"
  " bufSize=%zd" "\n" , myTimeStamp(), __FUNCTION__ , gpio, (uintptr_t)buf, bufSize); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11318 "pigpio.c" 3 4
  stderr
# 11318 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (gpio > 31)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11321 "pigpio.c" 3 4
     stderr
# 11321 "pigpio.c"
     , "%s %s: " "bad gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio); }; return -2; } while (0);

   if (bufSize == 0)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11324 "pigpio.c" 3 4
     stderr
# 11324 "pigpio.c"
     , "%s %s: " "buffer size can't be zero" "\n" , myTimeStamp(), __FUNCTION__); }; return -51; } while (0);

   if (wfRx[gpio].mode != 1)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11327 "pigpio.c" 3 4
     stderr
# 11327 "pigpio.c"
     , "%s %s: " "no serial read on gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio); }; return -38; } while (0);

   w = &wfRx[gpio];

   if (w->s.readPos != w->s.writePos)
   {
      wpos = w->s.writePos;

      if (wpos > w->s.readPos) bytes = wpos - w->s.readPos;
      else bytes = w->s.bufSize - w->s.readPos;

      if (bytes > bufSize) bytes = bufSize;



      bytes = (bytes / w->s.bytes) * w->s.bytes;

      if (buf) memcpy(buf, w->s.buf+w->s.readPos, bytes);

      w->s.readPos += bytes;

      if (w->s.readPos >= w->s.bufSize) w->s.readPos = 0;
   }
   return bytes;
}




int gpioSerialReadClose(unsigned gpio)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11358 "pigpio.c" 3 4
  stderr
# 11358 "pigpio.c"
  , "%s %s: " "gpio=%d" "\n" , myTimeStamp(), __FUNCTION__ , gpio); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11360 "pigpio.c" 3 4
  stderr
# 11360 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (gpio > 31)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11363 "pigpio.c" 3 4
     stderr
# 11363 "pigpio.c"
     , "%s %s: " "bad gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio); }; return -2; } while (0);

   switch(wfRx[gpio].mode)
   {
      case 0:

         do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11369 "pigpio.c" 3 4
        stderr
# 11369 "pigpio.c"
        , "%s %s: " "no serial read on gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio); }; return -38; } while (0);

         break;

      case 1:

         free(wfRx[gpio].s.buf);

         gpioSetWatchdog(gpio, 0);

         gpioSetAlertFunc(gpio, 
# 11379 "pigpio.c" 3 4
                               ((void *)0)
# 11379 "pigpio.c"
                                   );

         wfRx[gpio].mode = 0;

         break;
   }

   return 0;
}




static int intEventSetFunc(
   unsigned event,
   void * f,
   int user,
   void * userdata)
{
   { if ((gpioCfg.dbgLevel >= 5) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11398 "pigpio.c" 3 4
  stderr
# 11398 "pigpio.c"
  , "%s %s: " "event=%d function=%08"
# 11398 "pigpio.c" 3 4
  "l" "X"
# 11398 "pigpio.c"
  ", user=%d, userdata=%08"
# 11398 "pigpio.c" 3 4
  "l" "X" 
# 11398 "pigpio.c"
  "\n" , myTimeStamp(), __FUNCTION__ , event, (uintptr_t)f, user, (uintptr_t)userdata); }
                                                     ;

   eventAlert[event].ex = user;
   eventAlert[event].userdata = userdata;

   eventAlert[event].func = f;

   return 0;
}




int eventSetFunc(unsigned event, eventFunc_t f)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11414 "pigpio.c" 3 4
  stderr
# 11414 "pigpio.c"
  , "%s %s: " "event=%d function=%08"
# 11414 "pigpio.c" 3 4
  "l" "X" 
# 11414 "pigpio.c"
  "\n" , myTimeStamp(), __FUNCTION__ , event, (uintptr_t)f); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11416 "pigpio.c" 3 4
  stderr
# 11416 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (event > 31)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11419 "pigpio.c" 3 4
     stderr
# 11419 "pigpio.c"
     , "%s %s: " "bad event (%d)" "\n" , myTimeStamp(), __FUNCTION__ , event); }; return -143; } while (0);

   intEventSetFunc(event, f, 0, 
# 11421 "pigpio.c" 3 4
                               ((void *)0)
# 11421 "pigpio.c"
                                   );

   return 0;
}




int eventSetFuncEx(unsigned event, eventFuncEx_t f, void *userdata)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11431 "pigpio.c" 3 4
  stderr
# 11431 "pigpio.c"
  , "%s %s: " "event=%d function=%08"
# 11431 "pigpio.c" 3 4
  "l" "x"
# 11431 "pigpio.c"
  " userdata=%08"
# 11431 "pigpio.c" 3 4
  "l" "x" 
# 11431 "pigpio.c"
  "\n" , myTimeStamp(), __FUNCTION__ , event, (uintptr_t)f, (uintptr_t)userdata); }
                                               ;

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11434 "pigpio.c" 3 4
  stderr
# 11434 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (event > 31)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11437 "pigpio.c" 3 4
     stderr
# 11437 "pigpio.c"
     , "%s %s: " "bad event (%d)" "\n" , myTimeStamp(), __FUNCTION__ , event); }; return -143; } while (0);

   intEventSetFunc(event, f, 1, userdata);

   return 0;
}




int eventMonitor(unsigned handle, uint32_t bits)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11449 "pigpio.c" 3 4
  stderr
# 11449 "pigpio.c"
  , "%s %s: " "handle=%d bits=%08X" "\n" , myTimeStamp(), __FUNCTION__ , handle, bits); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11451 "pigpio.c" 3 4
  stderr
# 11451 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (handle >= 32)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11454 "pigpio.c" 3 4
     stderr
# 11454 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (gpioNotify[handle].state <= 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11457 "pigpio.c" 3 4
     stderr
# 11457 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   gpioNotify[handle].eventBits = bits;

   return 0;
}




int eventTrigger(unsigned event)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11469 "pigpio.c" 3 4
  stderr
# 11469 "pigpio.c"
  , "%s %s: " "event=%d" "\n" , myTimeStamp(), __FUNCTION__ , event); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11471 "pigpio.c" 3 4
  stderr
# 11471 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (event > 31)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11474 "pigpio.c" 3 4
     stderr
# 11474 "pigpio.c"
     , "%s %s: " "bad event (%d)" "\n" , myTimeStamp(), __FUNCTION__ , event); }; return -143; } while (0);

   eventAlert[event].fired = 1;

   return 0;
}




static int intGpioSetAlertFunc(
   unsigned gpio,
   void * f,
   int user,
   void * userdata)
{
   { if ((gpioCfg.dbgLevel >= 5) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11490 "pigpio.c" 3 4
  stderr
# 11490 "pigpio.c"
  , "%s %s: " "gpio=%d function=%08"
# 11490 "pigpio.c" 3 4
  "l" "X"
# 11490 "pigpio.c"
  ", user=%d, userdata=%08"
# 11490 "pigpio.c" 3 4
  "l" "X" 
# 11490 "pigpio.c"
  "\n" , myTimeStamp(), __FUNCTION__ , gpio, (uintptr_t)f, user, (uintptr_t)userdata); }
                                                    ;

   gpioAlert[gpio].ex = user;
   gpioAlert[gpio].userdata = userdata;

   gpioAlert[gpio].func = f;

   if (f)
   {
      alertBits |= (1<<(gpio&0x1F));
   }
   else
   {
      alertBits &= ~(1<<(gpio&0x1F));
   }

   monitorBits = alertBits | notifyBits | scriptBits | gpioGetSamples.bits;

   return 0;
}



int gpioSetAlertFunc(unsigned gpio, gpioAlertFunc_t f)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11516 "pigpio.c" 3 4
  stderr
# 11516 "pigpio.c"
  , "%s %s: " "gpio=%d function=%08"
# 11516 "pigpio.c" 3 4
  "l" "X" 
# 11516 "pigpio.c"
  "\n" , myTimeStamp(), __FUNCTION__ , gpio, (uintptr_t)f); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11518 "pigpio.c" 3 4
  stderr
# 11518 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (gpio > 31)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11521 "pigpio.c" 3 4
     stderr
# 11521 "pigpio.c"
     , "%s %s: " "bad gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio); }; return -2; } while (0);

   intGpioSetAlertFunc(gpio, f, 0, 
# 11523 "pigpio.c" 3 4
                                  ((void *)0)
# 11523 "pigpio.c"
                                      );

   return 0;
}




int gpioSetAlertFuncEx(unsigned gpio, gpioAlertFuncEx_t f, void *userdata)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11533 "pigpio.c" 3 4
  stderr
# 11533 "pigpio.c"
  , "%s %s: " "gpio=%d function=%08"
# 11533 "pigpio.c" 3 4
  "l" "X"
# 11533 "pigpio.c"
  " userdata=%08"
# 11533 "pigpio.c" 3 4
  "l" "X" 
# 11533 "pigpio.c"
  "\n" , myTimeStamp(), __FUNCTION__ , gpio, (uintptr_t)f, (uintptr_t)userdata); }
                                              ;

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11536 "pigpio.c" 3 4
  stderr
# 11536 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (gpio > 31)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11539 "pigpio.c" 3 4
     stderr
# 11539 "pigpio.c"
     , "%s %s: " "bad gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio); }; return -2; } while (0);

   intGpioSetAlertFunc(gpio, f, 1, userdata);

   return 0;
}

static void *pthISRThread(void *x)
{
   gpioISR_t *isr = x;
   int fd;
   int retval;
   uint32_t tick;
   int level;
   uint32_t levels;
   struct pollfd pfd;
   char buf[64];

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11557 "pigpio.c" 3 4
  stderr
# 11557 "pigpio.c"
  , "%s %s: " "gpio=%d edge=%d timeout=%d f=%"
# 11557 "pigpio.c" 3 4
  "l" "x"
# 11557 "pigpio.c"
  " u=%d data=%"
# 11557 "pigpio.c" 3 4
  "l" "x" 
# 11557 "pigpio.c"
  "\n" , myTimeStamp(), __FUNCTION__ , isr->gpio, isr->edge, isr->timeout, (uintptr_t)isr->func, isr->ex, (uintptr_t)isr->userdata); }

                                        ;

   sprintf(buf, "/sys/class/gpio/gpio%d/value", isr->gpio);

   isr->fd = -1;

   if ((fd = open(buf, 
# 11565 "pigpio.c" 3 4
                      00
# 11565 "pigpio.c"
                              )) < 0)
   {
      { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11567 "pigpio.c" 3 4
     stderr
# 11567 "pigpio.c"
     , "%s %s: " "gpio %d not exported" "\n" , myTimeStamp(), __FUNCTION__ , isr->gpio); };
      return 
# 11568 "pigpio.c" 3 4
            ((void *)0)
# 11568 "pigpio.c"
                ;
   }

   isr->fd = fd;

   pfd.fd = fd;

   pfd.events = 
# 11575 "pigpio.c" 3 4
               0x002
# 11575 "pigpio.c"
                      ;

   lseek(fd, 0, 
# 11577 "pigpio.c" 3 4
               0
# 11577 "pigpio.c"
                       );
   if (read(fd, buf, sizeof buf) == -1) { }

   while (1)
   {
      retval = poll(&pfd, 1, isr->timeout);

      tick = systReg[1];

      levels = *(gpioReg + 13);

      if (retval >= 0)
      {
         lseek(fd, 0, 
# 11590 "pigpio.c" 3 4
                     0
# 11590 "pigpio.c"
                             );
         if (read(fd, buf, sizeof buf) == -1) { }

         if (retval)
         {
            if (levels & (1<<isr->gpio)) level = 1; else level = 0;
         }
         else level = 2;

         if (isr->ex) (isr->func)(isr->gpio, level, tick, isr->userdata);
         else (isr->func)(isr->gpio, level, tick);
      }
   }

   return 
# 11604 "pigpio.c" 3 4
         ((void *)0)
# 11604 "pigpio.c"
             ;
}




static int intGpioSetISRFunc(
   unsigned gpio,
   unsigned edge,
   int timeout,
   void *f,
   int user,
   void *userdata)
{
   char buf[64];

   char *edge_str[]={"rising\n", "falling\n", "both\n"};
   int fd;
   int err;

   { if ((gpioCfg.dbgLevel >= 5) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11624 "pigpio.c" 3 4
  stderr
# 11624 "pigpio.c"
  , "%s %s: " "gpio=%d edge=%d timeout=%d function=%08"
# 11624 "pigpio.c" 3 4
  "l" "X"
# 11624 "pigpio.c"
  " user=%d userdata=%08"
# 11624 "pigpio.c" 3 4
  "l" "X" 
# 11624 "pigpio.c"
  "\n" , myTimeStamp(), __FUNCTION__ , gpio, edge, timeout, (uintptr_t)f, user, (uintptr_t)userdata); }

                                                                   ;

   if (f)
   {
      if (!gpioISR[gpio].inited)
      {
         fd = open("/sys/class/gpio/export", 
# 11632 "pigpio.c" 3 4
                                            01
# 11632 "pigpio.c"
                                                    );
         if (fd < 0) return -123;


         sprintf(buf, "%d\n", gpio);
         err = write(fd, buf, strlen(buf));
         close(fd);

         sprintf(buf, "/sys/class/gpio/gpio%d/direction", gpio);
         fd = open(buf, 
# 11641 "pigpio.c" 3 4
                       01
# 11641 "pigpio.c"
                               );
         if (fd < 0) return -123;

         err = write(fd, "in\n", 3);
         close(fd);
         if (err != 3) return -123;

         gpioISR[gpio].gpio = gpio;
         gpioISR[gpio].edge = -1;
         gpioISR[gpio].timeout = -1;

         gpioISR[gpio].inited = 1;
      }

      if (gpioISR[gpio].edge != edge)
      {
         sprintf(buf, "/sys/class/gpio/gpio%d/edge", gpio);
         fd = open(buf, 
# 11658 "pigpio.c" 3 4
                       01
# 11658 "pigpio.c"
                               );
         if (fd < 0) return -123;

         err = write(fd, edge_str[edge], strlen(edge_str[edge]));
         close(fd);
         if (err != strlen(edge_str[edge])) return -123;

         gpioISR[gpio].edge = edge;

         if (gpioISR[gpio].pth != 
# 11667 "pigpio.c" 3 4
                                 ((void *)0)
# 11667 "pigpio.c"
                                     )
            pthread_kill(*gpioISR[gpio].pth, 
# 11668 "pigpio.c" 3 4
                                            17
# 11668 "pigpio.c"
                                                   );
      }

      if (timeout <= 0) timeout = -1;
      if (gpioISR[gpio].timeout != timeout)
      {
         gpioISR[gpio].timeout = timeout;

         if (gpioISR[gpio].pth != 
# 11676 "pigpio.c" 3 4
                                 ((void *)0)
# 11676 "pigpio.c"
                                     )
            pthread_kill(*gpioISR[gpio].pth, 
# 11677 "pigpio.c" 3 4
                                            17
# 11677 "pigpio.c"
                                                   );
      }

      gpioISR[gpio].func = f;
      gpioISR[gpio].ex = user;
      gpioISR[gpio].userdata = userdata;

      if (gpioISR[gpio].pth == 
# 11684 "pigpio.c" 3 4
                              ((void *)0)
# 11684 "pigpio.c"
                                  )
         gpioISR[gpio].pth = gpioStartThread(pthISRThread, &gpioISR[gpio]);
   }
   else
   {
      if (gpioISR[gpio].pth)
      {
         gpioStopThread(gpioISR[gpio].pth);

         if (gpioISR[gpio].fd >= 0)
         {
            close(gpioISR[gpio].fd);
            gpioISR[gpio].fd = -1;
         }

         gpioISR[gpio].func = 
# 11699 "pigpio.c" 3 4
                             ((void *)0)
# 11699 "pigpio.c"
                                 ;
         gpioISR[gpio].pth = 
# 11700 "pigpio.c" 3 4
                            ((void *)0)
# 11700 "pigpio.c"
                                ;
      }

      if (gpioISR[gpio].inited)
      {
         fd = open("/sys/class/gpio/unexport", 
# 11705 "pigpio.c" 3 4
                                              01
# 11705 "pigpio.c"
                                                      );
         if (fd < 0) return -123;
         sprintf(buf, "%d\n", gpio);
         err = write(fd, buf, strlen(buf));
         close(fd);
         if (err != strlen(buf)) return -123;
         gpioISR[gpio].inited = 0;
      }
   }

   return 0;
}



int gpioSetISRFunc(
   unsigned gpio,
   unsigned edge,
   int timeout,
   gpioISRFunc_t f)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11726 "pigpio.c" 3 4
  stderr
# 11726 "pigpio.c"
  , "%s %s: " "gpio=%d edge=%d timeout=%d function=%08"
# 11726 "pigpio.c" 3 4
  "l" "X" 
# 11726 "pigpio.c"
  "\n" , myTimeStamp(), __FUNCTION__ , gpio, edge, timeout, (uintptr_t)f); }
                                        ;

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11729 "pigpio.c" 3 4
  stderr
# 11729 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (gpio > 53)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11732 "pigpio.c" 3 4
     stderr
# 11732 "pigpio.c"
     , "%s %s: " "bad gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio); }; return -3; } while (0);

   if (edge > 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11735 "pigpio.c" 3 4
     stderr
# 11735 "pigpio.c"
     , "%s %s: " "bad ISR edge (%d)" "\n" , myTimeStamp(), __FUNCTION__ , edge); }; return -122; } while (0);

   return intGpioSetISRFunc(gpio, edge, timeout, f, 0, 
# 11737 "pigpio.c" 3 4
                                                      ((void *)0)
# 11737 "pigpio.c"
                                                          );
}




int gpioSetISRFuncEx(
   unsigned gpio,
   unsigned edge,
   int timeout,
   gpioAlertFuncEx_t f,
   void *userdata)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11750 "pigpio.c" 3 4
  stderr
# 11750 "pigpio.c"
  , "%s %s: " "gpio=%d edge=%d timeout=%d function=%08"
# 11750 "pigpio.c" 3 4
  "l" "X"
# 11750 "pigpio.c"
  " userdata=%08"
# 11750 "pigpio.c" 3 4
  "l" "X" 
# 11750 "pigpio.c"
  "\n" , myTimeStamp(), __FUNCTION__ , gpio, edge, timeout, (uintptr_t)f, (uintptr_t)userdata); }
                                                             ;

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11753 "pigpio.c" 3 4
  stderr
# 11753 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (gpio > 53)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11756 "pigpio.c" 3 4
     stderr
# 11756 "pigpio.c"
     , "%s %s: " "bad gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio); }; return -3; } while (0);

   if (edge > 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11759 "pigpio.c" 3 4
     stderr
# 11759 "pigpio.c"
     , "%s %s: " "bad ISR edge (%d)" "\n" , myTimeStamp(), __FUNCTION__ , edge); }; return -122; } while (0);

   return intGpioSetISRFunc(gpio, edge, timeout, f, 1, userdata);
}

static void closeOrphanedNotifications(int slot, int fd)
{
   int i;



   for (i=0; i<32; i++)
   {
      if ((i != slot) &&
          (gpioNotify[i].state >= 3) &&
          (gpioNotify[i].fd == fd))
      {
         { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11776 "pigpio.c" 3 4
        stderr
# 11776 "pigpio.c"
        , "%s %s: " "closed orphaned fd=%d (handle=%d)" "\n" , myTimeStamp(), __FUNCTION__ , fd, i); };
         gpioNotify[i].state = 0;
         intNotifyBits();
      }
   }
}



static void notifyMutex(int lock)
{
   static pthread_mutex_t mutex = 
# 11787 "pigpio.c" 3 4
                                 { { 0, 0, 0, 0, PTHREAD_MUTEX_TIMED_NP, 0, { 0, 0 } } }
# 11787 "pigpio.c"
                                                          ;
   if (lock) pthread_mutex_lock(&mutex);
   else pthread_mutex_unlock(&mutex);
}



int gpioNotifyOpenWithSize(int bufSize)
{
   int i, slot, fd;
   char name[32];

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11799 "pigpio.c" 3 4
  stderr
# 11799 "pigpio.c"
  , "%s %s: " "bufSize=%d" "\n" , myTimeStamp(), __FUNCTION__ , bufSize); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11801 "pigpio.c" 3 4
  stderr
# 11801 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   slot = -1;

   notifyMutex(1);

   for (i=0; i<32; i++)
   {
      if (gpioNotify[i].state == 0)
      {
         slot = i;
         gpioNotify[slot].state = 1;
         break;
      }
   }

   notifyMutex(0);

   if (slot < 0) do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11819 "pigpio.c" 3 4
                stderr
# 11819 "pigpio.c"
                , "%s %s: " "no handle" "\n" , myTimeStamp(), __FUNCTION__); }; return -24; } while (0);

   sprintf(name, "/dev/pigpio%d", slot);

   myCreatePipe(name, 0664);

   fd = open(name, 
# 11825 "pigpio.c" 3 4
                  02
# 11825 "pigpio.c"
                        |
# 11825 "pigpio.c" 3 4
                         04000
# 11825 "pigpio.c"
                                   );

   if (fd < 0)
   {
      gpioNotify[slot].state = 0;
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11830 "pigpio.c" 3 4
     stderr
# 11830 "pigpio.c"
     , "%s %s: " "open %s failed (%m)" "\n" , myTimeStamp(), __FUNCTION__ , name); }; return -23; } while (0);
   }

   if (bufSize != 0)
   {
      i = fcntl(fd, 
# 11835 "pigpio.c" 3 4
                   1031
# 11835 "pigpio.c"
                               , bufSize);
      if (i != bufSize)
      {
         gpioNotify[slot].state = 0;
         do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11839 "pigpio.c" 3 4
        stderr
# 11839 "pigpio.c"
        , "%s %s: " "fcntl %s size %d failed (%m)" "\n" , myTimeStamp(), __FUNCTION__ , name, bufSize); }; return -23; } while (0)
                                                          ;
      }
   }

   gpioNotify[slot].seqno = 0;
   gpioNotify[slot].bits = 0;
   gpioNotify[slot].fd = fd;
   gpioNotify[slot].pipe = 1;
   gpioNotify[slot].max_emits = (
# 11848 "pigpio.c" 3 4
                                4096 
# 11848 "pigpio.c"
                                / sizeof(gpioReport_t));
   gpioNotify[slot].lastReportTick = gpioTick();
   gpioNotify[i].state = 3;

   closeOrphanedNotifications(slot, fd);

   return slot;
}

int gpioNotifyOpen(void)
{
   return gpioNotifyOpenWithSize(0);
}



static int gpioNotifyOpenInBand(int fd)
{
   int i, slot;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11868 "pigpio.c" 3 4
  stderr
# 11868 "pigpio.c"
  , "%s %s: " "fd=%d" "\n" , myTimeStamp(), __FUNCTION__ , fd); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11870 "pigpio.c" 3 4
  stderr
# 11870 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   slot = -1;

   notifyMutex(1);

   for (i=0; i<32; i++)
   {
      if (gpioNotify[i].state == 0)
      {
         slot = i;
         gpioNotify[slot].state = 1;
         break;
      }
   }

   notifyMutex(0);

   if (slot < 0) do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11888 "pigpio.c" 3 4
                stderr
# 11888 "pigpio.c"
                , "%s %s: " "no handle" "\n" , myTimeStamp(), __FUNCTION__); }; return -24; } while (0);

   gpioNotify[slot].seqno = 0;
   gpioNotify[slot].bits = 0;
   gpioNotify[slot].fd = fd;
   gpioNotify[slot].pipe = 0;
   gpioNotify[slot].max_emits = (
# 11894 "pigpio.c" 3 4
                                4096 
# 11894 "pigpio.c"
                                / sizeof(gpioReport_t));
   gpioNotify[slot].lastReportTick = gpioTick();
   gpioNotify[slot].state = 3;

   closeOrphanedNotifications(slot, fd);

   return slot;
}




static void intScriptBits(void)
{
   int i;
   uint32_t bits;

   bits = 0;

   for (i=0; i<32; i++)
   {
      if (gpioScript[i].state == 2)
      {
         bits |= gpioScript[i].waitBits;
      }
   }

   scriptBits = bits;

   monitorBits = alertBits | notifyBits | scriptBits | gpioGetSamples.bits;
}


static void intScriptEventBits(void)
{
   int i;
   uint32_t bits;

   bits = 0;

   for (i=0; i<32; i++)
   {
      if (gpioScript[i].state == 2)
      {
         bits |= gpioScript[i].eventBits;
      }
   }

   scriptEventBits = bits;
}


static void intNotifyBits(void)
{
   int i;
   uint32_t bits;

   bits = 0;

   for (i=0; i<32; i++)
   {
      if (gpioNotify[i].state == 4)
      {
         bits |= gpioNotify[i].bits;
      }
   }

   notifyBits = bits;

   monitorBits = alertBits | notifyBits | scriptBits | gpioGetSamples.bits;
}




int gpioNotifyBegin(unsigned handle, uint32_t bits)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11971 "pigpio.c" 3 4
  stderr
# 11971 "pigpio.c"
  , "%s %s: " "handle=%d bits=%08X" "\n" , myTimeStamp(), __FUNCTION__ , handle, bits); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11973 "pigpio.c" 3 4
  stderr
# 11973 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (handle >= 32)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11976 "pigpio.c" 3 4
     stderr
# 11976 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (gpioNotify[handle].state <= 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11979 "pigpio.c" 3 4
     stderr
# 11979 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   gpioNotify[handle].bits = bits;

   gpioNotify[handle].state = 4;

   intNotifyBits();

   return 0;
}




int gpioNotifyPause (unsigned handle)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11995 "pigpio.c" 3 4
  stderr
# 11995 "pigpio.c"
  , "%s %s: " "handle=%d" "\n" , myTimeStamp(), __FUNCTION__ , handle); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 11997 "pigpio.c" 3 4
  stderr
# 11997 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (handle >= 32)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12000 "pigpio.c" 3 4
     stderr
# 12000 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (gpioNotify[handle].state <= 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12003 "pigpio.c" 3 4
     stderr
# 12003 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   gpioNotify[handle].bits = 0;

   gpioNotify[handle].state = 5;

   intNotifyBits();

   return 0;
}




int gpioNotifyClose(unsigned handle)
{
   char fifo[32];

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12021 "pigpio.c" 3 4
  stderr
# 12021 "pigpio.c"
  , "%s %s: " "handle=%d" "\n" , myTimeStamp(), __FUNCTION__ , handle); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12023 "pigpio.c" 3 4
  stderr
# 12023 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (handle >= 32)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12026 "pigpio.c" 3 4
     stderr
# 12026 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (gpioNotify[handle].state <= 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12029 "pigpio.c" 3 4
     stderr
# 12029 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   gpioNotify[handle].bits = 0;

   gpioNotify[handle].state = 2;

   intNotifyBits();

   if (gpioCfg.ifFlags & 8)
   {
      if (gpioNotify[handle].pipe)
      {
         { if ((gpioCfg.dbgLevel >= 5) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12041 "pigpio.c" 3 4
        stderr
# 12041 "pigpio.c"
        , "%s %s: " "close notify pipe %d" "\n" , myTimeStamp(), __FUNCTION__ , gpioNotify[handle].fd); };
         close(gpioNotify[handle].fd);

         sprintf(fifo, "/dev/pigpio%d", handle);

         unlink(fifo);
      }

      gpioNotify[handle].state = 0;
   }
   else
   {

   }

   return 0;
}



int gpioTrigger(unsigned gpio, unsigned pulseLen, unsigned level)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12063 "pigpio.c" 3 4
  stderr
# 12063 "pigpio.c"
  , "%s %s: " "gpio=%d pulseLen=%d level=%d" "\n" , myTimeStamp(), __FUNCTION__ , gpio, pulseLen, level); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12065 "pigpio.c" 3 4
  stderr
# 12065 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (gpio > 31)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12068 "pigpio.c" 3 4
     stderr
# 12068 "pigpio.c"
     , "%s %s: " "bad gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio); }; return -2; } while (0);

   if (level > 1)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12071 "pigpio.c" 3 4
     stderr
# 12071 "pigpio.c"
     , "%s %s: " "gpio %d, bad level (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio, level); }; return -5; } while (0);

   if ((pulseLen > 100) || (!pulseLen))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12074 "pigpio.c" 3 4
     stderr
# 12074 "pigpio.c"
     , "%s %s: " "gpio %d, bad pulseLen (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio, pulseLen); }; return -46; } while (0)
                                                      ;

   if (level == 0) *(gpioReg + 10 + (gpio>>5)) = (1<<(gpio&0x1F));
   else *(gpioReg + 7 + (gpio>>5)) = (1<<(gpio&0x1F));

   myGpioDelay(pulseLen);

   if (level != 0) *(gpioReg + 10 + (gpio>>5)) = (1<<(gpio&0x1F));
   else *(gpioReg + 7 + (gpio>>5)) = (1<<(gpio&0x1F));

   return 0;
}




int gpioSetWatchdog(unsigned gpio, unsigned timeout)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12093 "pigpio.c" 3 4
  stderr
# 12093 "pigpio.c"
  , "%s %s: " "gpio=%d timeout=%d" "\n" , myTimeStamp(), __FUNCTION__ , gpio, timeout); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12095 "pigpio.c" 3 4
  stderr
# 12095 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (gpio > 31)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12098 "pigpio.c" 3 4
     stderr
# 12098 "pigpio.c"
     , "%s %s: " "bad gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio); }; return -2; } while (0);

   if (timeout > 60000)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12101 "pigpio.c" 3 4
     stderr
# 12101 "pigpio.c"
     , "%s %s: " "gpio %d, bad timeout (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio, timeout); }; return -15; } while (0)
                                                    ;

   gpioAlert[gpio].wdTick = systReg[1];
   gpioAlert[gpio].wdSteadyUs = timeout*1000;

   if (timeout) wdogBits |= (1<<gpio);
   else wdogBits &= (~(1<<gpio));

   return 0;
}



int gpioNoiseFilter(unsigned gpio, unsigned steady, unsigned active)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12117 "pigpio.c" 3 4
  stderr
# 12117 "pigpio.c"
  , "%s %s: " "gpio=%d steady=%d active=%d" "\n" , myTimeStamp(), __FUNCTION__ , gpio, steady, active); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12119 "pigpio.c" 3 4
  stderr
# 12119 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (gpio > 31)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12122 "pigpio.c" 3 4
     stderr
# 12122 "pigpio.c"
     , "%s %s: " "bad gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio); }; return -2; } while (0);

   if (steady > 300000)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12125 "pigpio.c" 3 4
     stderr
# 12125 "pigpio.c"
     , "%s %s: " "bad steady (%d)" "\n" , myTimeStamp(), __FUNCTION__ , steady); }; return -125; } while (0);

   if (active > 1000000)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12128 "pigpio.c" 3 4
     stderr
# 12128 "pigpio.c"
     , "%s %s: " "bad active (%d)" "\n" , myTimeStamp(), __FUNCTION__ , active); }; return -125; } while (0);

   gpioAlert[gpio].nfTick1 = systReg[1];
   gpioAlert[gpio].nfTick2 = gpioAlert[gpio].nfTick1;
   gpioAlert[gpio].nfSteadyUs = steady;
   gpioAlert[gpio].nfActiveUs = active;
   gpioAlert[gpio].nfActive = 0;

   if (steady) nFilterBits |= (1<<gpio);
   else nFilterBits &= (~(1<<gpio));

   return 0;
}




int gpioGlitchFilter(unsigned gpio, unsigned steady)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12147 "pigpio.c" 3 4
  stderr
# 12147 "pigpio.c"
  , "%s %s: " "gpio=%d steady=%d" "\n" , myTimeStamp(), __FUNCTION__ , gpio, steady); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12149 "pigpio.c" 3 4
  stderr
# 12149 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (gpio > 31)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12152 "pigpio.c" 3 4
     stderr
# 12152 "pigpio.c"
     , "%s %s: " "bad gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio); }; return -2; } while (0);

   if (steady > 300000)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12155 "pigpio.c" 3 4
     stderr
# 12155 "pigpio.c"
     , "%s %s: " "bad steady (%d)" "\n" , myTimeStamp(), __FUNCTION__ , steady); }; return -125; } while (0);

   if (steady)
   {
      gpioAlert[gpio].gfTick = systReg[1];

      if (gpioRead_Bits_0_31() & (1<<gpio))
      {
         gpioAlert[gpio].gfLBitV = (1<<gpio);
         gpioAlert[gpio].gfRBitV = 0 ;
      }
      else
      {
         gpioAlert[gpio].gfLBitV = 0 ;
         gpioAlert[gpio].gfRBitV = (1<<gpio);
      }
   }

   gpioAlert[gpio].gfSteadyUs = steady;

   if (steady) gFilterBits |= (1<<gpio);
   else gFilterBits &= (~(1<<gpio));

   return 0;
}



int gpioSetGetSamplesFunc(gpioGetSamplesFunc_t f, uint32_t bits)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12185 "pigpio.c" 3 4
  stderr
# 12185 "pigpio.c"
  , "%s %s: " "function=%08"
# 12185 "pigpio.c" 3 4
  "l" "X"
# 12185 "pigpio.c"
  " bits=%08X" "\n" , myTimeStamp(), __FUNCTION__ , (uintptr_t)f, bits); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12187 "pigpio.c" 3 4
  stderr
# 12187 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   gpioGetSamples.ex = 0;
   gpioGetSamples.userdata = 
# 12190 "pigpio.c" 3 4
                            ((void *)0)
# 12190 "pigpio.c"
                                ;
   gpioGetSamples.func = f;

   if (f) gpioGetSamples.bits = bits;
   else gpioGetSamples.bits = 0;

   monitorBits = alertBits | notifyBits | scriptBits | gpioGetSamples.bits;

   return 0;
}




int gpioSetGetSamplesFuncEx(gpioGetSamplesFuncEx_t f,
                            uint32_t bits,
                            void * userdata)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12208 "pigpio.c" 3 4
  stderr
# 12208 "pigpio.c"
  , "%s %s: " "function=%08"
# 12208 "pigpio.c" 3 4
  "l" "X"
# 12208 "pigpio.c"
  " bits=%08X" "\n" , myTimeStamp(), __FUNCTION__ , (uintptr_t)f, bits); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12210 "pigpio.c" 3 4
  stderr
# 12210 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   gpioGetSamples.ex = 1;
   gpioGetSamples.userdata = userdata;
   gpioGetSamples.func = f;

   if (f) gpioGetSamples.bits = bits;
   else gpioGetSamples.bits = 0;

   monitorBits = alertBits | notifyBits | scriptBits | gpioGetSamples.bits;

   return 0;
}




static int intGpioSetTimerFunc(unsigned id,
                               unsigned millis,
                               void *f,
                               int user,
                               void *userdata)
{
   pthread_attr_t pthAttr;

   { if ((gpioCfg.dbgLevel >= 5) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12235 "pigpio.c" 3 4
  stderr
# 12235 "pigpio.c"
  , "%s %s: " "id=%d millis=%d function=%08"
# 12235 "pigpio.c" 3 4
  "l" "X"
# 12235 "pigpio.c"
  " user=%d userdata=%08"
# 12235 "pigpio.c" 3 4
  "l" "X" 
# 12235 "pigpio.c"
  "\n" , myTimeStamp(), __FUNCTION__ , id, millis, (uintptr_t)f, user, (uintptr_t)userdata); }
                                                          ;

   gpioTimer[id].id = id;

   if (f)
   {
      gpioTimer[id].func = f;
      gpioTimer[id].ex = user;
      gpioTimer[id].userdata = userdata;
      gpioTimer[id].millis = millis;

      if (!gpioTimer[id].running)
      {
         if (pthread_attr_init(&pthAttr))
            do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12250 "pigpio.c" 3 4
           stderr
# 12250 "pigpio.c"
           , "%s %s: " "pthread_attr_init failed (%m)" "\n" , myTimeStamp(), __FUNCTION__); }; return -14; } while (0)
                                               ;

         if (pthread_attr_setstacksize(&pthAttr, (256*1024)))
            do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12254 "pigpio.c" 3 4
           stderr
# 12254 "pigpio.c"
           , "%s %s: " "pthread_attr_setstacksize failed (%m)" "\n" , myTimeStamp(), __FUNCTION__); }; return -14; } while (0)
                                                       ;

         if (pthread_create(
            &gpioTimer[id].pthId, &pthAttr, pthTimerTick, &gpioTimer[id]))
               do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12259 "pigpio.c" 3 4
              stderr
# 12259 "pigpio.c"
              , "%s %s: " "timer %d, create failed (%m)" "\n" , myTimeStamp(), __FUNCTION__ , id); }; return -14; } while (0)
                                                     ;

         gpioTimer[id].running = 1;
      }
   }
   else
   {
      if (gpioTimer[id].running)
      {



         if (pthread_self() == gpioTimer[id].pthId)
         {
            gpioTimer[id].running = 0;
            gpioTimer[id].func = 0;
            pthread_exit(
# 12276 "pigpio.c" 3 4
                        ((void *)0)
# 12276 "pigpio.c"
                            );
         }
         else
         {
            if (pthread_cancel(gpioTimer[id].pthId))
               do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12281 "pigpio.c" 3 4
              stderr
# 12281 "pigpio.c"
              , "%s %s: " "timer %d, cancel failed (%m)" "\n" , myTimeStamp(), __FUNCTION__ , id); }; return -14; } while (0);

            if (pthread_join(gpioTimer[id].pthId, 
# 12283 "pigpio.c" 3 4
                                                 ((void *)0)
# 12283 "pigpio.c"
                                                     ))
               do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12284 "pigpio.c" 3 4
              stderr
# 12284 "pigpio.c"
              , "%s %s: " "timer %d, join failed (%m)" "\n" , myTimeStamp(), __FUNCTION__ , id); }; return -14; } while (0);

            gpioTimer[id].running = 0;
            gpioTimer[id].func = 0;
         }
      }
   }

   return 0;
}




int gpioSetTimerFunc(unsigned id, unsigned millis, gpioTimerFunc_t f)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12300 "pigpio.c" 3 4
  stderr
# 12300 "pigpio.c"
  , "%s %s: " "id=%d millis=%d function=%08"
# 12300 "pigpio.c" 3 4
  "l" "X" 
# 12300 "pigpio.c"
  "\n" , myTimeStamp(), __FUNCTION__ , id, millis, (uintptr_t)f); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12302 "pigpio.c" 3 4
  stderr
# 12302 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (id > 9)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12305 "pigpio.c" 3 4
     stderr
# 12305 "pigpio.c"
     , "%s %s: " "bad timer id (%d)" "\n" , myTimeStamp(), __FUNCTION__ , id); }; return -9; } while (0);

   if ((millis < 10) || (millis > 60000))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12308 "pigpio.c" 3 4
     stderr
# 12308 "pigpio.c"
     , "%s %s: " "timer %d, bad millis (%d)" "\n" , myTimeStamp(), __FUNCTION__ , id, millis); }; return -10; } while (0);

   intGpioSetTimerFunc(id, millis, f, 0, 
# 12310 "pigpio.c" 3 4
                                        ((void *)0)
# 12310 "pigpio.c"
                                            );

   return 0;
}




int gpioSetTimerFuncEx(unsigned id, unsigned millis, gpioTimerFuncEx_t f,
                       void * userdata)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12321 "pigpio.c" 3 4
  stderr
# 12321 "pigpio.c"
  , "%s %s: " "id=%d millis=%d function=%08"
# 12321 "pigpio.c" 3 4
  "l" "X"
# 12321 "pigpio.c"
  ", userdata=%08"
# 12321 "pigpio.c" 3 4
  "l" "X" 
# 12321 "pigpio.c"
  "\n" , myTimeStamp(), __FUNCTION__ , id, millis, (uintptr_t)f, (uintptr_t)userdata); }
                                                    ;

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12324 "pigpio.c" 3 4
  stderr
# 12324 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (id > 9)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12327 "pigpio.c" 3 4
     stderr
# 12327 "pigpio.c"
     , "%s %s: " "bad timer id (%d)" "\n" , myTimeStamp(), __FUNCTION__ , id); }; return -9; } while (0);

   if ((millis < 10) || (millis > 60000))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12330 "pigpio.c" 3 4
     stderr
# 12330 "pigpio.c"
     , "%s %s: " "timer %d, bad millis (%d)" "\n" , myTimeStamp(), __FUNCTION__ , id, millis); }; return -10; } while (0);

   intGpioSetTimerFunc(id, millis, f, 1, userdata);

   return 0;
}



pthread_t *gpioStartThread(gpioThreadFunc_t f, void *userdata)
{
   pthread_t *pth;
   pthread_attr_t pthAttr;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12344 "pigpio.c" 3 4
  stderr
# 12344 "pigpio.c"
  , "%s %s: " "f=%08"
# 12344 "pigpio.c" 3 4
  "l" "X"
# 12344 "pigpio.c"
  ", userdata=%08"
# 12344 "pigpio.c" 3 4
  "l" "X" 
# 12344 "pigpio.c"
  "\n" , myTimeStamp(), __FUNCTION__ , (uintptr_t)f, (uintptr_t)userdata); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12346 "pigpio.c" 3 4
  stderr
# 12346 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return (
# 12346 "pigpio.c" 3 4
  ((void *)0)
# 12346 "pigpio.c"
  ); } } while (0);

   pth = malloc(sizeof(pthread_t));

   if (pth)
   {
      if (pthread_attr_init(&pthAttr))
      {
         free(pth);
         do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12355 "pigpio.c" 3 4
        stderr
# 12355 "pigpio.c"
        , "%s %s: " "pthread_attr_init failed" "\n" , myTimeStamp(), __FUNCTION__); }; return 
# 12355 "pigpio.c" 3 4
        ((void *)0)
# 12355 "pigpio.c"
        ; } while (0);
      }

      if (pthread_attr_setstacksize(&pthAttr, (256*1024)))
      {
         free(pth);
         do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12361 "pigpio.c" 3 4
        stderr
# 12361 "pigpio.c"
        , "%s %s: " "pthread_attr_setstacksize failed" "\n" , myTimeStamp(), __FUNCTION__); }; return 
# 12361 "pigpio.c" 3 4
        ((void *)0)
# 12361 "pigpio.c"
        ; } while (0);
      }

      if (pthread_create(pth, &pthAttr, f, userdata))
      {
         free(pth);
         do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12367 "pigpio.c" 3 4
        stderr
# 12367 "pigpio.c"
        , "%s %s: " "pthread_create failed" "\n" , myTimeStamp(), __FUNCTION__); }; return 
# 12367 "pigpio.c" 3 4
        ((void *)0)
# 12367 "pigpio.c"
        ; } while (0);
      }
   }
   return pth;
}



void gpioStopThread(pthread_t *pth)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12377 "pigpio.c" 3 4
  stderr
# 12377 "pigpio.c"
  , "%s %s: " "pth=%08"
# 12377 "pigpio.c" 3 4
  "l" "X" 
# 12377 "pigpio.c"
  "\n" , myTimeStamp(), __FUNCTION__ , (uintptr_t)pth); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12379 "pigpio.c" 3 4
  stderr
# 12379 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; } } while (0);

   if (pth)
   {
      if (pthread_self() == *pth)
      {
         free(pth);
         pthread_exit(
# 12386 "pigpio.c" 3 4
                     ((void *)0)
# 12386 "pigpio.c"
                         );
      }
      else
      {
         pthread_cancel(*pth);
         pthread_join(*pth, 
# 12391 "pigpio.c" 3 4
                           ((void *)0)
# 12391 "pigpio.c"
                               );
         free(pth);
      }
   }
}



int gpioStoreScript(char *script)
{
   static pthread_mutex_t mutex = 
# 12401 "pigpio.c" 3 4
                                 { { 0, 0, 0, 0, PTHREAD_MUTEX_TIMED_NP, 0, { 0, 0 } } }
# 12401 "pigpio.c"
                                                          ;
   gpioScript_t *s;
   int status, slot, i;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12405 "pigpio.c" 3 4
  stderr
# 12405 "pigpio.c"
  , "%s %s: " "script=[%s]" "\n" , myTimeStamp(), __FUNCTION__ , script); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12407 "pigpio.c" 3 4
  stderr
# 12407 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   slot = -1;

   pthread_mutex_lock(&mutex);

   for (i=0; i<32; i++)
   {
      if (gpioScript[i].state == 0)
      {
         slot = i;
         gpioScript[slot].state = 1;
         break;
      }
   }

   pthread_mutex_unlock(&mutex);

   if (slot < 0) do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12425 "pigpio.c" 3 4
                stderr
# 12425 "pigpio.c"
                , "%s %s: " "no room for scripts" "\n" , myTimeStamp(), __FUNCTION__); }; return -57; } while (0);

   s = &gpioScript[slot];

   status = cmdParseScript(script, &s->script, 0);

   if (status == 0)
   {
      s->request = 0;
      s->run_state = 0;

      pthread_cond_init(&s->pthCond, 
# 12436 "pigpio.c" 3 4
                                    ((void *)0)
# 12436 "pigpio.c"
                                        );
      pthread_mutex_init(&s->pthMutex, 
# 12437 "pigpio.c" 3 4
                                      ((void *)0)
# 12437 "pigpio.c"
                                          );

      s->id = slot;

      gpioScript[slot].state = 2;

      s->pthIdp = gpioStartThread(pthScript, s);

      status = slot;
   }
   else
   {
      if (s->script.par) free(s->script.par);
      s->script.par = 
# 12450 "pigpio.c" 3 4
                     ((void *)0)
# 12450 "pigpio.c"
                         ;
      gpioScript[slot].state = 0;
   }

   return status;
}




int gpioRunScript(unsigned script_id, unsigned numParam, uint32_t *param)
{
   int status = 0;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12464 "pigpio.c" 3 4
  stderr
# 12464 "pigpio.c"
  , "%s %s: " "script_id=%d numParam=%d param=%08"
# 12464 "pigpio.c" 3 4
  "l" "X" 
# 12464 "pigpio.c"
  "\n" , myTimeStamp(), __FUNCTION__ , script_id, numParam, (uintptr_t)param); }
                                            ;

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12467 "pigpio.c" 3 4
  stderr
# 12467 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (script_id >= 32)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12470 "pigpio.c" 3 4
     stderr
# 12470 "pigpio.c"
     , "%s %s: " "bad script id(%d)" "\n" , myTimeStamp(), __FUNCTION__ , script_id); }; return -48; } while (0);

   if (numParam > 10)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12473 "pigpio.c" 3 4
     stderr
# 12473 "pigpio.c"
     , "%s %s: " "bad number of parameters(%d)" "\n" , myTimeStamp(), __FUNCTION__ , numParam); }; return -61; } while (0);

   if (gpioScript[script_id].state == 2)
   {
      pthread_mutex_lock(&gpioScript[script_id].pthMutex);

      if (gpioScript[script_id].run_state != 0)
      {
         if ((numParam > 0) && (param != 0))
         {
            memcpy(gpioScript[script_id].script.par, param,
               sizeof(uint32_t) * numParam);
         }

         gpioScript[script_id].request = 1;

         pthread_cond_signal(&gpioScript[script_id].pthCond);
      }
      else
      {
         status = -62;
      }

      pthread_mutex_unlock(&gpioScript[script_id].pthMutex);

      return status;
   }
   else
   {
      return -48;
   }
}




int gpioUpdateScript(unsigned script_id, unsigned numParam, uint32_t *param)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12511 "pigpio.c" 3 4
  stderr
# 12511 "pigpio.c"
  , "%s %s: " "script_id=%d numParam=%d param=%08"
# 12511 "pigpio.c" 3 4
  "l" "X" 
# 12511 "pigpio.c"
  "\n" , myTimeStamp(), __FUNCTION__ , script_id, numParam, (uintptr_t)param); }
                                            ;

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12514 "pigpio.c" 3 4
  stderr
# 12514 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (script_id >= 32)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12517 "pigpio.c" 3 4
     stderr
# 12517 "pigpio.c"
     , "%s %s: " "bad script id(%d)" "\n" , myTimeStamp(), __FUNCTION__ , script_id); }; return -48; } while (0);

   if (numParam > 10)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12520 "pigpio.c" 3 4
     stderr
# 12520 "pigpio.c"
     , "%s %s: " "bad number of parameters(%d)" "\n" , myTimeStamp(), __FUNCTION__ , numParam); }; return -61; } while (0);

   if (gpioScript[script_id].state == 2)
   {
      if ((numParam > 0) && (param != 0))
      {
         memcpy(gpioScript[script_id].script.par, param,
            sizeof(uint32_t) * numParam);
      }
   }
   else
   {
      return -48;
   }

   return 0;
}




int gpioScriptStatus(unsigned script_id, uint32_t *param)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12543 "pigpio.c" 3 4
  stderr
# 12543 "pigpio.c"
  , "%s %s: " "script_id=%d param=%08"
# 12543 "pigpio.c" 3 4
  "l" "X" 
# 12543 "pigpio.c"
  "\n" , myTimeStamp(), __FUNCTION__ , script_id, (uintptr_t)param); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12545 "pigpio.c" 3 4
  stderr
# 12545 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (script_id >= 32)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12548 "pigpio.c" 3 4
     stderr
# 12548 "pigpio.c"
     , "%s %s: " "bad script id(%d)" "\n" , myTimeStamp(), __FUNCTION__ , script_id); }; return -48; } while (0);

   if (gpioScript[script_id].state == 2)
   {
      if (param != 
# 12552 "pigpio.c" 3 4
                  ((void *)0)
# 12552 "pigpio.c"
                      )
      {
         memcpy(param, gpioScript[script_id].script.par,
            sizeof(uint32_t) * 10);
      }

      return gpioScript[script_id].run_state;
   }
   else return -48;
}




int gpioStopScript(unsigned script_id)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12568 "pigpio.c" 3 4
  stderr
# 12568 "pigpio.c"
  , "%s %s: " "script_id=%d" "\n" , myTimeStamp(), __FUNCTION__ , script_id); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12570 "pigpio.c" 3 4
  stderr
# 12570 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (script_id >= 32)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12573 "pigpio.c" 3 4
     stderr
# 12573 "pigpio.c"
     , "%s %s: " "bad script id(%d)" "\n" , myTimeStamp(), __FUNCTION__ , script_id); }; return -48; } while (0);

   if (gpioScript[script_id].state == 2)
   {
      pthread_mutex_lock(&gpioScript[script_id].pthMutex);

      gpioScript[script_id].request = 0;

      if (gpioScript[script_id].run_state == 3)
      {
         pthread_cond_signal(&gpioScript[script_id].pthCond);
      }

      pthread_mutex_unlock(&gpioScript[script_id].pthMutex);

      return 0;
   }
   else return -48;
}



int gpioDeleteScript(unsigned script_id)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12597 "pigpio.c" 3 4
  stderr
# 12597 "pigpio.c"
  , "%s %s: " "script_id=%d" "\n" , myTimeStamp(), __FUNCTION__ , script_id); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12599 "pigpio.c" 3 4
  stderr
# 12599 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (script_id >= 32)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12602 "pigpio.c" 3 4
     stderr
# 12602 "pigpio.c"
     , "%s %s: " "bad script id(%d)" "\n" , myTimeStamp(), __FUNCTION__ , script_id); }; return -48; } while (0);

   if (gpioScript[script_id].state == 2)
   {
      gpioScript[script_id].state = 3;

      pthread_mutex_lock(&gpioScript[script_id].pthMutex);

      gpioScript[script_id].request = 0;

      if (gpioScript[script_id].run_state == 3)
      {
         pthread_cond_signal(&gpioScript[script_id].pthCond);
      }

      pthread_mutex_unlock(&gpioScript[script_id].pthMutex);

      while (gpioScript[script_id].run_state == 2)
      {
         myGpioSleep(0, 5000);
      }

      gpioStopThread(gpioScript[script_id].pthIdp);

      if (gpioScript[script_id].script.par)
         free(gpioScript[script_id].script.par);

      gpioScript[script_id].script.par = 
# 12629 "pigpio.c" 3 4
                                        ((void *)0)
# 12629 "pigpio.c"
                                            ;

      gpioScript[script_id].state = 0;

      return 0;
   }
   else return -48;
}





int gpioSetSignalFunc(unsigned signum, gpioSignalFunc_t f)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12644 "pigpio.c" 3 4
  stderr
# 12644 "pigpio.c"
  , "%s %s: " "signum=%d function=%08"
# 12644 "pigpio.c" 3 4
  "l" "X" 
# 12644 "pigpio.c"
  "\n" , myTimeStamp(), __FUNCTION__ , signum, (uintptr_t)f); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12646 "pigpio.c" 3 4
  stderr
# 12646 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (signum > 63)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12649 "pigpio.c" 3 4
     stderr
# 12649 "pigpio.c"
     , "%s %s: " "bad signum (%d)" "\n" , myTimeStamp(), __FUNCTION__ , signum); }; return -22; } while (0);

   gpioSignal[signum].ex = 0;
   gpioSignal[signum].userdata = 
# 12652 "pigpio.c" 3 4
                                ((void *)0)
# 12652 "pigpio.c"
                                    ;

   gpioSignal[signum].func = f;

   return 0;
}




int gpioSetSignalFuncEx(unsigned signum, gpioSignalFuncEx_t f,
                        void *userdata)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12665 "pigpio.c" 3 4
  stderr
# 12665 "pigpio.c"
  , "%s %s: " "signum=%d function=%08"
# 12665 "pigpio.c" 3 4
  "l" "X"
# 12665 "pigpio.c"
  " userdata=%08"
# 12665 "pigpio.c" 3 4
  "l" "X" 
# 12665 "pigpio.c"
  "\n" , myTimeStamp(), __FUNCTION__ , signum, (uintptr_t)f, (uintptr_t)userdata); }
                                                ;

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12668 "pigpio.c" 3 4
  stderr
# 12668 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (signum > 63)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12671 "pigpio.c" 3 4
     stderr
# 12671 "pigpio.c"
     , "%s %s: " "bad signum (%d)" "\n" , myTimeStamp(), __FUNCTION__ , signum); }; return -22; } while (0);

   gpioSignal[signum].ex = 1;
   gpioSignal[signum].userdata = userdata;

   gpioSignal[signum].func = f;

   return 0;
}




uint32_t gpioRead_Bits_0_31(void)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12686 "pigpio.c" 3 4
  stderr
# 12686 "pigpio.c"
  , "%s %s: " "" "\n" , myTimeStamp(), __FUNCTION__); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12688 "pigpio.c" 3 4
  stderr
# 12688 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   return (*(gpioReg + 13));
}




uint32_t gpioRead_Bits_32_53(void)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12698 "pigpio.c" 3 4
  stderr
# 12698 "pigpio.c"
  , "%s %s: " "" "\n" , myTimeStamp(), __FUNCTION__); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12700 "pigpio.c" 3 4
  stderr
# 12700 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   return (*(gpioReg + 14));
}




int gpioWrite_Bits_0_31_Clear(uint32_t bits)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12710 "pigpio.c" 3 4
  stderr
# 12710 "pigpio.c"
  , "%s %s: " "bits=%08X" "\n" , myTimeStamp(), __FUNCTION__ , bits); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12712 "pigpio.c" 3 4
  stderr
# 12712 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   *(gpioReg + 10) = bits;

   return 0;
}




int gpioWrite_Bits_32_53_Clear(uint32_t bits)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12724 "pigpio.c" 3 4
  stderr
# 12724 "pigpio.c"
  , "%s %s: " "bits=%08X" "\n" , myTimeStamp(), __FUNCTION__ , bits); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12726 "pigpio.c" 3 4
  stderr
# 12726 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   *(gpioReg + 11) = bits;

   return 0;
}




int gpioWrite_Bits_0_31_Set(uint32_t bits)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12738 "pigpio.c" 3 4
  stderr
# 12738 "pigpio.c"
  , "%s %s: " "bits=%08X" "\n" , myTimeStamp(), __FUNCTION__ , bits); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12740 "pigpio.c" 3 4
  stderr
# 12740 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   *(gpioReg + 7) = bits;

   return 0;
}




int gpioWrite_Bits_32_53_Set(uint32_t bits)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12752 "pigpio.c" 3 4
  stderr
# 12752 "pigpio.c"
  , "%s %s: " "bits=%08X" "\n" , myTimeStamp(), __FUNCTION__ , bits); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12754 "pigpio.c" 3 4
  stderr
# 12754 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   *(gpioReg + 8) = bits;

   return 0;
}



int gpioHardwareClock(unsigned gpio, unsigned frequency)
{
   int cctl[] = {28, 30, 32};
   int cdiv[] = {29, 31, 33};
   int csrc[2] = {1, 6};
   uint32_t cfreq[2]={clk_osc_freq, clk_plld_freq};
   unsigned clock, mode, mash;
   int password = 0;
   double f;
   clkInf_t clkInf={0,0,0};

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12774 "pigpio.c" 3 4
  stderr
# 12774 "pigpio.c"
  , "%s %s: " "gpio=%d frequency=%d" "\n" , myTimeStamp(), __FUNCTION__ , gpio, frequency); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12776 "pigpio.c" 3 4
  stderr
# 12776 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if ((gpio >> 24) == 0x5A) password = 1;

   gpio &= 0xFFFFFF;

   if (gpio > 53)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12783 "pigpio.c" 3 4
     stderr
# 12783 "pigpio.c"
     , "%s %s: " "bad gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio); }; return -3; } while (0);

   if (!clkDef[gpio])
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12786 "pigpio.c" 3 4
     stderr
# 12786 "pigpio.c"
     , "%s %s: " "bad gpio for clock (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio); }; return -94; } while (0);

   if (((frequency < hw_clk_min_freq) ||
        (frequency > hw_clk_max_freq)) &&
        (frequency))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12791 "pigpio.c" 3 4
     stderr
# 12791 "pigpio.c"
     , "%s %s: " "bad hardware clock frequency %d-%d: (%d)" "\n" , myTimeStamp(), __FUNCTION__ , hw_clk_min_freq, hw_clk_max_freq, frequency); }; return -98; } while (0)

                                                        ;

   clock = (clkDef[gpio] >> 4) & 3;

   if ((clock == 1) && (!password))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12798 "pigpio.c" 3 4
     stderr
# 12798 "pigpio.c"
     , "%s %s: " "Need password to use clock 1 (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio); }; return -99; } while (0)
                                                   ;

   mode = clkDef[gpio] & 7;
   mash = frequency < 23800000 ? 1 : 0;

   if (frequency)
   {
      if (chooseBestClock(&clkInf, frequency, 2, cfreq))
      {
         if (clkInf.frac == 0) mash = 0;

         initHWClk(cctl[clock], cdiv[clock],
            csrc[clkInf.clock], clkInf.div, clkInf.frac, mash);

         myGpioSetMode(gpio, mode);

         gpioInfo[gpio].is = 4;

         f = (double) cfreq[clkInf.clock] /
           ((double)clkInf.div + ((double)clkInf.frac / 4096.0));

         hw_clk_freq[clock] = (f + 0.5);

         { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12822 "pigpio.c" 3 4
        stderr
# 12822 "pigpio.c"
        , "%s %s: " "cf=%d div=%d frac=%d mash=%d" "\n" , myTimeStamp(), __FUNCTION__ , cfreq[clkInf.clock], clkInf.div, clkInf.frac, mash); }
                                                               ;
      }
      else
      {
         do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12827 "pigpio.c" 3 4
        stderr
# 12827 "pigpio.c"
        , "%s %s: " "bad hardware clock frequency %d-%d: (%d)" "\n" , myTimeStamp(), __FUNCTION__ , hw_clk_min_freq, hw_clk_max_freq, frequency); }; return -98; } while (0)

                                                           ;
      }
   }
   else
   {

      clkReg[cctl[clock]] = (0x5A<<24) | (1 <<5);

      if (gpioInfo[gpio].is == 4)
         gpioInfo[gpio].is = 0;
   }

   return 0;
}



int gpioHardwarePWM(
   unsigned gpio, unsigned frequency, unsigned dutycycle)
{
   uint32_t old_PWM_CTL;
   unsigned pwm, mode;
   uint32_t real_range, real_dutycycle;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12853 "pigpio.c" 3 4
  stderr
# 12853 "pigpio.c"
  , "%s %s: " "gpio=%d  frequency=%d dutycycle=%d" "\n" , myTimeStamp(), __FUNCTION__ , gpio, frequency, dutycycle); }
                                 ;

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12856 "pigpio.c" 3 4
  stderr
# 12856 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (gpio > 53)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12859 "pigpio.c" 3 4
     stderr
# 12859 "pigpio.c"
     , "%s %s: " "bad gpio (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio); }; return -3; } while (0);

   if (!PWMDef[gpio])
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12862 "pigpio.c" 3 4
     stderr
# 12862 "pigpio.c"
     , "%s %s: " "bad gpio for PWM (%d)" "\n" , myTimeStamp(), __FUNCTION__ , gpio); }; return -95; } while (0);

   if (dutycycle > 1000000)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12865 "pigpio.c" 3 4
     stderr
# 12865 "pigpio.c"
     , "%s %s: " "bad PWM dutycycle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , dutycycle); }; return -97; } while (0);

   if (((frequency < 1) ||
        (frequency > hw_pwm_max_freq)) &&
        (frequency))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12870 "pigpio.c" 3 4
     stderr
# 12870 "pigpio.c"
     , "%s %s: " "bad hardware PWM frequency %d-%d: (%d)" "\n" , myTimeStamp(), __FUNCTION__ , 1, hw_pwm_max_freq, frequency); }; return -96; } while (0)

                                                           ;


   if (gpioCfg.clockPeriph == 0)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12876 "pigpio.c" 3 4
     stderr
# 12876 "pigpio.c"
     , "%s %s: " "illegal, PWM in use for main clock" "\n" , myTimeStamp(), __FUNCTION__); }; return -100; } while (0);

   pwm = (PWMDef[gpio] >> 4) & 3;
   mode = PWMDef[gpio] & 7;

   if (frequency)
   {
      real_range = ((double)clk_plld_freq / (2.0 * frequency)) + 0.5;
      real_dutycycle = ((uint64_t)dutycycle * real_range) / 1000000;



      hw_pwm_freq[pwm] =
         ((double)clk_plld_freq / ( 2.0 * real_range)) + 0.5;

      hw_pwm_duty[pwm] = dutycycle;

      hw_pwm_real_range[pwm] = real_range;



      if (gpioWaveTxBusy()) gpioWaveTxStop();

      waveClockInited = 0;



      old_PWM_CTL = pwmReg[0] &
         ((1<<0) | (1<<7) | (1<<8) | (1<<15));

      if (!PWMClockInited)
      {
         pwmReg[0] = 0;

         myGpioDelay(10);

         initHWClk(40, 41, 6, 2, 0, 0);

         PWMClockInited = 1;
      }

      if (pwm == 0)
      {
         pwmReg[4] = real_range;
         myGpioDelay(10);
         pwmReg[5] = real_dutycycle;
         myGpioDelay(10);

         pwmReg[0] = (old_PWM_CTL | (1<<0) | (1<<7));
      }
      else
      {
         pwmReg[8] = real_range;
         myGpioDelay(10);
         pwmReg[9] = real_dutycycle;
         myGpioDelay(10);

         pwmReg[0] = (old_PWM_CTL | (1<<8) | (1<<15));
      }

      if (gpioInfo[gpio].is != 5)
      {
         switchFunctionOff(gpio);

         myGpioSetMode(gpio, mode);

         gpioInfo[gpio].is = 5;
      }
   }
   else
   {


      if (gpioInfo[gpio].is == 5)
      {
         if (pwm == 0) pwmReg[0] &= (~(1<<0));
         else pwmReg[0] &= (~(1<<8));

         gpioInfo[gpio].is = 0;
      }
   }

   return 0;
}


int gpioSetPad(unsigned pad, unsigned padStrength)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12964 "pigpio.c" 3 4
  stderr
# 12964 "pigpio.c"
  , "%s %s: " "pad=%d  padStrength=%d" "\n" , myTimeStamp(), __FUNCTION__ , pad, padStrength); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12966 "pigpio.c" 3 4
  stderr
# 12966 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (pad > 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12969 "pigpio.c" 3 4
     stderr
# 12969 "pigpio.c"
     , "%s %s: " "bad pad number (%d)" "\n" , myTimeStamp(), __FUNCTION__ , pad); }; return -126; } while (0);

   if ((padStrength < 1) ||
       (padStrength > 16))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12973 "pigpio.c" 3 4
     stderr
# 12973 "pigpio.c"
     , "%s %s: " "bad pad drive strength (%d)" "\n" , myTimeStamp(), __FUNCTION__ , pad); }; return -127; } while (0);



   padStrength += 1;
   padStrength /= 2;
   padStrength -= 1;

   padsReg[11+pad] = (0x5A<<24) | 0x18 | (padStrength & 7) ;

   return 0;
}

int gpioGetPad(unsigned pad)
{
   int strength;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12990 "pigpio.c" 3 4
  stderr
# 12990 "pigpio.c"
  , "%s %s: " "pad=%d" "\n" , myTimeStamp(), __FUNCTION__ , pad); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12992 "pigpio.c" 3 4
  stderr
# 12992 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (pad > 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 12995 "pigpio.c" 3 4
     stderr
# 12995 "pigpio.c"
     , "%s %s: " "bad pad (%d)" "\n" , myTimeStamp(), __FUNCTION__ , pad); }; return -126; } while (0);

   strength = padsReg[11+pad] & 7;

   strength *= 2;
   strength += 2;

   return strength;
}

int shell(char *scriptName, char *scriptString)
{
   int status;
   char buf[4096];

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13010 "pigpio.c" 3 4
  stderr
# 13010 "pigpio.c"
  , "%s %s: " "name=%s string=%s" "\n" , myTimeStamp(), __FUNCTION__ , scriptName, scriptString); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13012 "pigpio.c" 3 4
  stderr
# 13012 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (!myScriptNameValid(scriptName))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13015 "pigpio.c" 3 4
     stderr
# 13015 "pigpio.c"
     , "%s %s: " "bad script name (%s)" "\n" , myTimeStamp(), __FUNCTION__ , scriptName); }; return -140; } while (0);

   snprintf(buf, sizeof(buf),
      "/opt/pigpio/cgi/%s %s", scriptName, scriptString);

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13020 "pigpio.c" 3 4
  stderr
# 13020 "pigpio.c"
  , "%s %s: " "%s" "\n" , myTimeStamp(), __FUNCTION__ , buf); };

   status = system(buf);

   if (status < 0) status = -139;

   return status;
}


int fileApprove(char *filename)
{
   char match[512];
   char buffer[512];
   char line[512];
   char mperm=0;
   char perm;
   char term;
   FILE *f;

   buffer[0] = 0;
   match[0] = 0;

   f = fopen("/opt/pigpio/access", "r");

   if (!f) return 0;

   while (!feof(f))
   {
      buffer[0] = 0;
      perm = 0;
      term = 0;
      if (fgets(line, sizeof(line), f))
      {
         sscanf(line, " %511s %c%c", buffer, &perm, &term);
         if (term == 10)
         {
            if (myPathBad(buffer)) continue;

            if (fnmatch(buffer, filename, 0) == 0)
            {
               if (match[0])
               {
                  if (fnmatch(match, buffer, 0) == 0)
                  {
                     strcpy(match, buffer);
                     mperm = perm;
                  }
               }
               else
               {
                  strcpy(match, buffer);
                  mperm = perm;
               }
            }
         }
      }
   }

   fclose(f);

   if (match[0])
   {
      switch (
# 13083 "pigpio.c" 3 4
             (__extension__ ({ int __res; if (sizeof (
# 13083 "pigpio.c"
             mperm
# 13083 "pigpio.c" 3 4
             ) > 1) { if (__builtin_constant_p (
# 13083 "pigpio.c"
             mperm
# 13083 "pigpio.c" 3 4
             )) { int __c = (
# 13083 "pigpio.c"
             mperm
# 13083 "pigpio.c" 3 4
             ); __res = __c < -128 || __c > 255 ? __c : (*__ctype_toupper_loc ())[__c]; } else __res = toupper (
# 13083 "pigpio.c"
             mperm
# 13083 "pigpio.c" 3 4
             ); } else __res = (*__ctype_toupper_loc ())[(int) (
# 13083 "pigpio.c"
             mperm
# 13083 "pigpio.c" 3 4
             )]; __res; }))
# 13083 "pigpio.c"
                           )
      {
         case 'R': return 1;
         case 'W': return 2;
         case 'U': return 3;
         default : return 0;
      }
   }

   return 0;
}

int fileOpen(char *file, unsigned mode)
{
   static pthread_mutex_t mutex = 
# 13097 "pigpio.c" 3 4
                                 { { 0, 0, 0, 0, PTHREAD_MUTEX_TIMED_NP, 0, { 0, 0 } } }
# 13097 "pigpio.c"
                                                          ;
   int fd=-1;
   int i, slot, oflag, omode;
   struct stat statbuf;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13102 "pigpio.c" 3 4
  stderr
# 13102 "pigpio.c"
  , "%s %s: " "file=%s mode=%d" "\n" , myTimeStamp(), __FUNCTION__ , file, mode); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13104 "pigpio.c" 3 4
  stderr
# 13104 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if ( (mode < 1) ||
        (mode > 31) ||
        ((mode & 3) == 0) )
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13109 "pigpio.c" 3 4
     stderr
# 13109 "pigpio.c"
     , "%s %s: " "bad mode (%d)" "\n" , myTimeStamp(), __FUNCTION__ , mode); }; return -129; } while (0);

   if ((fileApprove(file) & mode) == 0)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13112 "pigpio.c" 3 4
     stderr
# 13112 "pigpio.c"
     , "%s %s: " "no permission to access file (%s)" "\n" , myTimeStamp(), __FUNCTION__ , file); }; return -137; } while (0);

   slot = -1;

   pthread_mutex_lock(&mutex);

   for (i=0; i<16; i++)
   {
      if (fileInfo[i].state == 0)
      {
         slot = i;
         fileInfo[slot].state = 1;
         break;
      }
   }

   pthread_mutex_unlock(&mutex);

   if (slot < 0) do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13130 "pigpio.c" 3 4
                stderr
# 13130 "pigpio.c"
                , "%s %s: " "no file handles" "\n" , myTimeStamp(), __FUNCTION__); }; return -24; } while (0);

   omode = 0;
   oflag = 0;

   if (mode & 4)
   {
      mode |= 2;
      oflag |= 
# 13138 "pigpio.c" 3 4
              02000
# 13138 "pigpio.c"
                      ;
   }

   if (mode & 8)
   {
      oflag |= 
# 13143 "pigpio.c" 3 4
              0100
# 13143 "pigpio.c"
                     ;
      omode |= (
# 13144 "pigpio.c" 3 4
               0400
# 13144 "pigpio.c"
                      |
# 13144 "pigpio.c" 3 4
                       0200
# 13144 "pigpio.c"
                              );
   }

   if (mode & 16)
   {
      mode |= 2;
      oflag |= 
# 13150 "pigpio.c" 3 4
              01000
# 13150 "pigpio.c"
                     ;
   }

   switch(mode&3)
   {
      case 1:
         fd = open(file, 
# 13156 "pigpio.c" 3 4
                        00
# 13156 "pigpio.c"
                                |oflag, omode);
         break;

      case 2:
         fd = open(file, 
# 13160 "pigpio.c" 3 4
                        01
# 13160 "pigpio.c"
                                |oflag, omode);
         break;

      case 3:
         fd = open(file, 
# 13164 "pigpio.c" 3 4
                        02
# 13164 "pigpio.c"
                              |oflag, omode);
         break;
   }

   if (fd == -1)
   {
      fileInfo[slot].state = 0;
      return -128;
   }
   else
   {
      if (stat(file, &statbuf) == 0)
      {
         if (
# 13177 "pigpio.c" 3 4
            ((((
# 13177 "pigpio.c"
            statbuf.st_mode
# 13177 "pigpio.c" 3 4
            )) & 0170000) == (0040000))
# 13177 "pigpio.c"
                                    )
         {
            close(fd);
            fileInfo[slot].state = 0;
            do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13181 "pigpio.c" 3 4
           stderr
# 13181 "pigpio.c"
           , "%s %s: " "file is a directory (%s)" "\n" , myTimeStamp(), __FUNCTION__ , file); }; return -138; } while (0);
         }
      }
   }

   fileInfo[slot].fd = fd;
   fileInfo[slot].mode = mode;
   fileInfo[slot].state = 2;

   return slot;
}

int fileClose(unsigned handle)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13195 "pigpio.c" 3 4
  stderr
# 13195 "pigpio.c"
  , "%s %s: " "handle=%d" "\n" , myTimeStamp(), __FUNCTION__ , handle); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13197 "pigpio.c" 3 4
  stderr
# 13197 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (handle >= 16)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13200 "pigpio.c" 3 4
     stderr
# 13200 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (fileInfo[handle].state != 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13203 "pigpio.c" 3 4
     stderr
# 13203 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (fileInfo[handle].fd >= 0) close(fileInfo[handle].fd);

   fileInfo[handle].fd = -1;
   fileInfo[handle].state = 0;

   return 0;
}

int fileWrite(unsigned handle, char *buf, unsigned count)
{
   int w;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13217 "pigpio.c" 3 4
  stderr
# 13217 "pigpio.c"
  , "%s %s: " "handle=%d count=%d [%s]" "\n" , myTimeStamp(), __FUNCTION__ , handle, count, myBuf2Str(count, buf)); }
                                           ;

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13220 "pigpio.c" 3 4
  stderr
# 13220 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (handle >= 16)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13223 "pigpio.c" 3 4
     stderr
# 13223 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (fileInfo[handle].state != 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13226 "pigpio.c" 3 4
     stderr
# 13226 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (!count)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13229 "pigpio.c" 3 4
     stderr
# 13229 "pigpio.c"
     , "%s %s: " "bad count (%d)" "\n" , myTimeStamp(), __FUNCTION__ , count); }; return -81; } while (0);

   if (!(fileInfo[handle].mode & 2))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13232 "pigpio.c" 3 4
     stderr
# 13232 "pigpio.c"
     , "%s %s: " "file not opened for write" "\n" , myTimeStamp(), __FUNCTION__); }; return -134; } while (0);

   w = write(fileInfo[handle].fd, buf, count);

   if (w != count)
   {
      if (w == -1) { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13238 "pigpio.c" 3 4
                  stderr
# 13238 "pigpio.c"
                  , "%s %s: " "write failed with errno %d" "\n" , myTimeStamp(), __FUNCTION__ , 
# 13238 "pigpio.c" 3 4
                  (*__errno_location ())
# 13238 "pigpio.c"
                  ); };

      return -132;
   }
   return 0;
}

int fileRead(unsigned handle, char *buf, unsigned count)
{
   int r;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13249 "pigpio.c" 3 4
  stderr
# 13249 "pigpio.c"
  , "%s %s: " "handle=%d count=%d buf=0x%"
# 13249 "pigpio.c" 3 4
  "l" "X" 
# 13249 "pigpio.c"
  "\n" , myTimeStamp(), __FUNCTION__ , handle, count, (uintptr_t)buf); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13251 "pigpio.c" 3 4
  stderr
# 13251 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (handle >= 16)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13254 "pigpio.c" 3 4
     stderr
# 13254 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (fileInfo[handle].state != 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13257 "pigpio.c" 3 4
     stderr
# 13257 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (!count)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13260 "pigpio.c" 3 4
     stderr
# 13260 "pigpio.c"
     , "%s %s: " "bad count (%d)" "\n" , myTimeStamp(), __FUNCTION__ , count); }; return -81; } while (0);

   if (!(fileInfo[handle].mode & 1))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13263 "pigpio.c" 3 4
     stderr
# 13263 "pigpio.c"
     , "%s %s: " "file not opened for read" "\n" , myTimeStamp(), __FUNCTION__); }; return -133; } while (0);

   r = read(fileInfo[handle].fd, buf, count);

   if (r == -1)
   {
      { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13269 "pigpio.c" 3 4
     stderr
# 13269 "pigpio.c"
     , "%s %s: " "read failed with errno %d" "\n" , myTimeStamp(), __FUNCTION__ , 
# 13269 "pigpio.c" 3 4
     (*__errno_location ())
# 13269 "pigpio.c"
     ); };
      return -131;
   }
   else
   {
      buf[r] = 0;
      return r;
   }
}


int fileSeek(unsigned handle, int32_t seekOffset, int seekFrom)
{
   int whence, s;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13284 "pigpio.c" 3 4
  stderr
# 13284 "pigpio.c"
  , "%s %s: " "handle=%d offset=%d from=%d" "\n" , myTimeStamp(), __FUNCTION__ , handle, seekOffset, seekFrom); }
                                   ;

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13287 "pigpio.c" 3 4
  stderr
# 13287 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (handle >= 16)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13290 "pigpio.c" 3 4
     stderr
# 13290 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   if (fileInfo[handle].state != 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13293 "pigpio.c" 3 4
     stderr
# 13293 "pigpio.c"
     , "%s %s: " "bad handle (%d)" "\n" , myTimeStamp(), __FUNCTION__ , handle); }; return -25; } while (0);

   switch (seekFrom)
   {
      case 0:
         whence = 
# 13298 "pigpio.c" 3 4
                 0
# 13298 "pigpio.c"
                         ;
         break;

      case 1:
         whence = 
# 13302 "pigpio.c" 3 4
                 1
# 13302 "pigpio.c"
                         ;
         break;

      case 2:
         whence = 
# 13306 "pigpio.c" 3 4
                 2
# 13306 "pigpio.c"
                         ;
         break;

      default:
         do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13310 "pigpio.c" 3 4
        stderr
# 13310 "pigpio.c"
        , "%s %s: " "bad seek from (%d)" "\n" , myTimeStamp(), __FUNCTION__ , seekFrom); }; return -135; } while (0);
   }

   s = lseek(fileInfo[handle].fd, seekOffset, whence);

   if (s == -1)
   {
      { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13317 "pigpio.c" 3 4
     stderr
# 13317 "pigpio.c"
     , "%s %s: " "seek failed with errno %d" "\n" , myTimeStamp(), __FUNCTION__ , 
# 13317 "pigpio.c" 3 4
     (*__errno_location ())
# 13317 "pigpio.c"
     ); };
      return -135;
   }

   return s;
}

int fileList(char *fpat, char *buf, unsigned count)
{
   int len, bufpos;
   glob_t pglob;
   int i;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13330 "pigpio.c" 3 4
  stderr
# 13330 "pigpio.c"
  , "%s %s: " "fpat=%s count=%d buf=%"
# 13330 "pigpio.c" 3 4
  "l" "x" 
# 13330 "pigpio.c"
  "\n" , myTimeStamp(), __FUNCTION__ , fpat, count, (uintptr_t)buf); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13332 "pigpio.c" 3 4
  stderr
# 13332 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (fileApprove(fpat) == 0)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13335 "pigpio.c" 3 4
     stderr
# 13335 "pigpio.c"
     , "%s %s: " "no permission to access file (%s)" "\n" , myTimeStamp(), __FUNCTION__ , fpat); }; return -137; } while (0);

   bufpos = 0;

   if (glob(fpat, 
# 13339 "pigpio.c" 3 4
                 (1 << 1)
# 13339 "pigpio.c"
                          , 
# 13339 "pigpio.c" 3 4
                            ((void *)0)
# 13339 "pigpio.c"
                                , &pglob) == 0)
   {
      for (i=0; i<pglob.gl_pathc; i++)
      {
         len = strlen(pglob.gl_pathv[i]);
         if ((bufpos + len + 1) < count)
         {
            strcpy(buf+bufpos, pglob.gl_pathv[i]);
            bufpos += len;
            buf[bufpos++] = '\n';
         }
      }
   }
   else
   {
      bufpos = -136;
   }

   globfree(&pglob);

   return bufpos;
}





int gpioTime(unsigned timetype, int *seconds, int *micros)
{
   struct timespec ts;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13370 "pigpio.c" 3 4
  stderr
# 13370 "pigpio.c"
  , "%s %s: " "timetype=%d &seconds=%08"
# 13370 "pigpio.c" 3 4
  "l" "X"
# 13370 "pigpio.c"
  " &micros=%08"
# 13370 "pigpio.c" 3 4
  "l" "X" 
# 13370 "pigpio.c"
  "\n" , myTimeStamp(), __FUNCTION__ , timetype, (uintptr_t)seconds, (uintptr_t)micros); }
                                                      ;

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13373 "pigpio.c" 3 4
  stderr
# 13373 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (timetype > 1)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13376 "pigpio.c" 3 4
     stderr
# 13376 "pigpio.c"
     , "%s %s: " "bad timetype (%d)" "\n" , myTimeStamp(), __FUNCTION__ , timetype); }; return -11; } while (0);

   if (timetype == 1)
   {
      clock_gettime(
# 13380 "pigpio.c" 3 4
                   0
# 13380 "pigpio.c"
                                 , &ts);
      *seconds = ts.tv_sec;
      *micros = ts.tv_nsec/1000;
   }
   else
   {
      clock_gettime(
# 13386 "pigpio.c" 3 4
                   0
# 13386 "pigpio.c"
                                 , &ts);

      do { (&ts)->tv_sec = (&ts)->tv_sec - (&libStarted)->tv_sec; (&ts)->tv_nsec = (&ts)->tv_nsec - (&libStarted)->tv_nsec; if ((&ts)->tv_nsec < 0) { --(&ts)->tv_sec; (&ts)->tv_nsec += 1000000000; } } while (0);

      *seconds = ts.tv_sec;
      *micros = ts.tv_nsec/1000;
   }

   return 0;
}




int gpioSleep(unsigned timetype, int seconds, int micros)
{
   struct timespec ts, rem;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13404 "pigpio.c" 3 4
  stderr
# 13404 "pigpio.c"
  , "%s %s: " "timetype=%d seconds=%d micros=%d" "\n" , myTimeStamp(), __FUNCTION__ , timetype, seconds, micros); }
                                ;

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13407 "pigpio.c" 3 4
  stderr
# 13407 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   if (timetype > 1)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13410 "pigpio.c" 3 4
     stderr
# 13410 "pigpio.c"
     , "%s %s: " "bad timetype (%d)" "\n" , myTimeStamp(), __FUNCTION__ , timetype); }; return -11; } while (0);

   if (seconds < 0)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13413 "pigpio.c" 3 4
     stderr
# 13413 "pigpio.c"
     , "%s %s: " "bad seconds (%d)" "\n" , myTimeStamp(), __FUNCTION__ , seconds); }; return -12; } while (0);

   if ((micros < 0) || (micros > 999999))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13416 "pigpio.c" 3 4
     stderr
# 13416 "pigpio.c"
     , "%s %s: " "bad micros (%d)" "\n" , myTimeStamp(), __FUNCTION__ , micros); }; return -13; } while (0);

   ts.tv_sec = seconds;
   ts.tv_nsec = micros * 1000;

   if (timetype == 1)
   {
      while (clock_nanosleep(
# 13423 "pigpio.c" 3 4
                            0
# 13423 "pigpio.c"
                                          , 
# 13423 "pigpio.c" 3 4
                                            1
# 13423 "pigpio.c"
                                                         , &ts, &rem));
   }
   else
   {
      while (clock_nanosleep(
# 13427 "pigpio.c" 3 4
                            0
# 13427 "pigpio.c"
                                          , 0, &ts, &rem))
      {

         ts.tv_sec = rem.tv_sec;
         ts.tv_nsec = rem.tv_nsec;
      }
   }

   return 0;
}




uint32_t gpioDelay(uint32_t micros)
{
   uint32_t start;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13445 "pigpio.c" 3 4
  stderr
# 13445 "pigpio.c"
  , "%s %s: " "microseconds=%u" "\n" , myTimeStamp(), __FUNCTION__ , micros); };

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13447 "pigpio.c" 3 4
  stderr
# 13447 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   start = systReg[1];

   if (micros <= 100)
      while ((systReg[1] - start) <= micros);
   else
      gpioSleep(0, (micros/1000000), (micros%1000000));

   return (systReg[1] - start);
}




uint32_t gpioTick(void)
{
   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13464 "pigpio.c" 3 4
  stderr
# 13464 "pigpio.c"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);

   return systReg[1];
}




unsigned gpioVersion(void)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13474 "pigpio.c" 3 4
  stderr
# 13474 "pigpio.c"
  , "%s %s: " "" "\n" , myTimeStamp(), __FUNCTION__); };

   return 7401;
}
# 13505 "pigpio.c"
unsigned gpioHardwareRevision(void)
{
   static unsigned rev = 0;

   FILE * filp;
   char buf[512];
   char term;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13513 "pigpio.c" 3 4
  stderr
# 13513 "pigpio.c"
  , "%s %s: " "" "\n" , myTimeStamp(), __FUNCTION__); };

   if (rev) return rev;

   filp = fopen ("/proc/cpuinfo", "r");


   if (filp != 
# 13520 "pigpio.c" 3 4
              ((void *)0)
# 13520 "pigpio.c"
                  )
   {
      while (fgets(buf, sizeof(buf), filp) != 
# 13522 "pigpio.c" 3 4
                                             ((void *)0)
# 13522 "pigpio.c"
                                                 )
      {
         if (!strncasecmp("revision\t:", buf, 10))
         {
            if (sscanf(buf+10, "%x%c", &rev, &term) == 2)
            {
               if (term != '\n') rev = 0;
            }
         }
      }
      fclose(filp);
   }



   if (rev == 0)
   {
      { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13539 "pigpio.c" 3 4
     stderr
# 13539 "pigpio.c"
     , "%s %s: " "searching /proc/device-tree for revision" "\n" , myTimeStamp(), __FUNCTION__); };
      filp = fopen ("/proc/device-tree/system/linux,revision", "r");

      if (filp != 
# 13542 "pigpio.c" 3 4
                 ((void *)0)
# 13542 "pigpio.c"
                     )
      {
         uint32_t tmp;
         if (fread(&tmp,1 , 4, filp) == 4)
         {





            rev = 
# 13552 "pigpio.c" 3 4
                 __bswap_32 (
# 13552 "pigpio.c"
                 tmp
# 13552 "pigpio.c" 3 4
                 )
# 13552 "pigpio.c"
                           ;
            rev &= 0xFFFFFF;
         }
      }
      fclose(filp);
   }

   piCores = 0;
   pi_ispi = 0;
   rev &= 0xFFFFFF;



   if ((rev & 0x800000) == 0)
   {
      if (rev < 0x0016)
      {
         pi_ispi = 1;
         piCores = 1;
         pi_peri_phys = 0x20000000;
         pi_dram_bus = 0x40000000;
         pi_mem_flag = 0x0C;
      }
      else
      {
         { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13577 "pigpio.c" 3 4
        stderr
# 13577 "pigpio.c"
        , "%s %s: " "unknown revision=%x" "\n" , myTimeStamp(), __FUNCTION__ , rev); };
         rev = 0;
      }
   }
   else
   {
      switch ((rev >> 12) & 0xF)
      {

         case 0x0:
            pi_ispi = 1;
            piCores = 1;
            pi_peri_phys = 0x20000000;
            pi_dram_bus = 0x40000000;
            pi_mem_flag = 0x0C;
            break;

         case 0x1:
         case 0x2:
            pi_ispi = 1;
            piCores = 4;
            pi_peri_phys = 0x3F000000;
            pi_dram_bus = 0xC0000000;
            pi_mem_flag = 0x04;
            break;

         case 0x3:
            pi_ispi = 1;
            piCores = 4;
            pi_peri_phys = 0xFE000000;
            pi_dram_bus = 0xC0000000;
            pi_mem_flag = 0x04;
            pi_is_2711 = 1;
            clk_osc_freq = 54000000;
            clk_plld_freq = 750000000;
            hw_pwm_max_freq = 187500000;
            hw_clk_min_freq = 13184;
            hw_clk_max_freq = 375000000;
            break;

         default:
            { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13618 "pigpio.c" 3 4
           stderr
# 13618 "pigpio.c"
           , "%s %s: " "unknown rev code (%x)" "\n" , myTimeStamp(), __FUNCTION__ , rev); };
            rev=0;
            pi_ispi = 0;
            break;
      }
   }

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13625 "pigpio.c" 3 4
  stderr
# 13625 "pigpio.c"
  , "%s %s: " "revision=%x" "\n" , myTimeStamp(), __FUNCTION__ , rev); };
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13626 "pigpio.c" 3 4
  stderr
# 13626 "pigpio.c"
  , "%s %s: " "pi_peri_phys=%x" "\n" , myTimeStamp(), __FUNCTION__ , pi_peri_phys); };
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13627 "pigpio.c" 3 4
  stderr
# 13627 "pigpio.c"
  , "%s %s: " "pi_dram_bus=%x" "\n" , myTimeStamp(), __FUNCTION__ , pi_dram_bus); };
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13628 "pigpio.c" 3 4
  stderr
# 13628 "pigpio.c"
  , "%s %s: " "pi_mem_flag=%x" "\n" , myTimeStamp(), __FUNCTION__ , pi_mem_flag); };

   return rev;
}




int gpioCfgBufferSize(unsigned millis)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13638 "pigpio.c" 3 4
  stderr
# 13638 "pigpio.c"
  , "%s %s: " "millis=%d" "\n" , myTimeStamp(), __FUNCTION__ , millis); };

   do { if (libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13640 "pigpio.c" 3 4
  stderr
# 13640 "pigpio.c"
  , "%s %s: " "pigpio initialised, call gpioTerminate()" "\n" , myTimeStamp(), __FUNCTION__); }; return -32; } } while (0);

   if ((millis < 100) || (millis > 10000))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13643 "pigpio.c" 3 4
     stderr
# 13643 "pigpio.c"
     , "%s %s: " "bad millis (%d)" "\n" , myTimeStamp(), __FUNCTION__ , millis); }; return -20; } while (0);

   gpioCfg.bufferMilliseconds = millis;

   return 0;
}




int gpioCfgClock(unsigned micros, unsigned peripheral, unsigned source)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13655 "pigpio.c" 3 4
  stderr
# 13655 "pigpio.c"
  , "%s %s: " "micros=%d peripheral=%d" "\n" , myTimeStamp(), __FUNCTION__ , micros, peripheral); };

   do { if (libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13657 "pigpio.c" 3 4
  stderr
# 13657 "pigpio.c"
  , "%s %s: " "pigpio initialised, call gpioTerminate()" "\n" , myTimeStamp(), __FUNCTION__); }; return -32; } } while (0);

   if ((micros < 1) || (micros > 10))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13660 "pigpio.c" 3 4
     stderr
# 13660 "pigpio.c"
     , "%s %s: " "bad micros (%d)" "\n" , myTimeStamp(), __FUNCTION__ , micros); }; return -19; } while (0);

   if (!clkCfg[micros].valid)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13663 "pigpio.c" 3 4
     stderr
# 13663 "pigpio.c"
     , "%s %s: " "bad micros (%d)" "\n" , myTimeStamp(), __FUNCTION__ , micros); }; return -19; } while (0);

   if (peripheral > 1)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13666 "pigpio.c" 3 4
     stderr
# 13666 "pigpio.c"
     , "%s %s: " "bad peripheral (%d)" "\n" , myTimeStamp(), __FUNCTION__ , peripheral); }; return -17; } while (0);

   gpioCfg.clockMicros = micros;
   gpioCfg.clockPeriph = peripheral;

   return 0;
}




int gpioCfgDMAchannel(unsigned DMAchannel)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13679 "pigpio.c" 3 4
  stderr
# 13679 "pigpio.c"
  , "%s %s: " "channel=%d" "\n" , myTimeStamp(), __FUNCTION__ , DMAchannel); };

   do { if (libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13681 "pigpio.c" 3 4
  stderr
# 13681 "pigpio.c"
  , "%s %s: " "pigpio initialised, call gpioTerminate()" "\n" , myTimeStamp(), __FUNCTION__); }; return -32; } } while (0);

   if ((DMAchannel < 0) || (DMAchannel > 15))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13684 "pigpio.c" 3 4
     stderr
# 13684 "pigpio.c"
     , "%s %s: " "bad channel (%d)" "\n" , myTimeStamp(), __FUNCTION__ , DMAchannel); }; return -27; } while (0);

   gpioCfg.DMAprimaryChannel = DMAchannel;

   return 0;
}




int gpioCfgDMAchannels(unsigned primaryChannel, unsigned secondaryChannel)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13696 "pigpio.c" 3 4
  stderr
# 13696 "pigpio.c"
  , "%s %s: " "primary channel=%d, secondary channel=%d" "\n" , myTimeStamp(), __FUNCTION__ , primaryChannel, secondaryChannel); }
                                       ;

   do { if (libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13699 "pigpio.c" 3 4
  stderr
# 13699 "pigpio.c"
  , "%s %s: " "pigpio initialised, call gpioTerminate()" "\n" , myTimeStamp(), __FUNCTION__); }; return -32; } } while (0);

   if (primaryChannel > 15)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13702 "pigpio.c" 3 4
     stderr
# 13702 "pigpio.c"
     , "%s %s: " "bad primary channel (%d)" "\n" , myTimeStamp(), __FUNCTION__ , primaryChannel); }; return -27; } while (0)
                        ;

   if ((secondaryChannel > 15) ||
         ((secondaryChannel == primaryChannel) &&
            (secondaryChannel != 15)))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13708 "pigpio.c" 3 4
     stderr
# 13708 "pigpio.c"
     , "%s %s: " "bad secondary channel (%d)" "\n" , myTimeStamp(), __FUNCTION__ , secondaryChannel); }; return -30; } while (0)
                          ;

   gpioCfg.DMAprimaryChannel = primaryChannel;
   gpioCfg.DMAsecondaryChannel = secondaryChannel;

   return 0;
}




int gpioCfgPermissions(uint64_t updateMask)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13722 "pigpio.c" 3 4
  stderr
# 13722 "pigpio.c"
  , "%s %s: " "gpio update mask=%"
# 13722 "pigpio.c" 3 4
  "l" "X" 
# 13722 "pigpio.c"
  "\n" , myTimeStamp(), __FUNCTION__ , updateMask); };

   do { if (libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13724 "pigpio.c" 3 4
  stderr
# 13724 "pigpio.c"
  , "%s %s: " "pigpio initialised, call gpioTerminate()" "\n" , myTimeStamp(), __FUNCTION__); }; return -32; } } while (0);

   gpioMask = updateMask;

   gpioMaskSet = 1;

   return 0;
}




int gpioCfgInterfaces(unsigned ifFlags)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13738 "pigpio.c" 3 4
  stderr
# 13738 "pigpio.c"
  , "%s %s: " "ifFlags=%X" "\n" , myTimeStamp(), __FUNCTION__ , ifFlags); };

   do { if (libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13740 "pigpio.c" 3 4
  stderr
# 13740 "pigpio.c"
  , "%s %s: " "pigpio initialised, call gpioTerminate()" "\n" , myTimeStamp(), __FUNCTION__); }; return -32; } } while (0);

   if (ifFlags > 15)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13743 "pigpio.c" 3 4
     stderr
# 13743 "pigpio.c"
     , "%s %s: " "bad ifFlags (%X)" "\n" , myTimeStamp(), __FUNCTION__ , ifFlags); }; return -26; } while (0);

   gpioCfg.ifFlags = ifFlags;

   return 0;
}



int gpioCfgSocketPort(unsigned port)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13754 "pigpio.c" 3 4
  stderr
# 13754 "pigpio.c"
  , "%s %s: " "port=%d" "\n" , myTimeStamp(), __FUNCTION__ , port); };

   do { if (libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13756 "pigpio.c" 3 4
  stderr
# 13756 "pigpio.c"
  , "%s %s: " "pigpio initialised, call gpioTerminate()" "\n" , myTimeStamp(), __FUNCTION__); }; return -32; } } while (0);

   if ((port < 1024) || (port > 32000))
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13759 "pigpio.c" 3 4
     stderr
# 13759 "pigpio.c"
     , "%s %s: " "bad port (%d)" "\n" , myTimeStamp(), __FUNCTION__ , port); }; return -28; } while (0);

   gpioCfg.socketPort = port;

   return 0;
}




int gpioCfgMemAlloc(unsigned memAllocMode)
{
   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13771 "pigpio.c" 3 4
  stderr
# 13771 "pigpio.c"
  , "%s %s: " "memAllocMode=%d" "\n" , myTimeStamp(), __FUNCTION__ , memAllocMode); };

   do { if (libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13773 "pigpio.c" 3 4
  stderr
# 13773 "pigpio.c"
  , "%s %s: " "pigpio initialised, call gpioTerminate()" "\n" , myTimeStamp(), __FUNCTION__); }; return -32; } } while (0);

   if (memAllocMode > 2)
      do { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13776 "pigpio.c" 3 4
     stderr
# 13776 "pigpio.c"
     , "%s %s: " "bad mem alloc mode (%d)" "\n" , myTimeStamp(), __FUNCTION__ , memAllocMode); }; return -104; } while (0)
                                                                     ;

   gpioCfg.memAllocMode = memAllocMode;

   return 0;
}



int gpioCfgNetAddr(int numSockAddr, uint32_t *sockAddr)
{
   int i;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13790 "pigpio.c" 3 4
  stderr
# 13790 "pigpio.c"
  , "%s %s: " "numSockAddr=%d sockAddr=%08"
# 13790 "pigpio.c" 3 4
  "l" "X" 
# 13790 "pigpio.c"
  "\n" , myTimeStamp(), __FUNCTION__ , numSockAddr, (uintptr_t)sockAddr); }
                                       ;

   do { if (libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13793 "pigpio.c" 3 4
  stderr
# 13793 "pigpio.c"
  , "%s %s: " "pigpio initialised, call gpioTerminate()" "\n" , myTimeStamp(), __FUNCTION__); }; return -32; } } while (0);

   if (numSockAddr <= 0) numSockNetAddr = 0;
   else
   {
      if (numSockAddr >= 256)
         numSockAddr = 256;

      for (i=0; i<numSockAddr; i++) sockNetAddr[i] = sockAddr[i];

      numSockNetAddr = numSockAddr;
   }
   return 0;
}




uint32_t gpioCfgGetInternals(void)
{
   return gpioCfg.internals;
}

int gpioCfgSetInternals(uint32_t cfgVal)
{
   gpioCfg.internals = cfgVal;
   gpioCfg.dbgLevel = cfgVal & 0xF;
   gpioCfg.alertFreq = (cfgVal>>4) & 0xF;
   return 0;
}

int gpioCfgInternals(unsigned cfgWhat, unsigned cfgVal)
{
   int retVal = -34;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13828 "pigpio.c" 3 4
  stderr
# 13828 "pigpio.c"
  , "%s %s: " "cfgWhat=%u, cfgVal=%d" "\n" , myTimeStamp(), __FUNCTION__ , cfgWhat, cfgVal); };

   switch(cfgWhat)
   {
      case 562484977:

         if (cfgVal) gpioCfg.internals |= (1<<9);
         else gpioCfg.internals &= (~(1<<9));

         { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13837 "pigpio.c" 3 4
        stderr
# 13837 "pigpio.c"
        , "%s %s: " "show stats is %u" "\n" , myTimeStamp(), __FUNCTION__ , cfgVal); };

         retVal = 0;

         break;

      case 984762879:

         if ((cfgVal >= 0) && (cfgVal <= 8))
         {

            gpioCfg.dbgLevel = cfgVal;
            gpioCfg.internals = (gpioCfg.internals & (~0xF)) | cfgVal;

            { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 13851 "pigpio.c" 3 4
           stderr
# 13851 "pigpio.c"
           , "%s %s: " "Debug level is %u" "\n" , myTimeStamp(), __FUNCTION__ , cfgVal); };

            retVal = 0;
         }

         break;
   }

   return retVal;
}




# 1 "custom.cext" 1
# 10 "custom.cext"
int gpioCustom1(unsigned arg1, unsigned arg2, char *argx, unsigned count)
{
   int i;
   unsigned max;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 15 "custom.cext" 3 4
  stderr
# 15 "custom.cext"
  , "%s %s: " "arg1=%d arg2=%d count=%d [%s]" "\n" , myTimeStamp(), __FUNCTION__ , arg1, arg2, count, myBuf2Str(count, argx)); }
                                                ;

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 18 "custom.cext" 3 4
  stderr
# 18 "custom.cext"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);



   if (arg1 > arg2) max = arg1; else max = arg2;

   for (i=0; i<count; i++) if (argx[i] > max) max = argx[i];

   return max;
}


int gpioCustom2(unsigned arg1, char *argx, unsigned count,
                char *retBuf, unsigned retMax)
{
   int i, j, t;

   { if ((gpioCfg.dbgLevel >= 4) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 35 "custom.cext" 3 4
  stderr
# 35 "custom.cext"
  , "%s %s: " "arg1=%d count=%d [%s] retMax=%d" "\n" , myTimeStamp(), __FUNCTION__ , arg1, count, myBuf2Str(count, argx), retMax); }
                                                  ;

   do { if (!libInitialised) { { if ((gpioCfg.dbgLevel >= 0) && (!(gpioCfg.internals & (1<<10)))) fprintf(
# 38 "custom.cext" 3 4
  stderr
# 38 "custom.cext"
  , "%s %s: " "pigpio uninitialised, call gpioInitialise()" "\n" , myTimeStamp(), __FUNCTION__); }; return -31; } } while (0);



   if (count > retMax) count = retMax;

   for (i=0, j=count-1; i<=j; i++, j--)
   {

      t = argx[i];
      retBuf[i] = argx[j];
      retBuf[j] = t;
   }

   return count;
}
# 13866 "pigpio.c" 2
